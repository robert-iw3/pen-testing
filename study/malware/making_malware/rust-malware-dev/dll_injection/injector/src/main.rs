/*
    DLL Injector [Enhanced Version]
    
*/

use std::env::args;
use std::ffi::CString;
use std::ptr::null_mut;
use winapi::ctypes::c_void;
use winapi::shared::basetsd::ULONG_PTR;
use winapi::shared::minwindef::FALSE;
use winapi::shared::ntdef::NULL;
use winapi::shared::winerror::WAIT_TIMEOUT;
use winapi::um::errhandlingapi::GetLastError;
use winapi::um::handleapi::CloseHandle;
use winapi::um::libloaderapi::{GetModuleHandleA, GetProcAddress};
use winapi::um::memoryapi::{VirtualAllocEx, VirtualFreeEx, WriteProcessMemory};

use winapi::um::processthreadsapi::{
    CreateRemoteThread, GetExitCodeThread, OpenProcess, OpenThread, QueueUserAPC, TerminateThread,
};

use winapi::um::synchapi::WaitForSingleObject;

use winapi::um::tlhelp32::{
    CreateToolhelp32Snapshot, Module32First, Module32Next, Process32First, Process32Next,
    Thread32First, Thread32Next, MODULEENTRY32, PROCESSENTRY32, TH32CS_SNAPMODULE,
    TH32CS_SNAPPROCESS, TH32CS_SNAPTHREAD, THREADENTRY32,
};

use winapi::um::winnt::{
    MEM_COMMIT, MEM_RELEASE, MEM_RESERVE, PAGE_READWRITE, PROCESS_ALL_ACCESS, THREAD_SET_CONTEXT
};

const INVALID_HANDLE_VALUE: *mut c_void = -1isize as *mut c_void;

macro_rules! log {
    ($level:expr, $msg:expr) => {{
        let color = match $level {
            "DEBUG" => "\x1b[94m", // Blue
            "INFO" => "\x1b[32m",  // Green
            "WARN" => "\x1b[33m",  // Yellow
            "ERROR" => "\x1b[31m", // Red
            _ => "\x1b[0m",        // Reset
        };
        match $level {
            "DEBUG" => println!("{}[DEBUG] {}\x1b[0m", color, $msg),
            "INFO" => println!("{}[INFO] {}\x1b[0m", color, $msg),
            "WARN" => println!("{}[WARN] {}\x1b[0m", color, $msg),
            "ERROR" => println!("{}[ERROR] {}\x1b[0m", color, $msg),
            _ => println!("{}{}\x1b[0m", color, $msg),
        }
    }};
}

// Your provided get_pid() function
unsafe fn get_pid(process_name: &str) -> u32 {
    let mut pe: PROCESSENTRY32 = std::mem::zeroed();
    pe.dwSize = std::mem::size_of::<PROCESSENTRY32>() as u32;

    let snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if snap.is_null() {
        log!(
            "ERROR",
            format!(
                "Error while snapshoting processes: Error {}",
                GetLastError()
            )
        );
        std::process::exit(0);
    }

    let mut pid = 0;

    let mut result = Process32First(snap, &mut pe) != 0;

    while result {
        let exe_file = CString::from_vec_unchecked(
            pe.szExeFile
                .iter()
                .map(|&file| file as u8)
                .take_while(|&c| c != 0)
                .collect::<Vec<u8>>(),
        );

        if exe_file.to_str().unwrap() == process_name {
            pid = pe.th32ProcessID;
            break;
        }
        result = Process32Next(snap, &mut pe) != 0;
    }

    if pid == 0 {
        log!(
            "ERROR",
            format!(
                "Unable to get PID for {}: PROCESS DOESNT EXISTS",
                process_name
            )
        );
        std::process::exit(0);
    }

    CloseHandle(snap);
    pid
}

unsafe fn is_module_loaded(pid: u32, dll_path: &str) -> bool {
    let snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid);
    if snapshot == INVALID_HANDLE_VALUE {
        log!("ERROR", "Failed to create module snapshot");
        return false;
    }

    let mut module_entry: MODULEENTRY32 = std::mem::zeroed();
    module_entry.dwSize = std::mem::size_of::<MODULEENTRY32>() as u32;

    if Module32First(snapshot, &mut module_entry) == FALSE {
        CloseHandle(snapshot);
        log!("ERROR", "Failed to get first module");
        return false;
    }

    let dll_name = std::path::Path::new(dll_path)
        .file_name()
        .unwrap()
        .to_str()
        .unwrap()
        .to_lowercase();

    loop {
        let module_name = std::ffi::CStr::from_ptr(module_entry.szModule.as_ptr())
            .to_str()
            .unwrap()
            .to_lowercase();
        if module_name == dll_name {
            CloseHandle(snapshot);
            return true;
        }
        if Module32Next(snapshot, &mut module_entry) == FALSE {
            break;
        }
    }

    CloseHandle(snapshot);
    false
}

unsafe fn inject_dll(process: *mut c_void, dll_path: &str, method: &str, pid: u32) -> bool {
    let dll_path_cstr = match CString::new(dll_path) {
        Ok(path) => path,
        Err(_) => {
            log!(
                "ERROR",
                format!("Failed to convert DLL path '{}' to CString", dll_path)
            );
            return false;
        }
    };

    let dllsize = dll_path.len();

    let buffer = VirtualAllocEx(
        process,
        null_mut(),
        dllsize,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE,
    );
    if buffer.is_null() {
        log!(
            "ERROR",
            format!("Failed to allocate buffer: Error Code {}", GetLastError())
        );
        return false;
    }

    let write_process = WriteProcessMemory(
        process,
        buffer,
        dll_path_cstr.as_ptr() as *const c_void,
        dllsize,
        null_mut(),
    );
    if write_process == 0 {
        log!(
            "ERROR",
            format!(
                "Failed to write DLL path to process memory: Error Code {}",
                GetLastError()
            )
        );
        VirtualFreeEx(process, buffer, 0, MEM_RELEASE);
        return false;
    }

    let kernel32 = GetModuleHandleA("kernel32.dll\0".as_ptr() as *const _);
    if kernel32.is_null() {
        log!(
            "ERROR",
            format!(
                "Failed to get handle to kernel32.dll: Error Code {}",
                GetLastError()
            )
        );
        VirtualFreeEx(process, buffer, 0, MEM_RELEASE);
        return false;
    }

    let load_library_addr = GetProcAddress(kernel32, "LoadLibraryA\0".as_ptr() as *const _);
    if load_library_addr.is_null() {
        log!(
            "ERROR",
            format!(
                "Failed to get address of LoadLibraryA: Error Code {}",
                GetLastError()
            )
        );
        VirtualFreeEx(process, buffer, 0, MEM_RELEASE);
        return false;
    }

    let success = if method == "CRT" {
        let thread = CreateRemoteThread(
            process,
            null_mut(),
            0,
            Some(std::mem::transmute(load_library_addr)),
            buffer,
            0,
            null_mut(),
        );
        if thread.is_null() {
            log!(
                "ERROR",
                format!(
                    "Failed to create remote thread: Error Code {}",
                    GetLastError()
                )
            );
            VirtualFreeEx(process, buffer, 0, MEM_RELEASE);
            return false;
        }

        let wait_result = WaitForSingleObject(thread, 20000);
        if wait_result == WAIT_TIMEOUT {
            log!(
                "WARN",
                "Timeout waiting for thread to complete, terminating it"
            );
            TerminateThread(thread, 0);
        }

        let mut exit_code = 0;
        GetExitCodeThread(thread, &mut exit_code);
        if exit_code == 0x00000103 {
            log!("INFO", "Thread still active, terminating it");
            TerminateThread(thread, 0);
        }

        CloseHandle(thread);
        true
    } else if method == "APC" {
        // Adapted from your working APC code
        let snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, pid);
        if snapshot == INVALID_HANDLE_VALUE {
            log!("ERROR", "Failed to create thread snapshot for APC");
            VirtualFreeEx(process, buffer, 0, MEM_RELEASE);
            return false;
        }

        let mut thread_entry: THREADENTRY32 = std::mem::zeroed();
        thread_entry.dwSize = std::mem::size_of::<THREADENTRY32>() as u32;

        let mut thread_ids: Vec<u32> = Vec::new();

        if Thread32First(snapshot, &mut thread_entry) != 0 {
            loop {
                if thread_entry.th32OwnerProcessID == pid {
                    thread_ids.push(thread_entry.th32ThreadID);
                }
                if Thread32Next(snapshot, &mut thread_entry) == 0 {
                    break;
                }
            }
        }

        CloseHandle(snapshot);

        for thread_id in thread_ids {
            let thread_handle = OpenThread(THREAD_SET_CONTEXT, 0, thread_id);
            if thread_handle.is_null() {
                log!(
                    "WARN",
                    format!(
                        "Failed to open thread {}: Error Code {}",
                        thread_id,
                        GetLastError()
                    )
                );
                continue;
            }

            let apc_result = QueueUserAPC(
                Some(std::mem::transmute(load_library_addr)),
                thread_handle,
                buffer as ULONG_PTR,
            );
            if apc_result == 0 {
                log!(
                    "WARN",
                    format!(
                        "Failed to queue APC for thread {}: Error Code {}",
                        thread_id,
                        GetLastError()
                    )
                );
            }
            CloseHandle(thread_handle);
        }

        std::thread::sleep(std::time::Duration::from_secs(2));
        true
    } else {
        log!("ERROR", format!("Unknown injection method: {}", method));
        false
    };

    VirtualFreeEx(process, buffer, 0, MEM_RELEASE);

    if success && is_module_loaded(pid, dll_path) {
        log!(
            "INFO",
            format!("DLL '{}' successfully loaded into process", dll_path)
        );
    } else if success {
        log!(
            "WARN",
            format!(
                "DLL '{}' not found in process modules after injection",
                dll_path
            )
        );
    }

    success
}

fn main() {
    let args: Vec<String> = args().collect();
    if args.len() < 3 {
        log!(
            "ERROR",
            "Usage: dll_inject.exe <Process Name> <DLL Path 1> [DLL Path 2] ... [--method CRT|APC]"
        );
        return;
    }

    let mut method = "CRT"; 
    let mut dll_paths = Vec::new();
    let mut process_name = "";


    for (i, arg) in args.iter().enumerate() {
        if i == 1 {
            process_name = arg; 
        } else if arg == "--method" {
            if i + 1 < args.len() {
                method = &args[i + 1];
                if method != "CRT" && method != "APC" {
                    log!("ERROR", "Invalid method specified. Use CRT or APC.");
                    return;
                }
            } else {
                log!("ERROR", "Missing method argument after --method");
                return;
            }
        } else if i > 1 && !arg.starts_with("--") && (i == 0 || args[i - 1] != "--method") {
            dll_paths.push(arg.clone());
        }
    }

    if dll_paths.is_empty() {
        log!("ERROR", "No DLL paths provided");
        return;
    }

    unsafe {
        let pid = get_pid(process_name);
        log!(
            "INFO",
            format!("Found PID {} for process '{}'", pid, process_name)
        );

        let process = OpenProcess(PROCESS_ALL_ACCESS, 0, pid);
        if process == NULL {
            let error_code = GetLastError();
            match error_code {
                5 => log!("ERROR", "Access denied. Try running as administrator."),
                87 => log!("ERROR", "Invalid PID or process does not exist."),
                _ => log!(
                    "ERROR",
                    format!("Failed to open process: Error Code {}", error_code)
                ),
            }
            return;
        }

        log!(
            "INFO",
            format!("Opened process {} with handle {:?}", pid, process)
        );

        for dll_path in &dll_paths {
            log!("INFO", format!("Attempting to inject DLL: {}", dll_path));
            if inject_dll(process, dll_path, method, pid) {
                log!("INFO", format!("Injection completed for DLL: {}", dll_path));
            } else {
                log!("ERROR", format!("Failed to inject DLL: {}", dll_path));
            }
        }

        CloseHandle(process);
    }
}
