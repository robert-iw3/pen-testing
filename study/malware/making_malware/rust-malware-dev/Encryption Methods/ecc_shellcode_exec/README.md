## Elliptic Curve Cryptography (ECC) Encryption and decryption.

## Introduction

![ECC Edit](https://github.com/nakov/Practical-Cryptography-for-Developers-Book/blob/master/.gitbook/assets/ecc-visualization-tool.png?raw=true)

Elliptic Curve Cryptography (ECC), which is typically used for secure communications due to its efficiency and high security with smaller keys. 

Jump to the code => [JMP](./src/main.rs)

## Process of Implementation

I implemented ECC in a way that could be useful for malware development by encrypting shellcode with a public key and then decrypting it using both the corresponding private key and an additional component called the R Point. This approach adds an extra layer of security, ensuring that only those with the correct private key and R Point can decrypt and execute the shellcode. 

> Note: Please go through the main function where i explained function features.

I generate random public and private keys then,

I have converted Keys into bytes for ease of handling, then reconstruct these keys for use in encryption and decryption. The encryption process involves using the public key to encrypt the shellcode and generate an R Point, which is serialized into bytes. To decrypt, you need this R Point along with the private key, which together allow the shellcode to be recovered and executed. However, my method of executing the shellcode is basic and could potentially be detected by security software, so more sophisticated execution methods would be necessary for real-world scenarios. 

This Proof of Concept shows how ECC can be adapted for stealthy malware operations by leveraging its inherent security properties.


## Small Snippet to encrypt and decrypt Messages

Write the Encrypt and decrypt function

```
// #![allow(deprecated)]
pub use k256::{elliptic_curve::{sec1::FromEncodedPoint, AffinePoint, Field}, EncodedPoint, ProjectivePoint, Scalar, Secp256k1};
pub use sha2::{Digest, Sha256};
pub use rand::rngs::OsRng;
pub use k256::elliptic_curve::group::GroupEncoding;
pub use k256::ecdsa::VerifyingKey;

fn encode_shellcode(
    shellcode: &[u8],
    public_key: &AffinePoint<Secp256k1>,
) -> (EncodedPoint, Vec<u8>) {
    let mut rng = OsRng;

    // generate the ephemeral keypair
    let k = Scalar::random(&mut rng);
    let r = (ProjectivePoint::generator() * k).to_affine();

    // compute shared secret
    let shared_secret = *public_key * k;
    let shared_secret_bytes = shared_secret.to_bytes();

    // derive encryption key from shared secret
    let mut hasher = Sha256::new();
    hasher.update(shared_secret_bytes);
    let encryption_key = hasher.finalize();

    // Encrypt shellcode
    let encrypted_shellcode: Vec<u8> = shellcode
        .iter()
        .zip(encryption_key.iter().cycle())
        .map(|(&byte, &key)| byte ^ key)
        .collect();

    (EncodedPoint::from(&r), encrypted_shellcode)
}

fn decode_shellcode(
    encrypted_shellcode: &[u8],
    r: &EncodedPoint,
    private_key: &Scalar,
) -> Vec<u8> {
    // Compute shared secret
    let r_point = ProjectivePoint::from_encoded_point(r).expect("Invalid R point");
    let shared_secret = r_point * private_key;
    let shared_secret_bytes = shared_secret.to_bytes();

    // derive decryption key from shared secret
    let mut hasher = Sha256::new();
    hasher.update(shared_secret_bytes);
    let decryption_key = hasher.finalize();

    // Decrypt shellcode
    encrypted_shellcode
        .iter()
        .zip(decryption_key.iter().cycle())
        .map(|(&byte, &key)| byte ^ key)
        .collect()
}
```

Write the main function for operation

```

fn main() {
    // Example string => lets name it as shellcode ie (placeholder)
    let shellcode: &[u8] = b;"Hello, World!"

    // Generate ECC key pair
    let private_key = Scalar::random(&mut OsRng);
    let public_key = (ProjectivePoint::generator() * private_key).to_affine();

    println!("Private Key: {:?}", private_key);
    println!("Public Key: {:?}", public_key);

    // Convert AffinePoint to VerifyingKey (or PublicKey)
    VerifyingKey::from_encoded_point(&EncodedPoint::from(public_key))
        .expect("Invalid public key");

    let (r, encrypted_shellcode) = encode_shellcode(shellcode, &public_key);

    println!("Encrypted Shellcode: {:?}", encrypted_shellcode);

    // Decode the shellcode
    let decrypted_shellcode = decode_shellcode(&encrypted_shellcode, &r, &private_key);

    println!(
        "Decrypted Shellcode: {:?}",
        String::from_utf8(decrypted_shellcode).unwrap()
    );
}
```

## Resource Used

* https://github.com/nakov/practical-cryptography-for-developers-book/blob/master/asymmetric-key-ciphers/elliptic-curve-cryptography-ecc.md
* https://github.com/nakov/Practical-Cryptography-for-Developers-Book/blob/master/asymmetric-key-ciphers/ecc-encryption-decryption.md
#s

By [Smukx.E](https://x.com/5mukx)