using System;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Net.NetworkInformation;
using System.Runtime.InteropServices;
using System.Security.Principal;

namespace ProcDump
{
    internal class Program
    {
        /* ---------------------------------------------------------------------- */
        /* ENUMS
        /* ---------------------------------------------------------------------- */
        private const int ERROR_NOT_ALL_ASSIGNED = 1300; // From winerror.h
        /* ---------------------------------------------------------------------- */

        /* ---------------------------------------------------------------------- */
        /* ENUMS
        /* ---------------------------------------------------------------------- */
        [Flags]
        enum ProcessAccessMask: UInt32
        {
            PROCESS_CREATE_PROCESS = 0x0080,
            PROCESS_QUERY_INFORMATION = 0x0400,
            PROCESS_TERMINATE = 0x0001,
            PROCESS_VM_READ = 0x0010,
            PROCESS_ALL_ACCESS = (UInt32)(0x000F0000L | 0x00100000L | 0xFFFF)
        }

        [Flags]
        enum ProcessCreationFlags: UInt32
        {
            NONE = 0x0,
            PROCESS_CREATE_FLAGS_INHERIT_FROM_PARENT = 0x00000100,
            PROCESS_CREATE_FLAGS_INHERIT_HANDLES = 0x00000004
        }

        [Flags]
        enum FileCreationOptions : UInt32
        {
            FILE_SYNCHRONOUS_IO_NONALERT = 0x00000020
        }

        [Flags]
        enum FileAccessMask : UInt32
        {
            SYNCHRONIZE = 0x00100000,
            WRITE_DATA = 0x2
        }

        [Flags]
        enum FileAttribute : UInt32
        {

            FILE_ATTRIBUTE_READONLY = 0x1,
            FILE_ATTRIBUTE_HIDDEN = 0x2,
            FILE_ATTRIBUTE_SYSTEM = 0x4,
            FILE_ATTRIBUTE_ARCHIVE = 0x20,
            FILE_ATTRIBUTE_ENCRYPTED = 0x4000,
            FILE_ATTRIBUTE_NORMAL = 0x80,
            FILE_ATTRIBUTE_TEMPORARY = 0x100,
            FILE_ATTRIBUTE_OFFLINE = 0x1000
        }

        [Flags]
        enum MinidumpType: UInt32
        {
            MiniDumpNormal = 0x00000000,
            MiniDumpWithDataSegs = 0x00000001,
            MiniDumpWithFullMemory = 0x00000002,
            MiniDumpWithHandleData = 0x00000004,
            MiniDumpFilterMemory = 0x00000008,
            MiniDumpScanMemory = 0x00000010,
            MiniDumpWithUnloadedModules = 0x00000020,
            MiniDumpWithIndirectlyReferencedMemory = 0x00000040,
            MiniDumpFilterModulePaths = 0x00000080,
            MiniDumpWithProcessThreadData = 0x00000100,
            MiniDumpWithPrivateReadWriteMemory = 0x00000200,
            MiniDumpWithoutOptionalData = 0x00000400,
            MiniDumpWithFullMemoryInfo = 0x00000800,
            MiniDumpWithThreadInfo = 0x00001000,
            MiniDumpWithCodeSegs = 0x00002000,
            MiniDumpWithoutAuxiliaryState = 0x00004000,
            MiniDumpWithFullAuxiliaryState = 0x00008000,
            MiniDumpWithPrivateWriteCopyMemory = 0x00010000,
            MiniDumpIgnoreInaccessibleMemory = 0x00020000,
            MiniDumpWithTokenInformation = 0x00040000,
            MiniDumpWithModuleHeaders = 0x00080000,
            MiniDumpFilterTriage = 0x00100000,
            MiniDumpWithAvxXStateContext = 0x00200000,
            MiniDumpWithIptTrace = 0x00400000,
            MiniDumpScanInaccessiblePartialPages = 0x00800000,
            MiniDumpFilterWriteCombinedMemory,
            MiniDumpValidTypeFlags = 0x01ffffff
        }

        [Flags]
        private enum TokenAccessLevels : uint
        {
            Query = 0x0008,
            AdjustPrivileges = 0x0020
        }


        [Flags]
        private enum PrivilegeAttributes : uint
        {
            SE_PRIVILEGE_ENABLED_BY_DEFAULT = 0x00000001,
            SE_PRIVILEGE_ENABLED = 0x00000002,
            SE_PRIVILEGE_REMOVED = 0x00000004,
            SE_PRIVILEGE_USED_FOR_ACCESS = 0x80000000
        }


        /* ---------------------------------------------------------------------- */
        /* STRUCT
        /* ---------------------------------------------------------------------- */
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        struct UNICODE_STRING
        {
            public UInt16 Length;
            public UInt16 MaximumLength;
            public IntPtr Buffer; // type: WCHAR
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        struct OBJECT_ATTRIBUTES
        {
            public UInt32 Length;
            public IntPtr RootDirectory;
            public IntPtr ObjectName; // type: UNICODE_STRING
            public UInt32 Attributes;
            public IntPtr SecurityDescriptor; // PSECURITY_DESCRIPTOR;
            public IntPtr SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        struct CLIENT_ID
        {
            public IntPtr UniqueProcess;
            public IntPtr UniqueThread;
        }

        [StructLayout(LayoutKind.Sequential, Pack = 0)]
        public struct IO_STATUS_BLOCK
        {
            public uint status;
            public IntPtr information;
        }

        [StructLayout(LayoutKind.Sequential, Pack = 4)]
        private struct LUID
        {
            public uint LowPart;
            public int HighPart;
        }

        [StructLayout(LayoutKind.Sequential, Pack = 4)]
        private struct LUID_AND_ATTRIBUTES
        {
            public LUID Luid;
            public PrivilegeAttributes Attributes;
        }

        [StructLayout(LayoutKind.Sequential, Pack = 4)]
        private struct TOKEN_PRIVILEGES
        {
            public uint PrivilegeCount;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)] // Adjust SizeConst if enabling multiple privileges at once.
            public LUID_AND_ATTRIBUTES[] Privileges;
        }


        /* ---------------------------------------------------------------------- */
        /* FUNCTION IMPORTS
        /* ---------------------------------------------------------------------- */
        [DllImport("ntdll.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto, SetLastError = true)]
        private static extern uint NtCreateProcessEx(
            ref IntPtr ProcessHandle,
            ProcessAccessMask DesiredAccess,
            ref OBJECT_ATTRIBUTES ObjectAttributes,
            IntPtr ParentProcess,
            ProcessCreationFlags Flags,
            IntPtr SectionHandle,
            IntPtr DebugPort,
            IntPtr TokenHandle,
            UInt32 Reserved // JobMemberLevel
        );

        [DllImport("ntdll.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto, SetLastError = true)]
        private static extern uint NtOpenProcess(
            ref IntPtr ProcessHandle,
            ProcessAccessMask DesiredAccess,
            ref OBJECT_ATTRIBUTES ObjectAttributes, // PCOBJECT_ATTRIBUTES
            ref CLIENT_ID ClientId // PCLIENT_ID
        );

        [DllImport("ntdll.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto, SetLastError = true)]
        private static extern uint NtCreateFile(
            ref IntPtr FileHandle,
            FileAccessMask DesiredAccess,
            ref OBJECT_ATTRIBUTES ObjectAttributes,
            ref IO_STATUS_BLOCK IoStatusBlock,
            ref UInt64 AllocationSize,
            FileAttribute FileAttributes,
            UInt32 ShareAccess,
            UInt32 CreateDisposition,
            FileCreationOptions CreateOptions,
            IntPtr EaBuffer,
            UInt32 EaLength
        );

        [DllImport("DbgHelp.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto, SetLastError = true)]
        private static extern UInt32 MiniDumpWriteDump(
          IntPtr hProcess,
          UInt32 ProcessId,
          IntPtr hFile,
          MinidumpType DumpType,
          IntPtr ExceptionParam,
          IntPtr UserStreamParam,
          IntPtr CallbackParam
        );

        [DllImport("kernel32.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto, SetLastError = true)]
        private static extern UInt32 GetLastError();

        [DllImport("ntdll.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto, SetLastError = true)]
        private static extern UInt32 NtClose(
            IntPtr Handle
        );

        [DllImport("kernel32.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr GetCurrentProcess();


        [DllImport("advapi32.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto, SetLastError = true)]
        private static extern bool OpenProcessToken(
            IntPtr ProcessHandle,
            TokenAccessLevels DesiredAccess,
            out IntPtr TokenHandle);

        [DllImport("advapi32.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto, SetLastError = true)]
        private static extern bool LookupPrivilegeValue(
            string lpSystemName,
            string lpName,
            out LUID lpLuid);

        [DllImport("advapi32.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto, SetLastError = true)]
        private static extern bool AdjustTokenPrivileges(
           IntPtr TokenHandle,
           bool DisableAllPrivileges,
           [In] ref TOKEN_PRIVILEGES NewState,
           uint BufferLength,
           IntPtr PreviousState, //out TOKEN_PRIVILEGES PreviousState
           IntPtr ReturnLength); //out uint ReturnLength


        /* ---------------------------------------------------------------------- */
        /* HELPER METHODS
        /* ---------------------------------------------------------------------- */
        static OBJECT_ATTRIBUTES CreateEmptyObjectAttributes()
        {
            UInt32 size = (UInt32)Marshal.SizeOf<OBJECT_ATTRIBUTES>();

            OBJECT_ATTRIBUTES objAttributes = new OBJECT_ATTRIBUTES {
                Length = size,
                RootDirectory = IntPtr.Zero,
                ObjectName = IntPtr.Zero, // UNICODE_STRING
                Attributes = 0,
                SecurityDescriptor = IntPtr.Zero,
                SecurityQualityOfService = IntPtr.Zero
            };
            return objAttributes;
        }


        /* ---------------------------------------------------------------------- */
        /* Enable a particular privilege
        /* ---------------------------------------------------------------------- */
        private static bool EnablePrivilege(string privilegeName)
        {
            if (!OpenProcessToken(GetCurrentProcess(), TokenAccessLevels.AdjustPrivileges | TokenAccessLevels.Query, out IntPtr tokenHandle))
            {
                return false;
            }

            LUID luid;
            if (!LookupPrivilegeValue(null, privilegeName, out luid))
            {
                NtClose(tokenHandle);
                return false;
            }

            TOKEN_PRIVILEGES tp = new TOKEN_PRIVILEGES();
            tp.PrivilegeCount = 1;
            tp.Privileges = new LUID_AND_ATTRIBUTES[1];
            tp.Privileges[0].Luid = luid;
            tp.Privileges[0].Attributes = PrivilegeAttributes.SE_PRIVILEGE_ENABLED;

            if (!AdjustTokenPrivileges(tokenHandle, false, ref tp, 0, IntPtr.Zero, IntPtr.Zero))
            {
                NtClose(tokenHandle);
                return false;
            }

            if (Marshal.GetLastWin32Error() == ERROR_NOT_ALL_ASSIGNED)
            {
                NtClose(tokenHandle);
                return false;
            }

            NtClose(tokenHandle);
            return true;
        }


        /* ---------------------------------------------------------------------- */
        /* MAIN
        /* ---------------------------------------------------------------------- */
        static void Main(string[] args)
        {
            // Check and usage
            if (args.Length != 2 || (args.Length > 0 && args[0] == "-h"))
            {
                Console.WriteLine(String.Format("Usage: {0}.exe <PID|Name> PATH_TO_DUMP", Process.GetCurrentProcess().ProcessName));
                return;
            }

            // Initialise values
            IntPtr hParentProcess = IntPtr.Zero;
            IntPtr hCloneProcess = IntPtr.Zero;
            IntPtr hDumpFile = IntPtr.Zero;

            try
            {
                // Find process to clone
                int processToClonePid = 0;
                try
                {
                    processToClonePid = int.Parse(args[0]);
                }
                catch
                {
                    foreach (var process in Process.GetProcesses())
                    {
                        if (process.ProcessName.ToLower() == args[0].ToLower())
                        {
                            processToClonePid = process.Id;
                            break;
                        }
                    }
                }
                if (processToClonePid == 0)
                {
                    throw new Exception("Target process not found");
                }

                // Enable SeDebugPrivilege if it exists
                if (EnablePrivilege("SeDebugPrivilege"))
                {
                    Console.WriteLine("SeDebugPrivilege enabled");
                }
                else
                {
                    Console.WriteLine("SeDebugPrivilege could not be enabled; continuing anyways");
                }


                // Open handle to target process
                OBJECT_ATTRIBUTES parentProcessObjectAttributes = CreateEmptyObjectAttributes();
                CLIENT_ID parentProcessClientId = new CLIENT_ID
                {
                    UniqueProcess = (IntPtr)processToClonePid,
                    UniqueThread = IntPtr.Zero
                };
                UInt32 ntStatus = NtOpenProcess(
                    ref hParentProcess,
                    ProcessAccessMask.PROCESS_CREATE_PROCESS,
                    ref parentProcessObjectAttributes,
                    ref parentProcessClientId
                    );

                if (hParentProcess == IntPtr.Zero || ntStatus != 0)
                {
                    throw new Exception(String.Format("Failed to open target process; NTSTATUS: 0x{0:X}", ntStatus));
                };
                Console.WriteLine(String.Format("Target process opened; handle: 0x{0:X}", hParentProcess));

                // Clone process
                OBJECT_ATTRIBUTES clonedProcessobjectAttributes = CreateEmptyObjectAttributes();

                ntStatus = NtCreateProcessEx(
                    ref hCloneProcess,
                    ProcessAccessMask.PROCESS_ALL_ACCESS,
                    ref clonedProcessobjectAttributes,
                    hParentProcess,
                    ProcessCreationFlags.NONE,
                    IntPtr.Zero,
                    IntPtr.Zero,
                    IntPtr.Zero,
                    0
                    );
                if (hCloneProcess == IntPtr.Zero || ntStatus != 0)
                {
                    throw new Exception(String.Format("Failed to create clone process; NTSTATUS: 0x{0:X}", ntStatus));
                }
                Console.WriteLine(String.Format("Target process cloned; HANDLE: 0x{0:X}", hCloneProcess));

                // Create handle to process dump file
                OBJECT_ATTRIBUTES dumpFileObjectAttributes = CreateEmptyObjectAttributes();
                IO_STATUS_BLOCK dumpFileIoStatusBlock = new IO_STATUS_BLOCK { information = IntPtr.Zero, status = 0 };
                ulong dumpFileAllocationSize = 0;

                //// Set filename
                String dumpFilepath = @"\??\" + Path.GetFullPath(args[1]);
                UNICODE_STRING dumpFilePathUnicodeString = new UNICODE_STRING
                {
                    Buffer = Marshal.StringToHGlobalUni(dumpFilepath),
                    Length = (ushort)(dumpFilepath.Length * 2),
                    MaximumLength = (ushort)((dumpFilepath.Length + 1) * 2)
                };
                int dumpFileUnicodeStringStructSize = Marshal.SizeOf(dumpFilePathUnicodeString);
                IntPtr dumpFilePathUnicodeStringPointer = Marshal.AllocHGlobal(dumpFileUnicodeStringStructSize);
                Marshal.StructureToPtr<UNICODE_STRING>(dumpFilePathUnicodeString, dumpFilePathUnicodeStringPointer, false);
                dumpFileObjectAttributes.ObjectName = dumpFilePathUnicodeStringPointer;

                //// Set OBJ_CASE_INSENSITIVE
                dumpFileObjectAttributes.Attributes = 0x00000040;

                ntStatus = NtCreateFile(
                    ref hDumpFile,
                    FileAccessMask.WRITE_DATA | FileAccessMask.SYNCHRONIZE,
                    ref dumpFileObjectAttributes,
                    ref dumpFileIoStatusBlock,
                    ref dumpFileAllocationSize,
                    FileAttribute.FILE_ATTRIBUTE_NORMAL,
                    0, // SHARE: none
                    0x00000000, // FILE_SUPERSEDE
                    FileCreationOptions.FILE_SYNCHRONOUS_IO_NONALERT,
                    IntPtr.Zero,
                    0
                );
                if (hDumpFile == IntPtr.Zero || ntStatus != 0)
                {
                    throw new Exception(String.Format("Failed to create file handle to new dump file; NTSTATUS: 0x{0:X}", ntStatus));
                }

                // Dump process
                if (MiniDumpWriteDump(
                    hCloneProcess,
                    0,
                    hDumpFile,
                    MinidumpType.MiniDumpWithFullMemory,
                    IntPtr.Zero,
                    IntPtr.Zero,
                    IntPtr.Zero
                ) == 0)
                {
                    throw new Exception(String.Format("Failed to dump cloned process; HRESULT: 0x{0:X}", GetLastError()));
                };
                Console.WriteLine(String.Format("Dump written to: {0}", dumpFilepath));
            }
            catch (Exception e) {
                Console.WriteLine(String.Format("Exception: {0}", e.Message));
            }
            finally
            {
                // Cleanup
                if (hParentProcess != IntPtr.Zero)
                {
                    NtClose(hParentProcess);
                }

                if (hCloneProcess != IntPtr.Zero)
                {
                    NtClose(hCloneProcess);
                }

                if (hDumpFile != IntPtr.Zero)
                {
                    NtClose(hDumpFile);
                }
            }
        }
    }
}
