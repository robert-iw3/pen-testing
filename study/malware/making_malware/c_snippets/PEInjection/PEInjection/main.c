#include "stdio.h"
#include "Windows.h"
#include "winternl.h"

#define MAX_NUM(a, b) a > b ? a : b;
#define MIN_NUM(a, b) a < b ? a : b;

#define MAX_INDIVIDUAL_CMDLINE_ARG_LEN 100

#ifdef _M_X64
#define ADD_OFFSET_TO_POINTER(addr, offset) (PBYTE)addr + (DWORD64)offset
#else
#define ADD_OFFSET_TO_POINTER(addr, offset) (PBYTE)addr + (DWORD)offset
#endif

///////////////////////
// STRUCTS
///////////////////////

typedef struct _ProcessParametersStore {
	WORD commandlineLenOrig;
	PWCHAR commandlineOrig;
} ProcessParametersStore, *PProcessParametersStore;

typedef struct _PEImageFileProcessed {
	IMAGE_FILE_HEADER FileHeader;
	IMAGE_OPTIONAL_HEADER OptionalHeader;

	BOOL IsDll;
	DWORD64 ImageBase; // absolute
	DWORD SizeOfImage;
	DWORD AddressOfEntryPointOffset; // relative

	WORD NumOfSections;
	PIMAGE_SECTION_HEADER SectionHeaderFirst; // absolute

	PIMAGE_DATA_DIRECTORY pDataDirectoryExport;
	PIMAGE_DATA_DIRECTORY pDataDirectoryImport;
	PIMAGE_DATA_DIRECTORY pDataDirectoryReloc;
	PIMAGE_DATA_DIRECTORY pDataDirectoryException;
} PEImageFileProcessed, * PPEImageFileProcessed;

////////////////////
// HELPERS
////////////////////

SIZE_T CharStringToWCharString(IN PCHAR Source, SIZE_T IN MaximumAllowed, OUT PWCHAR Destination)
{
	INT Length = (INT)MaximumAllowed;

	while (--Length >= 0)
	{
		if (!(*Destination++ = *Source++))
			return MaximumAllowed - Length - 1;
	}

	return MaximumAllowed - Length;
}

DWORD StrLen(PCHAR str) {
	DWORD len = 0;
	while (TRUE) {
		if (str[len] == 0) {
			return len;
		}
		else {
			len++;
		}
	}
}

void StrCat(PCHAR destination, PCHAR source, DWORD sourceLenMax) {
	DWORD sourceLenToCopy = MIN_NUM(StrLen(source), sourceLenMax);
	DWORD destinationLen = StrLen(destination);
	for (int i = 0; i < sourceLenToCopy; i++) {
		destination[destinationLen + i] = source[i];
	}
}

void ZeroMemoryCustom(PBYTE address, DWORD len) {
	for (int i = len - 1; i > 0; i--) {
		address[i] = 0;
	}
}

void MemCpy(PBYTE destination, PBYTE source, DWORD len) {
	for (int i = 0; i < len; i++) {
		destination[i] = source[i];
	}
}

///////////////////////
// FUNCTIONS
///////////////////////

void PrintError(IN PCHAR message) {
	printf("%s ; error code: %d\n", message, GetLastError());
}

DWORD64 ReadImageFile(IN PCHAR imagePath, OUT LPVOID* pBufImageFile) {
	*pBufImageFile = NULL;

	// Read image file
	HANDLE hImageFile = CreateFileA(imagePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hImageFile == INVALID_HANDLE_VALUE) {
		PrintError("CreateFile");
		goto _CLEANUP;
	}

	LARGE_INTEGER imageFileSize = {0};
	ZeroMemoryCustom(&imageFileSize, sizeof(imageFileSize));
	GetFileSizeEx(hImageFile, &imageFileSize);
	if (imageFileSize.QuadPart == 0) {
		PrintError("GetFileSize");
		goto _CLEANUP;
	}

	*pBufImageFile = VirtualAlloc(NULL, imageFileSize.QuadPart, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if (*pBufImageFile == NULL) {
		PrintError("VirtualAlloc");
		goto _CLEANUP;
	}

	DWORD numOfBytesRead = 0;
	if ((!ReadFile(hImageFile, *pBufImageFile, imageFileSize.QuadPart, &numOfBytesRead, NULL)) || (numOfBytesRead != imageFileSize.QuadPart)) {
		PrintError("ReadFile");
		goto _CLEANUP;
	}

_CLEANUP:
	if (hImageFile != INVALID_HANDLE_VALUE) {
		CloseHandle(hImageFile);
	}
	return imageFileSize.QuadPart;
}

BOOL ProcessPEFile(IN LPVOID pBufImageFile, OUT PPEImageFileProcessed pPeImageFileProcessed) {
	// Process headers
	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBufImageFile;
	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((DWORD64)pBufImageFile + (pDosHeader->e_lfanew));
	if (!(pNtHeaders->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE)) {
		printf("ProcessPEFile; input file is not a PE\n");
		return FALSE;
	};

	pPeImageFileProcessed->FileHeader = pNtHeaders->FileHeader;
	pPeImageFileProcessed->OptionalHeader = pNtHeaders->OptionalHeader;

	// Process misc
	pPeImageFileProcessed->IsDll = (pNtHeaders->FileHeader.Characteristics & IMAGE_FILE_DLL) ? TRUE : FALSE;
	pPeImageFileProcessed->SizeOfImage = pNtHeaders->OptionalHeader.SizeOfImage;
	pPeImageFileProcessed->ImageBase = pNtHeaders->OptionalHeader.ImageBase;
	pPeImageFileProcessed->AddressOfEntryPointOffset = pNtHeaders->OptionalHeader.AddressOfEntryPoint;

	// Process section headers
	pPeImageFileProcessed->NumOfSections = pNtHeaders->FileHeader.NumberOfSections;
	pPeImageFileProcessed->SectionHeaderFirst = IMAGE_FIRST_SECTION(pNtHeaders);

	// Process required sections explicitly
	pPeImageFileProcessed->pDataDirectoryExport = &(pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]);
	pPeImageFileProcessed->pDataDirectoryImport = &(pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]);
	pPeImageFileProcessed->pDataDirectoryReloc = &(pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC]);
	pPeImageFileProcessed->pDataDirectoryException = &(pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION]);

	return TRUE;
}

void AllocateMemoryForInMemPE(IN DWORD SizeOfImage, OUT LPVOID* pBufInMemPE) {
	*pBufInMemPE = VirtualAlloc(NULL, SizeOfImage, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if (*pBufInMemPE == NULL) {
		PrintError("VirtualAlloc for AllocateMemoryForInMemPE");
	}
}

void CopySectionsToInMemPE(IN PPEImageFileProcessed pPeImageFileProcessed, IN LPVOID pBufImageFile, OUT LPVOID pBufInMemPE) {
	for (int i = 0; i < pPeImageFileProcessed->NumOfSections; i++) {
		IMAGE_SECTION_HEADER SectionHeader = pPeImageFileProcessed->SectionHeaderFirst[i];

		MemCpy(
			(DWORD64)pBufInMemPE + SectionHeader.VirtualAddress,
			(DWORD64)pBufImageFile + SectionHeader.PointerToRawData,
			SectionHeader.SizeOfRawData
		);
	}
}

typedef struct _IMAGE_BASE_RELOCATION_ENTRY {
	WORD Offset : 12;
	WORD Type: 4;
} IMAGE_BASE_RELOCATION_ENTRY, *PIMAGE_BASE_RELOCATION_ENTRY;

void PerformRelocationForInMemPE(IN PPEImageFileProcessed pPeImageFileProcessed, OUT LPVOID pBufInMemPE) {
	PIMAGE_BASE_RELOCATION pImageBaseRelocation = (PIMAGE_BASE_RELOCATION)((DWORD64)pBufInMemPE + pPeImageFileProcessed->pDataDirectoryReloc->VirtualAddress);
	DWORD NumImageBaseRelocationEntry = NULL;
	PIMAGE_BASE_RELOCATION_ENTRY pImageBaseRelocationEntry = NULL;
	DWORD64 relocOffset = (DWORD64)pBufInMemPE - pPeImageFileProcessed->ImageBase;
	DWORD64 relocAt = NULL;

	// For each Base Relocation Block
	while (pImageBaseRelocation->VirtualAddress != NULL) {
		NumImageBaseRelocationEntry = (pImageBaseRelocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(IMAGE_BASE_RELOCATION_ENTRY);
		pImageBaseRelocationEntry = (PIMAGE_BASE_RELOCATION_ENTRY)((DWORD64)pImageBaseRelocation + sizeof(IMAGE_BASE_RELOCATION));
		relocAt = NULL;

		// For each Base Relocation Block Entry
		for (int i = 0; i < NumImageBaseRelocationEntry; i++) {
			relocAt = ADD_OFFSET_TO_POINTER(pBufInMemPE, pImageBaseRelocation->VirtualAddress + pImageBaseRelocationEntry[i].Offset);

			switch (pImageBaseRelocationEntry[i].Type) {
				case IMAGE_REL_BASED_HIGH: // The base relocation adds the high 16 bits of the difference to the 16-bit field at offset. The 16-bit field represents the high value of a 32-bit word.
					*(PWORD)relocAt += HIWORD(relocOffset);
					break;
				case IMAGE_REL_BASED_LOW: // The base relocation adds the low 16 bits of the difference to the 16-bit field at offset. The 16-bit field represents the low half of a 32-bit word.
					*(PWORD)relocAt += LOWORD(relocOffset);
					break;
				case IMAGE_REL_BASED_HIGHLOW: // The base relocation applies all 32 bits of the difference to the 32-bit field at offset.
					*(PDWORD)relocAt += (DWORD)relocOffset;
					break;
				case IMAGE_REL_BASED_DIR64: // The base relocation applies the difference to the 64-bit field at offset.
					*(PDWORD64)relocAt += relocOffset;
					break;
				case IMAGE_REL_BASED_ABSOLUTE: // The base relocation is skipped. This type can be used to pad a block.
				default:
					break;
			}
		}

		// Move on to next relocation block
		pImageBaseRelocation = ADD_OFFSET_TO_POINTER(pImageBaseRelocation, pImageBaseRelocation->SizeOfBlock);
	}
}

BOOL FixImportsForInMemPE(IN PPEImageFileProcessed pPeImageFileProcessed, OUT LPVOID pBufInMemPE) {
	PIMAGE_IMPORT_DESCRIPTOR pImageImportDescriptor = ADD_OFFSET_TO_POINTER(pBufInMemPE, pPeImageFileProcessed->pDataDirectoryImport->VirtualAddress);
	PCHAR dllName = NULL;
	PIMAGE_THUNK_DATA pOriginalFirstThunk = NULL;
	PIMAGE_THUNK_DATA pFirstThunk = NULL;
	BOOL isOrdinal = FALSE;
	HMODULE hModule = INVALID_HANDLE_VALUE;
	PIMAGE_IMPORT_BY_NAME pImageImportByName = { 0 };
	LPVOID funcAddress = NULL;

	// Iterate through Image Import Descriptors
	while (pImageImportDescriptor->FirstThunk != NULL && pImageImportDescriptor->OriginalFirstThunk != NULL) {
		// Get module handle to required DLL
		dllName = ADD_OFFSET_TO_POINTER(pBufInMemPE, pImageImportDescriptor->Name);
		hModule = GetModuleHandleA(dllName);
		if (hModule == INVALID_HANDLE_VALUE || hModule == NULL) {
			hModule = LoadLibraryA(dllName);
			if (hModule == INVALID_HANDLE_VALUE || hModule == NULL) {
				PrintError("GetModuleHandle");
				return FALSE;
			}
		}

		// Iterate through each Thunk
		pOriginalFirstThunk = ADD_OFFSET_TO_POINTER(pBufInMemPE, pImageImportDescriptor->OriginalFirstThunk);
		pFirstThunk = ADD_OFFSET_TO_POINTER(pBufInMemPE, pImageImportDescriptor->FirstThunk);
		funcAddress = NULL;
		while (pOriginalFirstThunk->u1.Function != NULL && pFirstThunk->u1.Function) {
			isOrdinal = ((pOriginalFirstThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG) == 0) ? FALSE : TRUE;
			if (isOrdinal) {
				funcAddress = GetProcAddress(hModule, IMAGE_ORDINAL(pOriginalFirstThunk->u1.Ordinal));
			}
			else {
				pImageImportByName = ADD_OFFSET_TO_POINTER(pBufInMemPE, pOriginalFirstThunk->u1.AddressOfData);
				funcAddress = GetProcAddress(hModule, pImageImportByName->Name);
			}
			if (funcAddress == NULL) {
				PrintError("GetProcAddress");
				return FALSE;
			}
			pFirstThunk->u1.Function = funcAddress;

			// Move on to next thunk
			pOriginalFirstThunk++;
			pFirstThunk++;
		}

		// Move on to next Image Import Descriptor
		pImageImportDescriptor++;
	}

	return TRUE;
}

BOOL AssignCorrectPagePerms(IN PPEImageFileProcessed pPeImageFileProcessed, OUT LPVOID pBufInMemPE) {
	IMAGE_SECTION_HEADER SectionHeader = {0};
	DWORD newProtection = NULL, oldProtection = NULL;

	// Iterate through each Section header
	for (int i = 0; i < pPeImageFileProcessed->NumOfSections; i++) {
		SectionHeader = pPeImageFileProcessed->SectionHeaderFirst[i];

		/*
		* TODO:
		PAGE_EXECUTE_WRITECOPY
		PAGE_WRITECOPY
		*/

		// Get correct permission to set
		if ((SectionHeader.Characteristics & IMAGE_SCN_MEM_EXECUTE) && !(SectionHeader.Characteristics & IMAGE_SCN_MEM_READ) && !(SectionHeader.Characteristics & IMAGE_SCN_MEM_WRITE)) {
			newProtection = PAGE_EXECUTE;
		}
		else if ((SectionHeader.Characteristics & IMAGE_SCN_MEM_EXECUTE) && (SectionHeader.Characteristics & IMAGE_SCN_MEM_READ) && !(SectionHeader.Characteristics & IMAGE_SCN_MEM_WRITE)) {
			newProtection = PAGE_EXECUTE_READ;
		}
		else if ((SectionHeader.Characteristics & IMAGE_SCN_MEM_EXECUTE) && (SectionHeader.Characteristics & IMAGE_SCN_MEM_READ) && (SectionHeader.Characteristics & IMAGE_SCN_MEM_WRITE)) {
			newProtection = PAGE_EXECUTE_READWRITE;
		}
		else if (!(SectionHeader.Characteristics & IMAGE_SCN_MEM_EXECUTE) && (SectionHeader.Characteristics & IMAGE_SCN_MEM_READ) && !(SectionHeader.Characteristics & IMAGE_SCN_MEM_WRITE)) {
			newProtection = PAGE_READONLY;
		}
		else if (!(SectionHeader.Characteristics & IMAGE_SCN_MEM_EXECUTE) && (SectionHeader.Characteristics & IMAGE_SCN_MEM_READ) && (SectionHeader.Characteristics & IMAGE_SCN_MEM_WRITE)) {
			newProtection = PAGE_READWRITE;
		}
		else {
			return FALSE;
		}

		// Set correct permission
		if (!VirtualProtect(
			ADD_OFFSET_TO_POINTER(pBufInMemPE, SectionHeader.VirtualAddress),
			SectionHeader.SizeOfRawData,
			newProtection,
			&oldProtection
		)) {
			PrintError("VirtualProtect");
			return FALSE;
		}
	}
	return TRUE;
}

BOOL RegisterExceptionHandlers(IN PPEImageFileProcessed pPeImageFileProcessed, OUT LPVOID pBufInMemPE) {
	if (pPeImageFileProcessed->pDataDirectoryException->VirtualAddress != NULL) {
		PRUNTIME_FUNCTION pFunctionTable = ADD_OFFSET_TO_POINTER(pBufInMemPE, pPeImageFileProcessed->pDataDirectoryException->VirtualAddress);
		if (!RtlAddFunctionTable(
			pFunctionTable,
			(pPeImageFileProcessed->pDataDirectoryException->Size / sizeof(RUNTIME_FUNCTION)),
			pBufInMemPE
		)) {
			PrintError("RtlAddFunctionTable");
			return FALSE;
		}
		else {
			return TRUE;
		}
	}
}

PPEB GetCurrentPEB() {
#ifdef _M_X64
	return (PPEB)__readgsqword(12 * sizeof(PVOID));
#else
	return (PPEB)__readfsdword(12 * sizeof(PVOID));
#endif
}

void FixCommandLine(PProcessParametersStore pProcessParamsStore, PCHAR pInMemPeArgs) {
	// Get current PE's command-line args
	PPEB pPeb = GetCurrentPEB();

	// Save original command line
	ZeroMemoryCustom(pProcessParamsStore, sizeof(ProcessParametersStore));
	pProcessParamsStore->commandlineLenOrig = pPeb->ProcessParameters->CommandLine.Length;
	pProcessParamsStore->commandlineOrig = VirtualAlloc(NULL, pPeb->ProcessParameters->CommandLine.Length, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if (pProcessParamsStore->commandlineOrig != NULL) {
		MemCpy(pProcessParamsStore->commandlineOrig, pPeb->ProcessParameters->CommandLine.Buffer, pPeb->ProcessParameters->CommandLine.Length);
	}

	// If there are no command line args to be passed to the in-mem PE
	if (pInMemPeArgs == NULL) {
		pPeb->ProcessParameters->CommandLine.Length = 0;
		pPeb->ProcessParameters->CommandLine.MaximumLength = 0;
		ZeroMemoryCustom(pPeb->ProcessParameters->CommandLine.Buffer, pProcessParamsStore->commandlineLenOrig);
	}
	// If there are command line args to be passed to the in-mem PE
	else {
		// Prepare new command line
		DWORD inMemPeArgsWLen = pPeb->ProcessParameters->ImagePathName.Length + (StrLen(pInMemPeArgs) * sizeof(WCHAR)) + (3 * sizeof(WCHAR)); // Image file path + args to in-mem PE + null terminator + 2 double-quotes + one space
		PWCHAR pInMemPeArgsW = VirtualAlloc(NULL, inMemPeArgsWLen, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
		if (pInMemPeArgsW == NULL) return;
		ZeroMemoryCustom(pInMemPeArgsW, inMemPeArgsWLen);
		MemCpy(pInMemPeArgsW + 0, L"\"", 1);
		MemCpy(pInMemPeArgsW + 1, pPeb->ProcessParameters->ImagePathName.Buffer, pPeb->ProcessParameters->ImagePathName.Length);
		MemCpy(pInMemPeArgsW + (pPeb->ProcessParameters->ImagePathName.Length / 2) + 1, L"\"", 1);
		MemCpy(pInMemPeArgsW + (pPeb->ProcessParameters->ImagePathName.Length / 2) + 2, L" ", 1);
		CharStringToWCharString(pInMemPeArgs, StrLen(pInMemPeArgs), pInMemPeArgsW + (pPeb->ProcessParameters->ImagePathName.Length / 2) + 3);

		// Set new command line len
		pPeb->ProcessParameters->CommandLine.Length = inMemPeArgsWLen;
		pPeb->ProcessParameters->CommandLine.MaximumLength = inMemPeArgsWLen;

		// Set new command line
		ZeroMemoryCustom(pPeb->ProcessParameters->CommandLine.Buffer, pProcessParamsStore->commandlineLenOrig);
		MemCpy(pPeb->ProcessParameters->CommandLine.Buffer, pInMemPeArgsW, inMemPeArgsWLen);
		ZeroMemoryCustom(pInMemPeArgsW, inMemPeArgsWLen);
		VirtualFree(pInMemPeArgsW, 0, MEM_RELEASE);
	}
}

void RestoreCommandLine(PProcessParametersStore pProcessParamsStore) {
	// Get current PE's command-line args
	PPEB pPeb = GetCurrentPEB();

	// Restore original command line
	pPeb->ProcessParameters->CommandLine.Length = pProcessParamsStore->commandlineLenOrig;
	MemCpy(pPeb->ProcessParameters->CommandLine.Buffer, pProcessParamsStore->commandlineOrig, pProcessParamsStore->commandlineLenOrig * sizeof(WCHAR));

	// Cleanup saved command line buffer
	ZeroMemoryCustom(pProcessParamsStore->commandlineOrig, pProcessParamsStore->commandlineLenOrig);
	VirtualFree(pProcessParamsStore->commandlineOrig, 0, MEM_RELEASE);
}

typedef BOOL(*DLLMAIN)(HINSTANCE, DWORD, LPVOID);
typedef BOOL(*MAIN)(DWORD, PCHAR);

void JumpToEntry(IN PPEImageFileProcessed pPeImageFileProcessed, IN LPVOID pBufInMemPE) {
	LPVOID pEntry = ADD_OFFSET_TO_POINTER(pBufInMemPE, pPeImageFileProcessed->AddressOfEntryPointOffset);
	// For DLL
	if (pPeImageFileProcessed->IsDll) {
		((DLLMAIN)pEntry)(pBufInMemPE, DLL_PROCESS_ATTACH, NULL);
	}
	// For other executables
	else {
		((MAIN)pEntry)(1, NULL);
	}
}

void LoadPELocally(PCHAR imageFilePath, PCHAR pInMemPeArgs) {
	// Map imagefile content to memory
	DWORD64 pBufImageFile = NULL;
	DWORD64 bufImageFileSize = ReadImageFile(imageFilePath, &pBufImageFile);
	if (bufImageFileSize == 0) goto _CLEANUP;

	// Process image file
	PEImageFileProcessed peImageFileProcessed;
	BOOL isProcessPEFileSuccess = ProcessPEFile(pBufImageFile, &peImageFileProcessed);
	if (!isProcessPEFileSuccess) goto _CLEANUP;

	// Allocate memory for in-mem image
	DWORD64 pBufInMemPE = NULL;
	AllocateMemoryForInMemPE(peImageFileProcessed.SizeOfImage, &pBufInMemPE);
	if (pBufInMemPE == NULL) goto _CLEANUP;

	// Copy over sections
	CopySectionsToInMemPE(&peImageFileProcessed, pBufImageFile, pBufInMemPE);

	// Perform relocations
	PerformRelocationForInMemPE(&peImageFileProcessed, pBufInMemPE);

	// Perform import fixes
	if(!FixImportsForInMemPE(&peImageFileProcessed, pBufInMemPE)) goto _CLEANUP;

	// Assign correct page access to sections
	if (!AssignCorrectPagePerms(&peImageFileProcessed, pBufInMemPE)) goto _CLEANUP;

	// Register exception handlers
	if (!RegisterExceptionHandlers(&peImageFileProcessed, pBufInMemPE)) goto _CLEANUP;

	// Fix command line for in-mem PE
	ProcessParametersStore processParamsStore;
	FixCommandLine(&processParamsStore, pInMemPeArgs);

	// Jump to entry
	JumpToEntry(&peImageFileProcessed, pBufInMemPE);

	// Restore command line
	RestoreCommandLine(&processParamsStore);

_CLEANUP:
	// Cleanup PE file buffer
	if (pBufImageFile != NULL) {
		ZeroMemoryCustom(pBufImageFile, bufImageFileSize);
		if (!VirtualFree(pBufImageFile, 0, MEM_RELEASE)) {
			PrintError("VirtualFree");
		}
	}
	// Cleanup in-mem PE buffer
	if (pBufInMemPE != NULL) {
		ZeroMemoryCustom(pBufInMemPE, peImageFileProcessed.SizeOfImage);
		if (!VirtualFree(pBufInMemPE, 0, MEM_RELEASE)) {
			PrintError("VirtualFree");
		}
	}
}

//////////////////
// MAIN
//////////////////

void main(int argc, char* argv[]) {
	if (argc == 1) {
		printf("Usage: PEInjection.exe PATH_TO_PE_FILE [ARGS_TO_PE]\n");
	}
	else {
		// Get image file path for the in-mem PE
		PCHAR imageFilePath = argv[1];

		// Get command arguments for the in-mem PE
		PCHAR pInMemPeArgs = NULL;
		if (argc > 2) {
			int inMemPeArgsLen = 0;
			for (int i = 2; i < argc; i++) {
				inMemPeArgsLen += StrLen(argv[i]) + 1; // one-extra for the space
			}
			pInMemPeArgs = VirtualAlloc(NULL, inMemPeArgsLen, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
			if (pInMemPeArgs == NULL) {
				PrintError("VirtualAlloc");
				return;
			}
			ZeroMemoryCustom(pInMemPeArgs, inMemPeArgsLen);
			for (int i = 2; i < argc; i++) {
				StrCat(pInMemPeArgs, argv[i], MAX_INDIVIDUAL_CMDLINE_ARG_LEN);
				if (i != argc - 1) {
					StrCat(pInMemPeArgs, " ", 1);
				}
			}
		}

		// Load PE locally
		LoadPELocally(imageFilePath, pInMemPeArgs); // <-- This is an independent function; only needs correct input; no cleanup needed for itself

		// Cleanup for main
		if(pInMemPeArgs != 0) VirtualFree(pInMemPeArgs, 0, MEM_RELEASE);
	}
}