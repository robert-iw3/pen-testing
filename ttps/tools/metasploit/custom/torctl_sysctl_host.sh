#!/bin/bash

# configure sysctl on host machine running docker container

set -eux

# rhel
dnf install iptables -y

# debian
#apt-get install iptables -y

# exclude locals
TOR_EXCLUDE="192.168.0.0/16 172.16.0.0/12 10.0.0.0/8"

# tor uid
TOR_UID="tor"

# tor socks port
TOR_PORT="9040"

# tor dns port
TOR_DNS="9053"

BACKUPDIR="/var/lib/torctl"

check_root() {
    if [ $(id -u) -ne 0 ]; then
        err "This script must be run as root"
    fi
}

check_backup_dir() {
    if [ ! -d $BACKUPDIR ]; then
        mkdir -p $BACKUPDIR
    fi
}

flush_iptables() {
    iptables -F
    iptables -t nat -F
}

gen_resolv_conf() {
    warn "configuring nameservers"
    cat >"/etc/resolv.conf" <<EOF
# generated by torctl
nameserver 127.0.0.1
nameserver 1.1.1.1
nameserver 1.0.0.1
nameserver 208.67.222.222
nameserver 208.67.220.220
nameserver 8.8.8.8
nameserver 8.8.4.4
EOF
    chmod 644 /etc/resolv.conf
    msg "configured nameservers"
}

check_backup_dir() {
    if [ ! -d $BACKUPDIR ]; then
        mkdir -p $BACKUPDIR
    fi
}

backup_resolv_conf() {
    info "backing up nameservers"
    mv /etc/resolv.conf $BACKUPDIR/resolv.conf.bak
    msg "backed up nameservers"
}

backup_iptables() {
    info "backing up iptables rules"
    iptables-save >$BACKUPDIR/iptables.rules.bak
    msg "backed up iptables rules"
}

backup_sysctl() {
    info "backing up sysctl rules"
    sysctl -a >$BACKUPDIR/sysctl.conf.bak
    msg "backed up sysctl rules"
}

apply_iptables_rules() {
    info "applying iptables rules"

    # set iptables nat
    iptables -t nat -A OUTPUT -m owner --uid-owner $TOR_UID -j RETURN
    # set dns redirect
    iptables -t nat -A OUTPUT -p udp --dport 53 -j REDIRECT --to-ports $TOR_DNS
    iptables -t nat -A OUTPUT -p tcp --dport 53 -j REDIRECT --to-ports $TOR_DNS
    iptables -t nat -A OUTPUT -p udp -m owner --uid-owner $TOR_UID -m udp --dport 53 -j REDIRECT --to-ports $TOR_DNS

    # resolve .onion domains mapping 10.192.0.0/10 address space
    iptables -t nat -A OUTPUT -p tcp -d 10.192.0.0/10 -j REDIRECT --to-ports $TOR_PORT
    iptables -t nat -A OUTPUT -p udp -d 10.192.0.0/10 -j REDIRECT --to-ports $TOR_PORT
    # exclude locals
    for NET in $TOR_EXCLUDE 127.0.0.0/9 127.128.0.0/10; do
        iptables -t nat -A OUTPUT -d $NET -j RETURN
        iptables -A OUTPUT -d "$NET" -j ACCEPT
    done

    # redirect all other output through tor
    iptables -t nat -A OUTPUT -p tcp --syn -j REDIRECT --to-ports $TOR_PORT
    iptables -t nat -A OUTPUT -p udp -j REDIRECT --to-ports $TOR_PORT
    iptables -t nat -A OUTPUT -p icmp -j REDIRECT --to-ports $TOR_PORT

    # accept already established connections
    iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

    # allow only tor output
    iptables -A OUTPUT -m owner --uid-owner $TOR_UID -j ACCEPT
    iptables -A OUTPUT -j REJECT

    msg "applied iptables rules"
}

apply_sysctl_rules() {
    info "applying sysctl rules"

    # Disable Explicit Congestion Notification in TCP
    sysctl -w net.ipv4.tcp_ecn=0 &>"/dev/null"

    # window scaling
    sysctl -w net.ipv4.tcp_window_scaling=1 &>"/dev/null"

    # increase linux autotuning tcp buffer limits
    sysctl -w net.ipv4.tcp_rmem="8192 87380 16777216" &>"/dev/null"
    sysctl -w net.ipv4.tcp_wmem="8192 65536 16777216" &>"/dev/null"

    # increase TCP max buffer size
    sysctl -w net.core.rmem_max=16777216 &>"/dev/null"
    sysctl -w net.core.wmem_max=16777216 &>"/dev/null"

    # Increase number of incoming connections backlog
    sysctl -w net.core.netdev_max_backlog=16384 &>"/dev/null"
    sysctl -w net.core.dev_weight=64 &>"/dev/null"

    # Increase number of incoming connections
    sysctl -w net.core.somaxconn=32768 &>"/dev/null"

    # Increase the maximum amount of option memory buffers
    sysctl -w net.core.optmem_max=65535 &>"/dev/null"

    # Increase the tcp-time-wait buckets pool size to prevent simple DOS attacks
    sysctl -w net.ipv4.tcp_max_tw_buckets=1440000 &>"/dev/null"

    # try to reuse time-wait connections, but don't recycle them
    # (recycle can break clients behind NAT)
    sysctl -w net.ipv4.tcp_tw_reuse=1 &>"/dev/null"

    # Limit number of orphans, each orphan can eat up to 16M (max wmem)
    # of unswappable memory
    sysctl -w net.ipv4.tcp_max_orphans=16384 &>"/dev/null"
    sysctl -w net.ipv4.tcp_orphan_retries=0 &>"/dev/null"

    # don't cache ssthresh from previous connection
    sysctl -w net.ipv4.tcp_no_metrics_save=1 &>"/dev/null"
    sysctl -w net.ipv4.tcp_moderate_rcvbuf=1 &>"/dev/null"

    # Increase size of RPC datagram queue length
    sysctl -w net.unix.max_dgram_qlen=50 &>"/dev/null"

    # Don't allow the arp table to become bigger than this
    sysctl -w net.ipv4.neigh.default.gc_thresh3=2048 &>"/dev/null"

    # Tell the gc when to become aggressive with arp table cleaning.
    # Adjust this based on size of the LAN. 1024 is suitable for most
    # /24 networks
    sysctl -w net.ipv4.neigh.default.gc_thresh2=1024 &>"/dev/null"

    # Adjust where the gc will leave arp table alone - set to 32.
    sysctl -w net.ipv4.neigh.default.gc_thresh1=32 &>"/dev/null"

    # Adjust to arp table gc to clean-up more often
    sysctl -w net.ipv4.neigh.default.gc_interval=30 &>"/dev/null"

    # Increase TCP queue length
    sysctl -w net.ipv4.neigh.default.proxy_qlen=96 &>"/dev/null"
    sysctl -w net.ipv4.neigh.default.unres_qlen=6 &>"/dev/null"

    # Enable Explicit Congestion Notification (RFC 3168), disable it
    # if it doesn't work for you
    sysctl -w net.ipv4.tcp_ecn=1 &>"/dev/null"
    sysctl -w net.ipv4.tcp_reordering=3 &>"/dev/null"

    # How many times to retry killing an alive TCP connection
    sysctl -w net.ipv4.tcp_retries2=15 &>"/dev/null"
    sysctl -w net.ipv4.tcp_retries1=3 &>"/dev/null"

    # Avoid falling back to slow start after a connection goes idle
    # keeps our cwnd large with the keep alive connections (kernel > 3.6)
    sysctl -w net.ipv4.tcp_slow_start_after_idle=0 &>"/dev/null"

    # Allow the TCP fastopen flag to be used,
    # beware some firewalls do not like TFO! (kernel > 3.7)
    sysctl -w net.ipv4.tcp_fastopen=3 &>"/dev/null"

    # This will enusre that immediatly subsequent connections use the new values
    sysctl -w net.ipv4.route.flush=1 &>"/dev/null"
    sysctl -w net.ipv6.route.flush=1 &>"/dev/null"

    # TCP SYN cookie protection
    sysctl -w net.ipv4.tcp_syncookies=1 &>"/dev/null"

    # TCP rfc1337
    sysctl -w net.ipv4.tcp_rfc1337=1 &>"/dev/null"

    # Reverse path filtering
    sysctl -w net.ipv4.conf.default.rp_filter=1 &>"/dev/null"
    sysctl -w net.ipv4.conf.all.rp_filter=1 &>"/dev/null"

    # Log martian packets
    sysctl -w net.ipv4.conf.default.log_martians=1 &>"/dev/null"
    sysctl -w net.ipv4.conf.all.log_martians=1 &>"/dev/null"

    # Disable ICMP redirecting
    sysctl -w net.ipv4.conf.all.accept_redirects=0 &>"/dev/null"
    sysctl -w net.ipv4.conf.default.accept_redirects=0 &>"/dev/null"
    sysctl -w net.ipv4.conf.all.secure_redirects=0 &>"/dev/null"
    sysctl -w net.ipv4.conf.default.secure_redirects=0 &>"/dev/null"
    sysctl -w net.ipv6.conf.all.accept_redirects=0 &>"/dev/null"
    sysctl -w net.ipv6.conf.default.accept_redirects=0 &>"/dev/null"
    sysctl -w net.ipv4.conf.all.send_redirects=0 &>"/dev/null"
    sysctl -w net.ipv4.conf.default.send_redirects=0 &>"/dev/null"

    # Enable Ignoring to ICMP Request
    sysctl -w net.ipv4.icmp_echo_ignore_all=1 &>"/dev/null"

    # Disable IPv6
    sysctl -w net.ipv6.conf.all.disable_ipv6=1 &>"/dev/null"
    sysctl -w net.ipv6.conf.default.disable_ipv6=1 &>"/dev/null"

    msg "applied sysctl rules"
}

check_root
check_backup_dir

# backup resolve.conf
backup_resolv_conf

# backup iptables rules
backup_iptables

# backup sysctl rules
backup_sysctl

# iptables rules
flush_iptables
apply_iptables_rules

# generate new resolv.conf
gen_resolv_conf

# apply new sysctl rules
apply_sysctl_rules