#include <sys/ioctl.h>
#include <sys/types.h>

#ifndef __user
#define __user
#endif

typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;

__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;

typedef __s8  s8;
typedef __u8  u8;
typedef __s16 s16;
typedef __u16 u16;
typedef __s32 s32;
typedef __u32 u32;
typedef __s64 s64;
typedef __u64 u64;
typedef s64	ktime_t;

struct list_head {
	struct list_head *next, *prev;
};

#define KGSL_IOC_TYPE 0x09

/* --- context flags --- */
#define KGSL_CONTEXT_SAVE_GMEM		0x00000001
#define KGSL_CONTEXT_NO_GMEM_ALLOC	0x00000002
/* This is a cmdbatch exclusive flag - use the CMDBATCH equivalent instead */
#define KGSL_CONTEXT_SUBMIT_IB_LIST	0x00000004
#define KGSL_CONTEXT_CTX_SWITCH		0x00000008
#define KGSL_CONTEXT_PREAMBLE		0x00000010
#define KGSL_CONTEXT_TRASH_STATE	0x00000020
#define KGSL_CONTEXT_PER_CONTEXT_TS	0x00000040
#define KGSL_CONTEXT_USER_GENERATED_TS	0x00000080
/* This is a cmdbatch exclusive flag - use the CMDBATCH equivalent instead */
#define KGSL_CONTEXT_END_OF_FRAME	0x00000100
#define KGSL_CONTEXT_NO_FAULT_TOLERANCE 0x00000200
/* This is a cmdbatch exclusive flag - use the CMDBATCH equivalent instead */
#define KGSL_CONTEXT_SYNC               0x00000400
#define KGSL_CONTEXT_PWR_CONSTRAINT     0x00000800
#define KGSL_CONTEXT_PRIORITY_MASK      0x0000F000
#define KGSL_CONTEXT_PRIORITY_SHIFT     12
#define KGSL_CONTEXT_PRIORITY_UNDEF     0

#define KGSL_CONTEXT_IFH_NOP            0x00010000
#define KGSL_CONTEXT_SECURE             0x00020000
#define KGSL_CONTEXT_NO_SNAPSHOT        0x00040000
#define KGSL_CONTEXT_SPARSE             0x00080000

#define KGSL_CONTEXT_PREEMPT_STYLE_MASK       0x0E000000
#define KGSL_CONTEXT_PREEMPT_STYLE_SHIFT      25
#define KGSL_CONTEXT_PREEMPT_STYLE_DEFAULT    0x0
#define KGSL_CONTEXT_PREEMPT_STYLE_RINGBUFFER 0x1
#define KGSL_CONTEXT_PREEMPT_STYLE_FINEGRAIN  0x2

#define KGSL_CONTEXT_TYPE_MASK          0x01F00000
#define KGSL_CONTEXT_TYPE_SHIFT         20
#define KGSL_CONTEXT_TYPE_ANY		0
#define KGSL_CONTEXT_TYPE_GL		1
#define KGSL_CONTEXT_TYPE_CL		2
#define KGSL_CONTEXT_TYPE_C2D		3
#define KGSL_CONTEXT_TYPE_RS		4
#define KGSL_CONTEXT_TYPE_VK		5
#define KGSL_CONTEXT_TYPE_UNKNOWN	0x1E

#define KGSL_CONTEXT_INVALIDATE_ON_FAULT 0x10000000
#define KGSL_CONTEXT_LPAC 0x20000000
#define KGSL_CONTEXT_FAULT_INFO	  0x40000000

#define KGSL_CONTEXT_INVALID 0xffffffff

/* Flags for GPU command objects */
#define KGSL_CMDLIST_IB                  0x00000001U
#define KGSL_CMDLIST_CTXTSWITCH_PREAMBLE 0x00000002U
#define KGSL_CMDLIST_IB_PREAMBLE         0x00000004U

#define KGSL_MEMFLAGS_USE_CPU_MAP (1ULL << 28)
#define KGSL_MEMFLAGS_SPARSE_PHYS (1ULL << 29)
#define KGSL_MEMFLAGS_SPARSE_VIRT (1ULL << 30)
#define KGSL_MEMFLAGS_IOCOHERENT  (1ULL << 31)
#define KGSL_MEMFLAGS_GUARD_PAGE  (1ULL << 33)
#define KGSL_MEMFLAGS_VBO         (1ULL << 34)
#define KGSL_MEMFLAGS_SECURE       (1ULL << 3)
#define KGSL_MEMFLAGS_GPUREADONLY  (1ULL << 24)
#define KGSL_MEMFLAGS_GPUWRITEONLY (1ULL << 25)
#define KGSL_MEMFLAGS_FORCE_32BIT  (1ULL << 32)

#define CMDLIST_FLAGS \
	(KGSL_CMDLIST_IB | \
	 KGSL_CMDLIST_CTXTSWITCH_PREAMBLE | \
	 KGSL_CMDLIST_IB_PREAMBLE)

/* create a draw context, which is used to preserve GPU state.
 * The flags field may contain a mask KGSL_CONTEXT_*  values
 */
struct kgsl_drawctxt_create {
	unsigned int flags;
	unsigned int drawctxt_id; /*output param */
};

#define IOCTL_KGSL_DRAWCTXT_CREATE \
	_IOWR(KGSL_IOC_TYPE, 0x13, struct kgsl_drawctxt_create)

/* destroy a draw context */
struct kgsl_drawctxt_destroy {
	unsigned int drawctxt_id;
};

#define IOCTL_KGSL_DRAWCTXT_DESTROY \
	_IOW(KGSL_IOC_TYPE, 0x14, struct kgsl_drawctxt_destroy)

/* Macros to be used in kgsl_pagefault_report structure */
#define KGSL_PAGEFAULT_TYPE_NONE                  0
#define KGSL_PAGEFAULT_TYPE_READ                  (1 << 0)
#define KGSL_PAGEFAULT_TYPE_WRITE                 (1 << 1)
#define KGSL_PAGEFAULT_TYPE_TRANSLATION           (1 << 2)
#define KGSL_PAGEFAULT_TYPE_PERMISSION            (1 << 3)
#define KGSL_PAGEFAULT_TYPE_EXTERNAL              (1 << 4)
#define KGSL_PAGEFAULT_TYPE_TRANSACTION_STALLED   (1 << 5)

/**
 * struct kgsl_pagefault_report - Descriptor for each page fault
 * @fault_addr: page fault address
 * @fault_type: type of page fault
 *
 * Contains information about supported GPU page fault.
 * Supported fault type: KGSL_PAGEFAULT_TYPE_*
 */
struct kgsl_pagefault_report {
	__u64 fault_addr;
	/* private: reserved for future use */
	__u64 reserved[2];
	__u32 fault_type;
	/* private: padding for 64 bit compatibility */
	__u32 __pad;
};

/**
 * struct kgsl_fault_node - GPU fault descriptor
 * @node: List node for list of faults
 * @type: Type of fault
 * @priv: Pointer to type specific fault
 * @time: Time when fault was observed
 */
struct kgsl_fault_node {
	struct list_head node;
	u32 type;
	void *priv;
	ktime_t time;
};

/* Macros for fault type used in kgsl_fault structure */
#define KGSL_FAULT_TYPE_NO_FAULT    0
#define KGSL_FAULT_TYPE_PAGEFAULT   1
#define KGSL_FAULT_TYPE_MAX         2

/**
 * struct kgsl_fault - Descriptor for each GPU fault type
 * @fault: User memory pointer to list of specific fault type
 * @type: Type of gpu fault
 * @count: Number of entries in @fault
 * @size: Size of each entry in @fault in bytes
 *
 * Contains information about each GPU fault type. If user passes 0 for all the fields, KGSL
 * will return the @count and @type of fault. Based on this, user can allocate a buffer for
 * specific fault type, fill the @fault and specify the structure size of type specific fault
 * in @size. User can walk through @fault list to parse the fault type specific information.
 *
 * Supported type: KGSL_FAULT_TYPE_*
 */
struct kgsl_fault {
	__u64 fault;
	__u32 type;
	__u32 count;
	__u32 size;
	/* private: padding for 64 bit compatibility */
	__u32 padding;
};

/**
 * struct kgsl_fault_report - Container for list of GPU faults
 * @faultlist: User memory pointer to list of fault descriptor &struct kgsl_fault
 * @faultnents: Number of entries in @faultlist. Each entry corresponds to a fault type i.e.
 * KGSL_FAULT_TYPE_*
 * @faultsize: Size of each entry in @faultlist in bytes
 * @context_id: ID of a KGSL context
 *
 * Returns a list of GPU faults for a context identified by @context_id. If the user specifies
 * @context_id only, then KGSL will set the @faultnents to the number of fault types it has
 * for that context.
 *
 * User is expected to allocate an array of @struct kgsl_fault with @faultnents number of entries
 * and fill the @faultlist field. On calling @IOCTL_KGSL_GET_FAULT_REPORT, KGSL will return the
 * type and count for each fault. Based on this, user needs to update the @kgsl_fault structure.
 * Then, it should call the @IOCTL_KGSL_GET_FAULT_REPORT again for kernel to fill the fault
 * information.
 */
struct kgsl_fault_report {
	__u64 faultlist;
	__u32 faultnents;
	__u32 faultsize;
	__u32 context_id;
	/* private: padding for 64 bit compatibility */
	__u32 padding;
};

#define IOCTL_KGSL_GET_FAULT_REPORT \
	_IOWR(KGSL_IOC_TYPE, 0x5E, struct kgsl_fault_report)

	/**
 * struct kgsl_gpuobj_alloc - Argument to IOCTL_KGSL_GPUOBJ_ALLOC
 * @size: Size in bytes of the object to allocate
 * @flags: mask of KGSL_MEMFLAG_* bits
 * @va_len: Size in bytes of the virtual region to allocate
 * @mmapsize: Returns the mmap() size of the object
 * @id: Returns the GPU object ID of the new object
 * @metadata_len: Length of the metdata to copy from the user
 * @metadata: Pointer to the user specified metadata to store for the object
 */
struct kgsl_gpuobj_alloc {
	__u64 size;
	__u64 flags;
	__u64 va_len;
	__u64 mmapsize;
	unsigned int id;
	unsigned int metadata_len;
	__u64 metadata;
};

/**
 * struct kgsl_gpuobj_free - Argument to IOCTL_KGLS_GPUOBJ_FREE
 * @flags: Mask of: KGSL_GPUOBJ_FREE_ON_EVENT
 * @priv: Pointer to the private object if KGSL_GPUOBJ_FREE_ON_EVENT is
 * specified
 * @id: ID of the GPU object to free
 * @type: If KGSL_GPUOBJ_FREE_ON_EVENT is specified, the type of asynchronous
 * event to free on
 * @len: Length of the data passed in priv
 */
struct kgsl_gpuobj_free {
	__u64 flags;
	__u64 __user priv;
	unsigned int id;
	unsigned int type;
	unsigned int len;
};

#define IOCTL_KGSL_GPUOBJ_FREE \
	_IOW(KGSL_IOC_TYPE, 0x46, struct kgsl_gpuobj_free)

/**
 * struct kgsl_gpuobj_info - argument to IOCTL_KGSL_GPUOBJ_INFO
 * @gpuaddr: GPU address of the object
 * @flags: Current flags for the object
 * @size: Size of the object
 * @va_len: VA size of the object
 * @va_addr: Virtual address of the object (if it is mapped)
 * id - GPU object ID of the object to query
 */
struct kgsl_gpuobj_info {
	__u64 gpuaddr;
	__u64 flags;
	__u64 size;
	__u64 va_len;
	__u64 va_addr;
	unsigned int id;
};

#define IOCTL_KGSL_GPUOBJ_INFO \
	_IOWR(KGSL_IOC_TYPE, 0x47, struct kgsl_gpuobj_info)

/* Let the user know that this header supports the gpuobj metadata */
#define KGSL_GPUOBJ_ALLOC_METADATA_MAX 64

#define IOCTL_KGSL_GPUOBJ_ALLOC \
	_IOWR(KGSL_IOC_TYPE, 0x45, struct kgsl_gpuobj_alloc)

/**
 * struct kgsl_command_object - GPU command object
 * @offset: GPU address offset of the object
 * @gpuaddr: GPU address of the object
 * @size: Size of the object
 * @flags: Current flags for the object
 * @id - GPU command object ID
 */
struct kgsl_command_object {
	__u64 offset;
	__u64 gpuaddr;
	__u64 size;
	unsigned int flags;
	unsigned int id;
};

/**
 * struct kgsl_gpu_command - Argument for IOCTL_KGSL_GPU_COMMAND
 * @flags: Current flags for the object
 * @cmdlist: List of kgsl_command_objects for submission
 * @cmdsize: Size of kgsl_command_objects structure
 * @numcmds: Number of kgsl_command_objects in command list
 * @objlist: List of kgsl_command_objects for tracking
 * @objsize: Size of kgsl_command_objects structure
 * @numobjs: Number of kgsl_command_objects in object list
 * @synclist: List of kgsl_command_syncpoints
 * @syncsize: Size of kgsl_command_syncpoint structure
 * @numsyncs: Number of kgsl_command_syncpoints in syncpoint list
 * @context_id: Context ID submitting the kgsl_gpu_command
 * @timestamp: Timestamp for the submitted commands
 */
struct kgsl_gpu_command {
	__u64 flags;
	__u64 __user cmdlist;
	unsigned int cmdsize;
	unsigned int numcmds;
	__u64 __user objlist;
	unsigned int objsize;
	unsigned int numobjs;
	__u64 __user synclist;
	unsigned int syncsize;
	unsigned int numsyncs;
	unsigned int context_id;
	unsigned int timestamp;
};

#define IOCTL_KGSL_GPU_COMMAND \
	_IOWR(KGSL_IOC_TYPE, 0x4A, struct kgsl_gpu_command)