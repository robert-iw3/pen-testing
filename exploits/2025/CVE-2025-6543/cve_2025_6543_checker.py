#!/usr/bin/env python3
"""
Enhanced CVE-2025-6543 Checker: multi-host, multi-port support + Exploit Stub
"""
import argparse
import re
import subprocess
import sys
import socket
from pathlib import Path

# Optional progress bar for scanning
try:
    from tqdm import tqdm
except ImportError:
    def tqdm(x, **kwargs): return x

# Fixed builds mapping; expand as new branches appear
SAFE = {
    "14.1":      (47, 46),
    "13.1":      (59, 19),
    "13.1FIPS":  (37, 235),
    "13.1NDCPP": (37, 236),
    "12.1":      (55, 328),
}

# Regex to capture branch, build, optional tag
BANNER_RX = re.compile(
    r"(?:NetScaler|NS).*?(?P<branch>\d+\.\d+)"
    r"(?:[-_](?P<build_major>\d+)\.(?P<build_minor>\d+))?"
    r"(?:[-_](?P<tag>FIPS|NDCPP))?"
)

def parse_build(text: str):
    m = BANNER_RX.search(text)
    if not m:
        return None
    branch = m.group('branch')
    major = int(m.group('build_major') or 0)
    minor = int(m.group('build_minor') or 0)
    tag = m.group('tag') or ''
    key = branch + tag
    return key, (major, minor)


def vulnerable(key, build):
    safe = SAFE.get(key)
    return True if safe is None else build < safe


def is_port_open(host, port, timeout=2, verbose=False):
    if verbose:
        print(f"[DEBUG] Checking TCP {host}:{port}")
    try:
        with socket.create_connection((host, port), timeout=timeout):
            if verbose:
                print(f"[DEBUG] Open {host}:{port}")
            return True
    except Exception as e:
        if verbose:
            print(f"[DEBUG] Closed {host}:{port}: {e}")
        return False


def snmp_banner(host, community, timeout=3, verbose=False):
    if verbose:
        print(f"[DEBUG] SNMP grab {host} (community={community})")
    try:
        out = subprocess.check_output([
            "snmpget", "-v2c", "-c", community,
            "-Oqv", host, "1.3.6.1.2.1.1.1.0"
        ], timeout=timeout, universal_newlines=True, stderr=subprocess.DEVNULL)
        banner = out.strip()
        if verbose:
            print(f"[DEBUG] SNMP banner: {banner}")
        return banner
    except Exception as e:
        if verbose:
            print(f"[DEBUG] SNMP failed: {e}")
        return ""


def cli_banner(host, user, password, verbose=False):
    if verbose:
        print(f"[DEBUG] SSH grab {host} (user={user})")
    try:
        out = subprocess.check_output([
            "sshpass", "-p", password,
            "ssh", "-oBatchMode=yes", "-oStrictHostKeyChecking=no",
            f"{user}@{host}", "show version | head -n 6"
        ], timeout=5, universal_newlines=True, stderr=subprocess.DEVNULL)
        if verbose:
            print(f"[DEBUG] SSH banner: {out.strip()}")
        return out
    except Exception as e:
        if verbose:
            print(f"[DEBUG] SSH failed: {e}")
        return ""


def exploit_probe(host, port, verbose=False):
    if verbose:
        print(f"[DEBUG] Exploit stub {host}:{port}")
    print(f"[i] {host}:{port} - exploit probe not implemented")


def check_host_port(host, port, args, out_fh=None):
    # 1) reachability
    if not is_port_open(host, port, verbose=args.verbose):
        print(f"[!] {host}:{port} - unreachable")
        return

    # 2) banner
    banner = ''
    origin = ''
    if args.snmp:
        banner = snmp_banner(host, args.community, verbose=args.verbose)
        origin = 'SNMP'
    if not banner and args.ssh_user and args.ssh_pass:
        banner = cli_banner(host, args.ssh_user, args.ssh_pass, verbose=args.verbose)
        origin = 'SSH'
    if not banner:
        print(f"[?] {host}:{port} - no banner")
        return

    parsed = parse_build(banner)
    if not parsed:
        print(f"[?] {host}:{port} - unknown banner")
        return

    key, build = parsed
    state = "VULNERABLE ⚠️" if vulnerable(key, build) else "PATCHED ✅"
    print(f"[{state}] {host}:{port} -> {key} {build[0]}.{build[1]} via {origin}")

    if args.output:
        out_fh.write(f"{host},{port},{key},{build[0]}.{build[1]},{state}\n")

    if args.exploit and state == "PATCHED ✅":
        exploit_probe(host, port, verbose=args.verbose)


def main():
    parser = argparse.ArgumentParser(
        description="CVE-2025-6543 multi-host, multi-port checker",
        formatter_class=argparse.RawTextHelpFormatter
    )
    # debug
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")

    # hosts input
    host_grp = parser.add_mutually_exclusive_group(required=True)
    host_grp.add_argument("-H", "--hosts", nargs='+', metavar="HOST",
                          help="IPs/FQDNs list")
    host_grp.add_argument("-f", "--file", type=Path, metavar="FILE",
                          help="File with one host per line")

    # ports input
    port_grp = parser.add_mutually_exclusive_group(required=True)
    port_grp.add_argument("-p", "--port", type=int, help="Single TCP port to test")
    port_grp.add_argument("-P", "--ports-file", type=Path,
                          help="File with one port per line")

    # connection
    parser.add_argument("-c", "--community", default="public",
                        help="SNMP community (default: public)")
    parser.add_argument("--no-snmp", dest="snmp", action="store_false",
                        help="Disable SNMP")
    parser.add_argument("--ssh-user", help="SSH username")
    parser.add_argument("--ssh-pass", help="SSH password")

    # exploit stub
    parser.add_argument("-x", "--exploit", action="store_true",
                        help="Run exploit probe stub")

    # output CSV
    parser.add_argument("-o", "--output", type=Path,
                        help="Write CSV to file")

    args = parser.parse_args()

    # build host list
    if args.file:
        hosts = [h.strip() for h in args.file.read_text().splitlines() if h.strip()]
    else:
        hosts = args.hosts
    # build port list
    if args.ports_file:
        ports = []
        for line in args.ports_file.read_text().splitlines():
            line = line.strip()
            if not line: continue
            try:
                ports.append(int(line))
            except ValueError:
                print(f"[!] Invalid port: {line}")
        if not ports:
            print("[!] No valid ports found in file")
            sys.exit(1)
    else:
        ports = [args.port]

    # open CSV if needed
    out_fh = None
    if args.output:
        try:
            out_fh = open(args.output, 'w')
            out_fh.write("host,port,branch,build,state\n")
        except Exception as e:
            print(f"[!] Cannot open output: {e}")
            sys.exit(1)

    # scan
    for host in tqdm(hosts, desc="Scanning hosts"):
        for port in ports:
            check_host_port(host, port, args, out_fh)

    if out_fh:
        out_fh.close()
        print(f"[i] Results -> {args.output}")

if __name__ == "__main__":
    main()