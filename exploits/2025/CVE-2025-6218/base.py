from __future__ import annotations
from rartypes import BlockType, BlockFlags, ExtraAreaType, GeneralExtraAreaType
from typing import List, Optional, Any
import leb128
from utils.bytes import CRC, MixinBytePackingMixin, BlockBytePackingMixin

class ExtraAreaMixin(MixinBytePackingMixin):
    def __init__(self):
        self.type:ExtraAreaType
        self.data:bytes = b""

    def mixin_compile(self) -> bytes:
        return self.data

class MainExtraMixin():
    type:GeneralExtraAreaType

class ExtraArea(MixinBytePackingMixin):
    def __init__(self, mixin=None):
        self.type:ExtraAreaType
        self.data:bytes = b""

    def compile(self) -> bytes:
        #print(self.mixin_compile())
        block_bytes = self.type + self.mixin_compile()
        size = len(block_bytes)
        return leb128.u.encode(size) + block_bytes

    def mixin_compile(self) -> bytes:
        raise NotImplementedError("Define mixin_compile() in your class")

class ArchiveBlockMixin(MixinBytePackingMixin):
    def __init__(self, mixin=None):
        self.type:BlockType
        self.flags:BlockFlags
        self.extras:List[ExtraArea]
        self.data:bytes

    def mixin_compile(self) -> bytes:
        raise NotImplementedError("Define mixin_compile() in your class")

    def add_extra(self, extra:ExtraArea):
        self.extras.append(extra)
        if BlockFlags.HAS_EXTRA not in self.flags:
            self.flags |= BlockFlags.HAS_EXTRA

    def add_data(self, data:bytes):
        self.data = data
        if BlockFlags.HAS_DATA not in self.flags:
            self.flags |= BlockFlags.HAS_DATA

class ArchiveBlock(BlockBytePackingMixin):
    def __init__(self):
        self.type:Any
        self.flags:BlockFlags = BlockFlags.NONE
        self.extras: List[ExtraArea] = []
        self.data:bytes = b""

    def compile(self) -> bytes:
        block_bytes = self.type + self.flags
        extra_bytes = b""
        if BlockFlags.HAS_EXTRA & self.flags:
            for extra in self.extras:
                extra_bytes += extra.compile()
            extra_size = leb128.u.encode(len(extra_bytes))
            block_bytes += extra_size

        if BlockFlags.HAS_DATA in self.flags:
            data_size = leb128.u.encode(len(self.data))
            block_bytes += data_size

        mixin_bytes = self.mixin_compile()
        block_bytes = block_bytes + mixin_bytes
        if BlockFlags.HAS_EXTRA & self.flags:
            block_bytes += extra_bytes
        block_bytes = leb128.u.encode(len(block_bytes)) + block_bytes
        return CRC(block_bytes) + block_bytes  + self.data

    def mixin_compile(self) -> bytes:
        raise NotImplementedError("Define mixin_compile() in your class")

    def add_etra(self, extra_area:ExtraArea):
        self.flags |= BlockFlags.HAS_EXTRA
        self.extras.append(extra_area)