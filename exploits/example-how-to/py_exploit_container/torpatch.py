#!/usr/bin/env python3

"""
torpatch.py
--------------------------------
Patch Python scripts to route requests through Tor via Privoxy with random real-browser User-Agent.

Usage:
    python3 torpatch.py script1.py script2.py ...                # creates script1.torpatched.py
    python3 torpatch.py *.py --inplace                        # patches in-place
    python3 torpatch.py ./exploits --recursive --inplace       # patches every .py in tree
"""

import argparse
import sys
from pathlib import Path
import re

PATCH_MARKER = "class TorSession(_OriginalSession):"

PATCH_CODE = '''# TOR / PRIVOXY ANONYMIZATION PATCH - random real-browser User-Agent + force proxy + verify=False
import json
import random
from pathlib import Path
import requests
import requests.packages.urllib3

requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)

_UA_PATH = Path("/exploit-base/user_agents.json")

# Try to load the huge list from the container, fall back to a solid built-in list if missing
try:
    ua_data = json.load(_UA_PATH.open("r", encoding="utf-8"))
    USER_AGENTS = [item["ua"] for item in ua_data if isinstance(item, dict) and item.get("ua")]
except Exception:
    USER_AGENTS = [
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36 Edg/129.0.0.0",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36",
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36",
        "Mozilla/5.0 (X11; Linux x86_64; rv:130.0) Gecko/20100101 Firefox/130.0",
        "Mozilla/5.0 (iPhone; CPU iPhone OS 17_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) CriOS/130.0.6723.97 Mobile/15E148 Safari/604.1",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:130.0) Gecko/20100101 Firefox/130.0",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:130.0) Gecko/20100101 Firefox/130.0",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0 Safari/537.36 OPR/115.0.0.0",
    ]

def _get_random_ua():
    return random.choice(USER_AGENTS)

PROXIES = {
    "http":  "http://127.0.0.1:8118",
    "https": "http://127.0.0.1:8118",
}

# Core monkey-patch
from requests import sessions as _requests_sessions
from requests.structures import CaseInsensitiveDict

_OriginalSession = _requests_sessions.Session

class TorSession(_OriginalSession):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.proxies = PROXIES          # force Tor via Privoxy
        self.verify = False              # Tor exits often have bad certs

    def request(self, method, url, **kwargs):
        # Build final headers for this request
        final_headers = CaseInsensitiveDict(self.headers)  # start with session defaults
        if kwargs.get("headers"):
            final_headers.update(kwargs["headers"])

        # Inject random real-browser UA only if the code didn't set one
        if "User-Agent" not in final_headers and "user-agent" not in final_headers:
            final_headers["User-Agent"] = _get_random_ua()

        kwargs["headers"] = final_headers
        kwargs.setdefault("proxies", PROXIES)   # force again in case someone overwrote

        return super().request(method, url, **kwargs)

# Apply the patch
_requests_sessions.Session = TorSession
requests.Session = TorSession
'''

def patch_content(source: str) -> str:
    if PATCH_MARKER in source:
        return source  # already patched

    # Preserve shebang and encoding declaration (utf-8, iso-8859-1, etc.)
    match = re.match(r"(?s)(^#!.*\n)?(#.*coding[:=]\s*[\w.-]+\n)?", source)
    prefix_len = match.end() if match else 0

    patched = source[:prefix_len] + PATCH_CODE + "\n" + source[prefix_len:]
    return patched

def process_file(file_path: Path, inplace: bool, dry_run: bool = False):
    try:
        content = file_path.read_text(encoding="utf-8", errors="replace")
    except UnicodeDecodeError:
        try:
            content = file_path.read_text(encoding="latin1")
        except Exception as e:
            print(f"[ERROR] Could not read {file_path}: {e}")
            return

    patched_content = patch_content(content)

    if patched_content == content:
        print(f"[SKIP] Already patched: {file_path}")
        return

    if dry_run:
        print(f"[DRY-RUN] Would patch: {file_path}")
        return

    if inplace:
        file_path.write_text(patched_content, encoding="utf-8")
        print(f"[PATCHED inplace] {file_path}")
    else:
        output_path = file_path.parent / f"{file_path.stem}.torpatched{file_path.suffix}"
        output_path.write_text(patched_content, encoding="utf-8")
        print(f"[PATCHED] {file_path} â†’ {output_path}")

def main():
    parser = argparse.ArgumentParser(description="Patch Python scripts to use Tor + random UA via Privoxy")
    parser.add_argument("paths", nargs="+", type=Path, help="Files or directories to patch")
    parser.add_argument("--inplace", action="store_true", help="Modify files in-place")
    parser.add_argument("--recursive", "-r", action="store_true", help="Recurse into directories")
    parser.add_argument("--dry-run", action="store_true", help="Show what would be patched without writing")
    args = parser.parse_args()

    files = set()

    for p in args.paths:
        if p.is_file():
            if p.suffix == ".py":
                files.add(p)
        elif p.is_dir():
            if args.recursive:
                for py in p.rglob("*.py"):
                    files.add(py)
            else:
                for item in p.iterdir():
                    if item.is_file() and item.suffix == ".py":
                        files.add(item)
        else:
            print(f"[ERROR] Not found: {p}")
            sys.exit(1)

    if not files:
        print("No .py files found")
        sys.exit(0)

    for f in sorted(files):
        process_file(f, inplace=args.inplace, dry_run=args.dry_run)

if __name__ == "__main__":
    main()