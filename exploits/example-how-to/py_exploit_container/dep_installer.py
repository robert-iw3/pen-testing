#!/usr/bin/env python3

"""
Universal Dependency Installer for Python Scripts (Alpine + venv aware)

Scans .py files → extracts THIRD-PARTY imports → COLLECTS UNIQUE pip packages → BATCH-INSTALLS all required
Alpine system deps FIRST (known + core build env) → BATCH-PIP-INSTALL ALL at once (handles transitive deps).

"""

import ast
import importlib.util
import subprocess
import sys
from pathlib import Path
import tempfile

# ----------------------------------------------------------------------
# CORE BUILD DEPS: Always batch-install these first (idempotent, ~50MB)
# ----------------------------------------------------------------------
BROAD_CORE_DEPS = [
    "gcc", "g++", "make", "cmake", "pkgconfig",
    "python3-dev", "musl-dev", "linux-headers",
    "openssl-dev", "libffi-dev", "readline-dev",
    "libxml2-dev", "libxslt-dev",
    "zlib-dev", "bzip2-dev", "xz-dev", "expat-dev",
    "libjpeg-turbo-dev", "libpng-dev",
    "rust", "cargo",  # for cryptography/bcrypt/etc.
    "postgresql-dev", "mariadb-dev",
    "yaml-dev", "protobuf-dev", "lz4-dev", "zstd-dev", "brotli-dev",
    "openblas-dev", "lapack-dev", "gfortran",
]

# ----------------------------------------------------------------------
# EXPANDED: 50+ COMMON PACKAGES → EXACT EXTRA DEPS (beyond core)
# Researched from SO/GitHub/Alpine wikis/PyPI (Nov 2025)
# ----------------------------------------------------------------------
KNOWN_SYSTEM_DEPS = {
    # Images/Graphics
    "pillow": ["freetype-dev", "tiff-dev", "lcms2-dev", "openjpeg-dev", "libwebp-dev", "libimagequant-dev", "harfbuzz-dev", "fribidi-dev"],
    "opencv-python": ["ffmpeg-dev", "v4l-utils-dev", "libgphoto2-dev"],
    "matplotlib": ["freetype-dev", "cairo-dev", "pango-dev", "pixman-dev", "gtk+3.0-dev", "glib-dev"],
    "pycairo": ["cairo-dev"],
    "wand": ["imagemagick-dev", "libltdl-dev"],

    # XML/HTML
    "lxml": ["libxml2-dev", "libxslt-dev"],

    # Crypto/Auth
    "cryptography": ["openssl-dev"],
    "bcrypt": ["openssl-dev"],
    "argon2-cffi": ["libsodium-dev"],
    "pycryptodome": ["gcc"],  # rare

    # DB
    "psycopg2": ["postgresql-dev"],
    "psycopg": ["postgresql-dev"],  # psycopg3
    "mysqlclient": ["mariadb-dev"],
    "pymysql": [],
    "aiosqlite": [],

    # YAML/Serial
    "pyyaml": ["yaml-dev"],

    # NumPy/Sci/ML
    "numpy": ["numpy-dev", "openblas-dev"],
    "scipy": ["scipy-dev", "lapack-dev", "gfortran"],
    "scikit-learn": ["openblas-dev", "lapack-dev"],
    "pandas": ["pandas-dev"],  # optional
    "pyarrow": ["arrow-dev", "lz4-dev", "zstd-dev", "brotli-dev"],
    "torch": ["blas-dev"],  # if no wheel
    "tensorflow": ["protobuf-dev"],  # huge anyway

    # Async/Gevent
    "gevent": ["libev-dev"],
    "uvloop": ["libuv-dev"],
    "eventlet": ["greenlet"],  # pip

    # GUI/Browser
    "pygame": ["sdl2-dev", "sdl2_image-dev", "sdl2_mixer-dev", "sdl2_ttf-dev", "portaudio-dev"],
    "tkinter": ["tk-dev"],  # py3-tkinter
    "pyqt5": ["qt5-qtbase-dev"],  # massive
    "pygobject": ["gobject-introspection-dev"],

    # Other common exploit/pentest
    "impacket": [],
    "scapy": ["libpcap-dev"],
    "paramiko": [],
    "pywinrm": [],
    "requests": [],
    "beautifulsoup4": [],

    # Niche but common
    "rdkit": ["boost-dev", "eigen-dev"],  # chem
    "biopython": ["zlib-dev"],  # bio
    "rasterio": ["gdal-dev"],  # GIS huge
    "fiona": ["gdal-dev"],

    # Web/Async
    "playwright": ["libglib2.0-dev"],  # pip handles most
}

# Map top-level import → pip package (expanded)
TOPLEVEL_TO_PIP = {
    "bs4": "beautifulsoup4",
    "PIL": "pillow",
    "sklearn": "scikit-learn",
    "yaml": "PyYAML",
    "cv2": "opencv-python",
    "Crypto": "pycryptodome",
    "Cryptodome": "pycryptodome",
    "OpenSSL": "pyOpenSSL",
    "gi": "pygobject",
    "dateutil": "python-dateutil",
    "six": "six",
    "tkinter": "tk",  # special apk
    # Add more mappings as needed
}

# Stdlib to ignore (common false positives)
STDLIB_MODULES = {
    'os', 'sys', 'json', 'time', 'datetime', 'collections', 'itertools', 'functools',
    'threading', 'subprocess', 'glob', 'pathlib', 'shutil', 'tempfile', 'logging',
    'urllib', 'http', 'socket', 'base64', 'hashlib', 'hmac', 'secrets', 'random',
    're', 'csv', 'xml', 'html', 'email', 'smtplib', 'sqlite3', 'math', 'statistics',
    'argparse', 'getopt', 'configparser', 'enum', 'abc', 'typing', 'asyncio', 'ctypes',
    'inspect', 'traceback', 'warnings', 'weakref', 'copy', 'pprint', 'platform',
}

def get_imported_modules(file_path: str) -> set[str]:
    """Parse .py → top-level imports (excludes relative/.)"""
    try:
        with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
            tree = ast.parse(f.read(), filename=file_path)
        modules = set()
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    mod = alias.name.split(".")[0]
                    modules.add(mod)
            elif isinstance(node, ast.ImportFrom):
                if node.module and node.module.startswith("."):
                    continue  # relative
                mod = node.module.split(".")[0] if node.module else None
                if mod:
                    modules.add(mod)
        return modules - STDLIB_MODULES  # filter stdlib
    except Exception as e:
        print(f"[ERROR] Parsing {file_path}: {e}")
        return set()

def is_module_installed(module_name: str) -> bool:
    return importlib.util.find_spec(module_name) is not None

def main():
    import argparse
    parser = argparse.ArgumentParser(description="Universal Python/Alpine dep installer (batch + fallback)")
    parser.add_argument("paths", nargs="*", default=["."], help="Files/dirs (default: .)")
    parser.add_argument("--recursive", "-r", action="store_true")
    args = parser.parse_args()

    files = set()
    for input_path in args.paths:
        p = Path(input_path)
        if p.is_dir():
            pattern = "**/*.py" if args.recursive else "*.py"
            files.update(p.glob(pattern))
        elif p.suffix.lower() == ".py":
            files.add(p)

    if not files:
        print("[INFO] No .py files found.")
        return

    print(f"[INFO] Scanning {len(files)} Python file(s)...")

    # COLLECT ALL UNIQUE THIRD-PARTY MODULES
    all_modules = set()
    has_selenium = False
    has_playwright = False
    for f in files:
        if f.name == Path(__file__).name:
            continue  # skip self
        mods = get_imported_modules(str(f))
        all_modules.update(mods)
        if any(m.lower() == "selenium" for m in mods):
            has_selenium = True
        if any(m.lower() == "playwright" for m in mods):
            has_playwright = True

    if not all_modules:
        print("[INFO] No third-party imports detected.")
        return

    print(f"[INFO] Detected {len(all_modules)} unique modules: {', '.join(sorted(all_modules))}")

    # MISSING → PIP NAMES (dedup)
    missing_modules = {m for m in all_modules if not is_module_installed(m)}
    pip_names = list(set(TOPLEVEL_TO_PIP.get(m, m) for m in missing_modules))
    print(f"[INFO] Need to install {len(pip_names)} pip pkg(s): {', '.join(pip_names)}")

    if not pip_names:
        print("[INFO] All deps already installed!")
        return

    # BATCH 1: System deps for ALL
    system_deps = set(BROAD_CORE_DEPS)
    for pip_name in pip_names:
        extras = KNOWN_SYSTEM_DEPS.get(pip_name.lower(), [])
        system_deps.update(extras)

    print(f"[INFO] Batch-installing {len(system_deps)} Alpine deps...")
    subprocess.check_call(["apk", "add", "--no-cache"] + list(system_deps))

    # Special browsers
    if has_selenium:
        print("[INFO] Selenium → Chromium + driver")
        subprocess.check_call(["apk", "add", "--no-cache",
                               "chromium", "chromium-chromedriver",
                               "ttf-dejavu", "fontconfig", "xvfb"])
    if has_playwright:
        print("[INFO] Playwright → deps")
        subprocess.check_call(["apk", "add", "--no-cache", "libglib2.0-dev"])

    # Upgrade pip ecosystem ONCE
    print("[INFO] Upgrading pip/setuptools/wheel...")
    subprocess.check_call([sys.executable, "-m", "pip", "install", "--upgrade", "--no-cache-dir",
                           "pip", "setuptools", "wheel", "cython"])  # cython helps builds

    # BATCH 2: pip install ALL (handles transitive deps!)
    print(f"[INFO] Batch-pip-installing {len(pip_names)} packages...")
    try:
        subprocess.check_call([sys.executable, "-m", "pip", "install", "--no-cache-dir"] + pip_names)
    except subprocess.CalledProcessError:
        print("[WARN] Batch failed → FALLBACK: Broad deps + individual retries")
        # Extra broad for edge cases
        fallback_deps = ["libcap-dev", "libpcap-dev", "libressl-dev", "boost-dev"]
        subprocess.check_call(["apk", "add", "--no-cache"] + fallback_deps)
        # Retry each individually
        for pip_name in pip_names:
            try:
                subprocess.check_call([sys.executable, "-m", "pip", "install", "--no-cache-dir", "--force-reinstall", pip_name])
            except subprocess.CalledProcessError as e:
                print(f"[ERROR] STILL failed {pip_name}: {e}")

    # Post-install specials
    if has_playwright:
        subprocess.check_call([sys.executable, "-m", "playwright", "install", "--with-deps", "chromium"])

    # VERIFY
    still_missing = [m for m in missing_modules if not is_module_installed(m)]
    if still_missing:
        print(f"[WARN] {len(still_missing)} modules still missing: {still_missing}")
    else:
        print("[GREEN CHECK] ALL deps installed & verified!")

if __name__ == "__main__":
    main()