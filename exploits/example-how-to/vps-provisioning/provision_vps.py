import json
import os
import time
import yaml
from typing import Dict, Any, List
import requests

# Requirements: pip install pyyaml python-digitalocean paramiko boto3 linode_api4
# For Linode: linode_api4
# WARNING: Secure credentials! Use environment vars or secrets manager in production.
# For AWS key creation, script will save private key if new.
# Added support for Vultr (via requests), Linode (via linode_api4), Hostinger (via requests, assumed endpoints), Fly.io (via requests)

try:
    import digitalocean
except ImportError:
    print("pip install python-digitalocean")
    exit(1)

try:
    import boto3
    from botocore.exceptions import ClientError
except ImportError:
    print("pip install boto3")
    exit(1)

try:
    import paramiko
except ImportError:
    print("pip install paramiko")
    exit(1)

try:
    from linode_api4 import LinodeClient, Instance
except ImportError:
    print("pip install linode_api4")
    exit(1)


def load_config(config_path: str) -> Dict[str, Any]:
    if not os.path.exists(config_path):
        raise FileNotFoundError(f"Config file not found: {config_path}")
    with open(config_path, 'r') as f:
        if config_path.endswith(('.yaml', '.yml')):
            return yaml.safe_load(f)
        elif config_path.endswith('.json'):
            return json.load(f)
        else:
            raise ValueError("Config must be YAML or JSON")


def deploy_digitalocean(config: Dict[str, Any]) -> str:
    token = config['credentials']['token']
    manager = digitalocean.Manager(token=token)
    droplet = digitalocean.Droplet(
        token=token,
        name=config['instance']['name'],
        region=config['instance']['region'],
        image=config['instance']['image'],
        size_slug=config['instance']['size'],
        ssh_keys=[config['instance']['ssh_pub_key_id']],  # Key ID
        backups=False
    )
    droplet.create()
    print(f"Creating droplet {droplet.name}...")
    # Wait for creation
    while droplet.get_status() != 'active':
        time.sleep(10)
        droplet.load()
    ip_address = droplet.ip_address
    print(f"Droplet IP: {ip_address}")
    # Firewall
    if 'networking' in config and 'firewall_rules' in config['networking']:
        inbound_rules: List = []
        for rule in config['networking']['firewall_rules']:
            ports_list = rule['ports'] if isinstance(rule['ports'], list) else [rule['ports']]
            for p in ports_list:
                inbound_rules.append(
                    digitalocean.InboundRule(
                        protocol=rule['protocol'],
                        ports=str(p),
                        sources=digitalocean.Sources(addresses=[rule['sources']])
                    )
                )
        firewall = digitalocean.Firewall(
            token=token,
            name=f"{droplet.name}-firewall",
            inbound_rules=inbound_rules,
            outbound_rules=[digitalocean.OutboundRule(protocol="all", ports="all", destinations=digitalocean.Destinations(addresses=["0.0.0.0/0"]))],
            droplet_ids=[droplet.id]
        )
        firewall.create()
        print("Firewall set up.")
    return ip_address


def deploy_aws(config: Dict[str, Any]) -> str:
    creds = config['credentials']
    instance_cfg = config['instance']
    region = instance_cfg.get('region', 'us-east-1')
    ec2 = boto3.client('ec2', aws_access_key_id=creds['access_key'], aws_secret_access_key=creds['secret_key'], region_name=region)
    key_name = instance_cfg.get('key_name', 'vps-key')
    private_key_path = instance_cfg['ssh_key']
    # Handle key pair
    try:
        ec2.describe_key_pairs(KeyNames=[key_name])
        print(f"Using existing key pair: {key_name}")
    except ClientError as e:
        if 'InvalidKeyPair.NotFound' in str(e):
            key_pair = ec2.create_key_pair(KeyName=key_name)
            with open(private_key_path, 'w') as f:
                f.write(key_pair['KeyMaterial'])
            os.chmod(private_key_path, 0o600)
            print(f"Created new key pair and saved private key to {private_key_path}")
        else:
            raise
    # Security group
    sg_name = f"{instance_cfg['name']}-sg"
    try:
        sg_resp = ec2.create_security_group(GroupName=sg_name, Description="VPS SG")
        sg_id = sg_resp['GroupId']
    except ClientError as e:
        if 'InvalidGroup.Duplicate' in str(e):
            resp = ec2.describe_security_groups(Filters=[{'Name': 'group-name', 'Values': [sg_name]}])
            sg_id = resp['SecurityGroups'][0]['GroupId']
        else:
            raise
    # Authorize ingress
    if 'networking' in config and 'firewall_rules' in config['networking']:
        ip_perms = []
        for rule in config['networking']['firewall_rules']:
            ports_list = rule['ports'] if isinstance(rule['ports'], list) else [rule['ports']]
            for p in ports_list:
                ip_perms.append({
                    'IpProtocol': rule['protocol'],
                    'FromPort': int(p),
                    'ToPort': int(p),
                    'IpRanges': [{'CidrIp': rule['sources']}]
                })
        ec2.authorize_security_group_ingress(GroupId=sg_id, IpPermissions=ip_perms)
        print(f"Security rules added to {sg_id}")
    # Launch instance
    instances = ec2.run_instances(
        ImageId=instance_cfg['image'],
        MinCount=1, MaxCount=1,
        InstanceType=instance_cfg['size'],
        KeyName=key_name,
        SecurityGroupIds=[sg_id]
    )
    instance_id = instances['Instances'][0]['InstanceId']
    print(f"Launching instance {instance_id}...")
    waiter = ec2.get_waiter('instance_running')
    waiter.wait(InstanceIds=[instance_id])
    resp = ec2.describe_instances(InstanceIds=[instance_id])
    ip_address = resp['Reservations'][0]['Instances'][0]['PublicIpAddress']
    print(f"Instance IP: {ip_address}")
    return ip_address


def deploy_vultr(config: Dict[str, Any]) -> str:
    api_key = config['credentials']['api_key']
    instance_cfg = config['instance']
    url = "https://api.vultr.com/v2/instances"
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }
    data = {
        "region": instance_cfg['region'],
        "plan": instance_cfg['plan'],
        "os_id": instance_cfg['os_id'],
        "sshkey_id": instance_cfg.get('ssh_key_ids', []),
        "label": instance_cfg['name'],
        "hostname": instance_cfg.get('hostname', instance_cfg['name'])
    }
    if 'networking' in config:
        # Vultr firewalls are separate; create after
        pass
    response = requests.post(url, headers=headers, json=data)
    if response.status_code != 201:
        raise ValueError(f"Vultr creation failed: {response.text}")
    instance = response.json()['instance']
    instance_id = instance['id']
    print(f"Creating Vultr instance {instance_id}...")
    # Wait for active
    while True:
        resp = requests.get(f"https://api.vultr.com/v2/instances/{instance_id}", headers=headers)
        if resp.status_code == 200 and resp.json()['instance']['status'] == 'active':
            break
        time.sleep(10)
    ip_address = resp.json()['instance']['main_ip']
    print(f"Vultr IP: {ip_address}")
    # Firewall (separate endpoint)
    if 'networking' in config and 'firewall_rules' in config['networking']:
        fw_data = {
            "label": f"{instance_cfg['name']}-fw"
        }
        fw_resp = requests.post("https://api.vultr.com/v2/firewalls", headers=headers, json=fw_data)
        if fw_resp.status_code == 201:
            fw_id = fw_resp.json()['firewall_group']['id']
            for rule in config['networking']['firewall_rules']:
                ports_list = rule['ports'] if isinstance(rule['ports'], list) else [rule['ports']]
                for p in ports_list:
                    rule_data = {
                        "protocol": rule['protocol'].upper(),
                        "port": str(p),
                        "network": rule['sources'],
                        "notes": "From config"
                    }
                    requests.post(f"https://api.vultr.com/v2/firewalls/{fw_id}/rules", headers=headers, json=rule_data)
            # Attach to instance (Vultr attaches via instance ID? Note: Vultr firewalls attach to instances via /v2/firewalls/{id}/instances but API may vary; adjust if needed)
            print("Firewall created; attach manually if needed.")
    return ip_address


def deploy_linode(config: Dict[str, Any]) -> str:
    token = config['credentials']['token']
    instance_cfg = config['instance']
    client = LinodeClient(token)
    new_linode, root_pass = client.linode.instance_create(
        ltype=instance_cfg['size'],
        region=instance_cfg['region'],
        image=instance_cfg['image'],
        label=instance_cfg['name'],
        authorized_keys=[instance_cfg['ssh_key']],  # Public key string
        root_pass=instance_cfg.get('root_pass')
    )
    print(f"Creating Linode {new_linode.label}...")
    # Wait for active
    while new_linode.status != 'running':
        time.sleep(10)
        new_linode = Instance(client, new_linode.id)
    ip_address = new_linode.ipv4[0]
    print(f"Linode IP: {ip_address}")
    if root_pass:
        print(f"Root password: {root_pass}")
    # Networking: Linode uses Firewalls separate; create if needed
    if 'networking' in config and 'firewall_rules' in config['networking']:
        fw = client.networking.firewall_create(
            label=f"{instance_cfg['name']}-fw",
            devices={'linodes': [new_linode.id]}
        )
        for rule in config['networking']['firewall_rules']:
            ports_list = rule['ports'] if isinstance(rule['ports'], list) else [rule['ports']]
            fw.rule_create_inbound(
                protocol=rule['protocol'].upper(),
                ports=','.join(map(str, ports_list)),
                addresses={'ipv4': [rule['sources']]}
            )
        print("Firewall set up.")
    return ip_address


def deploy_hostinger(config: Dict[str, Any]) -> str:
    api_key = config['credentials']['api_key']
    instance_cfg = config['instance']
    url = "https://api.hostinger.com/v1/vps/virtual-machines"  # Assumed base URL
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }
    data = {
        "name": instance_cfg['name'],
        "data_center": instance_cfg['data_center'],
        "plan": instance_cfg['plan'],
        "os_template": instance_cfg['os_template'],
        "ssh_key": instance_cfg['ssh_key'],
        "hostname": instance_cfg.get('hostname', instance_cfg['name'])
    }
    response = requests.post(url, headers=headers, json=data)
    if response.status_code not in (200, 201):
        raise ValueError(f"Hostinger creation failed: {response.text}")
    vm = response.json()  # Assume returns VM details with ID
    vm_id = vm.get('id')  # Assume ID
    print(f"Creating Hostinger VM {vm_id}...")
    # Wait for provisioned (poll /vps/virtual-machines/{id})
    while True:
        resp = requests.get(f"{url}/{vm_id}", headers=headers)
        if resp.status_code == 200 and resp.json().get('status') == 'active':  # Assumed
            break
        time.sleep(10)
    ip_address = resp.json().get('ip_address')  # Assumed
    print(f"Hostinger IP: {ip_address}")
    # Firewall: Use /api/vps/v1/firewalls or similar; assumed separate
    if 'networking' in config and 'firewall_rules' in config['networking']:
        print("Hostinger firewall setup: Implement via /api/vps/v1/firewalls endpoint if available.")
    return ip_address


def deploy_fly(config: Dict[str, Any]) -> str:
    token = config['credentials']['token']
    instance_cfg = config['instance']
    app_name = instance_cfg['app_name']
    base_url = "https://api.machines.dev/v1"
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json"
    }
    # Create app if not exists
    app_url = f"{base_url}/apps/{app_name}"
    if requests.get(app_url, headers=headers).status_code == 404:
        requests.post(f"{base_url}/apps", headers=headers, json={"name": app_name, "org_slug": "personal"})  # Assume personal org
        print(f"Created Fly app {app_name}")
    # Create machine
    data = {
        "name": instance_cfg['name'],
        "region": instance_cfg['region'],
        "config": {
            "image": instance_cfg['image'],
            "guest": {"cpu_kind": "shared", "cpus": 1, "memory_mb": 256} if instance_cfg['size'] == 'shared-cpu-1x' else instance_cfg.get('guest', {}),
            "init": {"cmd": ["/bin/bash"]},  # For VPS-like
            "mounts": [],  # Optional
            "services": []  # For networking
        }
    }
    response = requests.post(f"{base_url}/apps/{app_name}/machines", headers=headers, json=data)
    if response.status_code != 200:
        raise ValueError(f"Fly creation failed: {response.text}")
    machine = response.json()
    machine_id = machine['id']
    print(f"Creating Fly machine {machine_id}...")
    # Wait for started
    while True:
        resp = requests.get(f"{base_url}/apps/{app_name}/machines/{machine_id}", headers=headers)
        if resp.status_code == 200 and resp.json()['state'] == 'started':
            break
        time.sleep(10)
    ip_address = resp.json()['private_ip']  # Fly uses 6pn IPs; public via services
    print(f"Fly Machine IP: {ip_address} (private; configure services for public)")
    # Networking: Add services to config for ports
    if 'networking' in config and 'firewall_rules' in config['networking']:
        # Update machine config with services
        services = []
        for rule in config['networking']['firewall_rules']:
            ports_list = rule['ports'] if isinstance(rule['ports'], list) else [rule['ports']]
            for p in ports_list:
                services.append({
                    "protocol": rule['protocol'],
                    "ports": [{"port": int(p)}],
                    "handlers": ["tcp"]  # or http etc.
                })
        update_data = {"config": {"services": services}}
        requests.post(f"{base_url}/apps/{app_name}/machines/{machine_id}", headers=headers, json=update_data)
        print("Fly services updated for networking.")
    # Note: For SSH, use fly ssh establish and fly ssh issue
    print("For SSH on Fly: Use 'fly ssh console -a {app_name}' after setting up.")
    return ip_address


def setup_vps_via_ssh(ip_address: str, config: Dict[str, Any]):
    private_key_path = config['instance']['ssh_key']
    if not os.path.exists(private_key_path):
        raise FileNotFoundError(f"Private key not found: {private_key_path}")
    key = paramiko.RSAKey.from_private_key_file(private_key_path)
    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    print(f"SSH to {ip_address}...")
    client.connect(hostname=ip_address, username='ubuntu', pkey=key, timeout=30)  # Assume ubuntu; for other OS, change to root or user
    commands = []
    # Base update
    commands.append('sudo apt update -y && sudo apt upgrade -y')
    # Provisions
    provisions = config.get('provision', [])
    if 'docker' in provisions:
        # Uninstall conflicting
        commands.append('for pkg in docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; do sudo apt-get remove $pkg -y || true; done')
        # Repo setup
        commands.append('sudo apt-get install ca-certificates curl gnupg -y')
        commands.append('sudo install -m 0755 -d /etc/apt/keyrings')
        commands.append('sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc')
        commands.append('sudo chmod a+r /etc/apt/keyrings/docker.asc')
        commands.append(r'''echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null''')
        commands.append('sudo apt-get update')
        # Install
        commands.append('sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin -y')
        # Verify
        commands.append('sudo docker run --rm hello-world')
        # Post-install
        commands.append('sudo usermod -aG docker ubuntu')
        commands.append('sudo systemctl enable --now docker')
        print("Docker provisioned. Reconnect SSH for non-sudo docker access.")
    if 'podman' in provisions:
        commands.append('sudo apt-get install podman -y')
    if 'python' in provisions:
        commands.append('sudo apt-get install python3 python3-pip python3-venv -y')
    # Tools
    if 'tools_to_install' in config:
        tools = ' '.join(config['tools_to_install'])
        commands.append(f'sudo apt-get install -y {tools}')
    # Clones
    if 'repos_to_clone' in config:
        for repo in config['repos_to_clone']:
            repo_name = repo.split('/')[-1].rstrip('.git')
            commands.append(f'git clone {repo} /home/ubuntu/{repo_name}')
    # Execute
    for cmd in commands:
        print(f"Exec: {cmd}")
        stdin, stdout, stderr = client.exec_command(cmd)
        out = stdout.read().decode().strip()
        err = stderr.read().decode().strip()
        if out: print(out)
        if err: print(f"ERR: {err}")
        if stderr.channel.recv_exit_status() != 0:
            print(f"Command failed: {cmd}")
    client.close()
    print("Setup complete.")


def main(config_path: str = 'config.yaml'):
    config = load_config(config_path)
    provider = config['provider'].lower()
    if provider == 'digitalocean':
        ip = deploy_digitalocean(config)
    elif provider == 'aws':
        ip = deploy_aws(config)
    elif provider == 'vultr':
        ip = deploy_vultr(config)
    elif provider == 'linode':
        ip = deploy_linode(config)
    elif provider == 'hostinger':
        ip = deploy_hostinger(config)
    elif provider == 'fly':
        ip = deploy_fly(config)
    else:
        raise ValueError(f"Provider {provider} unsupported")
    time.sleep(60)  # Wait for SSH ready
    setup_vps_via_ssh(ip, config)
    print(f"VPS ready at {ip}. SSH: ssh -i {config['instance']['ssh_key']} ubuntu@{ip}")


if __name__ == "__main__":
    import sys
    main(sys.argv[1] if len(sys.argv) > 1 else 'config.yaml')